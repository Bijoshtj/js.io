#!/usr/bin/env node
jsio=(function init(cloneFrom) {
    // We expect this code to be minified before production use, so we may
    // write code slightly more verbosely than we otherwise would.

    var INITIAL_FILE = '<initial file>';
    var MODULE_NOT_FOUND = 'MODULE_NOT_FOUND';

    // Should we parse syntax errors in the browser?
    var DEBUG = true;

    // Store a reference to the slice function for converting objects of
    // type arguments to type array.
    var SLICE = Array.prototype.slice;

    // js.io supports multiple JavaScript environments such as node.js and
    // most web browsers (IE, Firefox, WebKit).  The ENV object wraps
    // any utility functions that contain environment-specific code (e.g.
    // reading a file using node's `fs` library or a browser's
    // `XMLHttpRequest`).  Running js.io in other JavaScript environments
    // is as easy as implementing an environment object that conforms to
    // the abstract interface for an environment (provided below) and
    // calling `jsio.setEnv()`.
    var ENV;

    // Checks if the last character in a string is `/`.
    var rexpEndSlash = /(\/|\\)$/;
    var extensions = ['.js', '.ts'];

    function getModuleDefs (path, extension) {
      return extensions.map(function(ext) {
        var fullPath = path + ext;
        return jsio.__modules[fullPath] || new ModuleDef(fullPath);

      })
    }

    // Creates an object containing metadata about a module.
    function ModuleDef (path) {
      this.path = path;
      this.friendlyPath = path;

      util.splitPath(path, this);
      this.directory = util.resolve(ENV.getCwd(), this.directory);
    }

    ModuleDef.prototype.setBase = function (baseMod, basePath) {
      this.baseMod = baseMod;
      this.basePath = basePath + '/' + baseMod;
    };

    var HOST = /^([a-z][a-z0-9+\-\.]*:\/\/.*?\/)(.*)$/;
    var PROTOCOL = /^[a-z][a-z0-9+\-\.]*:/;

    // Utility functions
    var util = {
        // `util.bind` returns a function that, when called, will execute
        // the method passed in with the provided context and any additional
        // arguments passed to `util.bind`.
        //       util.bind(obj, 'f', a) -> function() { return obj.f(a); }
        //       util.bind(obj, g, a, b, c) -> function() { return g.call(g, a, b, c); }
        bind: function(context, method/*, args... */) {
          var args = SLICE.call(arguments, 2);
          return function () {
            method = (typeof method == 'string' ? context[method] : method);
            return method.apply(context, args.concat(SLICE.call(arguments, 0)));
          };
        },

        // `util.addEndSlash` accepts a string.  That string is returned with a `/`
        // appended if the string did not already end in a `/`.
        addEndSlash: function(str) {
          return rexpEndSlash.test(str) ? str : str + '/';
        },

        // `util.removeEndSlash` accepts a string.  It removes a trailing `/` if
        // one is found.
        removeEndSlash: function(str) {
          return str.replace(rexpEndSlash, '');
        },

        // `util.relative` accepts two paths (strings) and returns the second path
        // relative to the first.
        //
        //  - if `path` starts with `relativeTo`, then strip `path` off the
        //    `relativeTo` part
        //
        //         util.relative('abc/def/', 'abc') -> 'def'
        //
        //  - if `path` starts with some substring of `relativeTo`, remove
        //    this substring and add `../` for each remaining segment of
        //    `relativeTo`.
        //
        //         util.relative('abc/def/', 'abc/hij') -> '../def'
        //
        relative: function (relativeTo, path) {
          var len = relativeTo.length;
          if (path.substring(0, len) == relativeTo) {
            // if the relative path now starts with a path separator
            // either (/ or \), remove it
            /* Note: we're casting a boolean to an int by adding len to it */
            return path.slice(len + /[\/\\]/.test(path.charAt(len)));
          }

          var sA = util.removeEndSlash(path).split(ENV.pathSep),
            sB = util.removeEndSlash(relativeTo).split(ENV.pathSep),
            i = 0;

          /* Count how many segments match. */
          while(sA[i] == sB[i]) { ++i; }

          if (i) {
            /* If at least some segments matched, remove them.  The result is our new path. */
            path = sA.slice(i).join(ENV.pathSep);

            /* Prepend `../` for each segment remaining in `relativeTo`. */
            for (var j = sB.length - i; j > 0; --j) { path = '../' + path; }
          }

          return path;
        },

        // `buildPath` accepts an arbitrary number of string arguments to concatenate into a path.
        //     util.buildPath('a', 'b', 'c/', 'd/') -> 'a/b/c/d/'
        buildPath: function() {
          var pieces = [];
          for (var i = 0, n = arguments.length; i < n; ++i) {
            var piece = arguments[i];
            if (PROTOCOL.test(piece)) {
              pieces.length = 0;
            }

            if (piece != '.' && piece != './' && piece) {
              pieces.push(piece);
            }
          }

          return util.resolveRelativePath(pieces.join('/'));
        },

        // `resolveRelativePath` removes relative path indicators.  For example:
        //     util.resolveRelativePath('a/../b') -> b
        resolveRelativePath: function(path) {
          /* If the path starts with a protocol+host, store it and remove it (add it
             back later) so we don't accidently modify it. */
          var protocol = path.match(HOST);
          if (protocol) { path = protocol[2]; }

          /* Remove multiple slashes and trivial dots (`/./ -> /`). */
          path = path.replace(/\/+/g, '/').replace(/\/\.\//g, '/');

          /* Loop to collapse instances of `../` in the path by matching a previous
             path segment.  Essentially, we find substrings of the form `/abc/../`
             where abc is not `.` or `..` and replace the substrings with `/`.
             We loop until the string no longer changes since after collapsing
             possible instances once, we may have created more instances that can
             be collapsed.
          */
          var o;
          while((o = path) != (path = path.replace(/(^|\/)(?!\.?\.\/)([^\/]+)\/\.\.\//g, '$1'))) {}
          /* Don't forget to prepend any protocol we might have removed earlier. */
          return protocol ? protocol[1] + path.replace(/^\//, '') : path;
        },

        isAbsolutePath: function (path) {
          return /^\//.test(path) || PROTOCOL.test(path);
        },

        resolve: function (from, to) {
          return this.isAbsolutePath(to) ? util.resolveRelativePath(to) : util.buildPath(from, to);
        },

        resolveRelativeModule: function (modulePath, directory) {
          var result = [],
            parts = modulePath.split('.'),
            len = parts.length,
            relative = (len > 1 && !parts[0]),
            i = relative ? 0 : -1;

          while(++i < len) { result.push(parts[i] ? parts[i] : '..'); }
          return util.buildPath(relative ? directory : '', result.join('/'));
        },
        resolveModulePath: function (modulePath, directory) {
          // resolve relative paths
          if (modulePath.charAt(0) == '.') {
            return getModuleDefs(util.resolveRelativeModule(modulePath, directory))
              .concat(getModuleDefs(util.resolveRelativeModule(modulePath + '.index', directory)));
          }

          // resolve absolute paths with respect to jsio packages/
          var pathSegments = modulePath.split('.');
          var n = pathSegments.length;
          for (var i = n; i > 0; --i) {
            var subpath = pathSegments.slice(0, i).join('.');
            var value = jsioPath.cache[subpath];
            var pathString = pathSegments.slice(i).join('/');
            if (value) {
              return getModuleDefs(util.buildPath(value, pathString))
                .concat(getModuleDefs(util.buildPath(value, pathString + '/index')));
            }
          }

          var baseMod = pathSegments[0];
          var pathString = pathSegments.join('/');
          var defs = [];
          var paths = jsioPath.get();
          var len = paths.length;
          for (var i = 0; i < len; ++i) {
            var base = paths[i];
            var path = util.buildPath(base, pathString);

            var moduleDefs = getModuleDefs(path);
            moduleDefs.forEach(function(moduleDef) {
              moduleDef.setBase(baseMod, base);
              defs.push(moduleDef);
            });

            var moduleDefs = getModuleDefs(path + '/index');
            moduleDefs.forEach(function(moduleDef) {
              moduleDef.setBase(baseMod, base);
              defs.push(moduleDef);
            });
          }
          return defs;
        },
        splitPath: function(path, result) {
          if (!result) { result = {}; }
          var i = path.lastIndexOf('/') + 1;
          result.directory = path.substring(0, i);
          result.filename = path.substring(i);
          return result;
        }
      };

    // construct the top-level jsio object
    var jsio = util.bind(this, _require, null, null, null);

    jsio.__util = util;
    jsio.__init__ = init;

    var srcCache;
    jsio.setCache = function(cache) { srcCache = jsio.__srcCache = cache; };
    jsio.setCache(cloneFrom && cloneFrom.__srcCache || {});

    jsio.setCachedSrc = function(path, src, locked) {
      if (srcCache[path] && srcCache[path].locked) {
        console.warn('Cache is ignoring (already present and locked) src ' + path);
        return;
      }
      srcCache[path] = { path: path, src: src, locked: locked };
    };
    jsio.getCachedSrc = function(path) { return srcCache[path]; };

    jsio.__filename = 'jsio.js';
    jsio.__cmds = [];
    jsio.__jsio = jsio;
    jsio.__require = _require;
    jsio.__modules = {preprocessors:{}};
    var jsioPath = {
        set: function(path) {
          this.value = [];
          (typeof path == 'string' ? [path] : path).map(this.add, this);
        },
        get: function() { return jsioPath.value.slice(0); },
        add: function (path) {
          if (arguments.length == 2) {
            var from = arguments[0];
            var to = util.resolve(ENV.getCwd(), arguments[1]);
            this.cache[from] = to;
          } else {
            path = util.resolve(ENV.getCwd(), path);
            var v = jsioPath.value, len = v.length;
            for (var i = 0; i < len; ++i) {
              if (v[i] == path) { return; }
            }
            v.push(path);
          }
        },
        remove: function(path) {
          var v = jsioPath.value, len = v.length;
          for (var i = 0; i < len; ++i) {
            if (v[i] == path) {
              v.splice(i, 1);
            }
          }
        },
        value: [],
        cache: {}
      };

    jsio.path = jsioPath;
    jsio.addPath = util.bind(jsioPath, 'add');
    jsio.addCmd = util.bind(jsio.__cmds, 'push');

    jsio.setEnv = function(envCtor) {
      if (!envCtor && cloneFrom) {
        ENV = new cloneFrom.__env.constructor(util);
      } else {
        if (typeof envCtor == 'string') {
          envCtor = ({
              node: ENV_node,
              browser: ENV_browser
            })[envCtor] || ENV_browser;
        }

        ENV = new envCtor(util);
      }

      this.__env = ENV;
      this.__dir = ENV.getCwd();

      if (!ENV.loadModule) {
        ENV.loadModule = loadModule;
      }

      jsio.path.cache['jsio'] = cloneFrom ? cloneFrom.path.cache.jsio : ENV.getPath();
      if (envCtor == ENV_browser) {
        jsio.path.set(ENV.getPath());
      }
    };

    if (cloneFrom) {
      jsio.setEnv();
    } else if (typeof JSIO_ENV_CTOR !== 'undefined') {
      jsio.setEnv(JSIO_ENV_CTOR);
    } else if (typeof process !== 'undefined' && process.version) {
      jsio.setEnv('node');
    } else if (typeof XMLHttpRequest != 'undefined' || typeof ActiveXObject != 'undefined') {
      jsio.setEnv('browser');
    }

    jsio.main = ENV && ENV.main;

    var boundJsio;
    var localJsio = function (req) {
      if (!boundJsio) {
        boundJsio = util.bind(this, _require, {}, ENV.getPath(), 'jsio.js');
      }

      return boundJsio(req, {dontExport: true, dontPreprocess: true});
    };

    /*
    function ENV_abstract() {
      this.global = null;
      this.getCwd = function() {};
      this.getPath = function() {};
      this.eval = function(code, path) {};
      this.fetch = function(path) { return contentsOfPath; };
      this.log = function(args...) {};
    }
    */

    function ENV_node() {
      var Module = module.constructor;

      var parent = module.parent;
      var req = util.bind(parent, parent && parent.require || require);

      var fs = req('fs');
      var path = req('path');
      var vm = req('vm');

      this.requireCache = require.cache;
      this.main = require.main;
      this.name = 'node';
      this.global = global;

      var _cwd = process.cwd();
      this.setCwd = function (cwd) { _cwd = path.resolve(_cwd, cwd); };
      this.getCwd = function () { return _cwd; };

      this.pathSep = path.sep;

      // var parentPath = util.splitPath(module.parent.filename);
      // module.parent.require = function(request, opts) {
      //   if (!opts) { opts = {}; }
      //   opts.dontExport = true;
      //   return _require({}, parentPath.directory, parentPath.filename, request, opts);
      // };

      this.log = function() {
        var msg;
        try {
          msg = Array.prototype.map.call(arguments, function(a) {
              if ((a instanceof Error) && a.message) {
                return 'Error:' + a.message + '\nStack:' + a.stack + '\nArguments:' + a.arguments;
              }
              return (typeof a == 'string' ? a : JSON.stringify(a));
            }).join(' ') + '\n';
        } catch(e) {
          msg = Array.prototype.join.call(arguments, ' ') + '\n';
        }

        process.stderr.write(msg);
        return msg;
      };

      this.getPath = function() {
        return __dirname;
      };

      this.eval = function (code, path) {
        return vm.runInThisContext(code, path, true);
      };

      this.fetch = function (p) {
        p = util.resolve(this.getCwd(), p);

        var filename, lowercaseFilename, files;
        try {
          var dirname = path.dirname(p);
          filename = path.basename(p);
          lowercaseFilename = filename.toLowerCase();
          files = fs.readdirSync(dirname);
        } catch (e) {
          return false;
        }

        for (var i = 0, testName; testName = files[i]; ++i) {
          if (testName.toLowerCase() == lowercaseFilename && testName != filename) {
            throw "Invalid case when importing [" + p + "].  You probably meant" + testName;
          }
        }

        try {
          return fs.readFileSync(p, 'utf8');
        } catch(e) {
          return false;
        }
      };

      var stackRe = /\((?!module.js)(?:file:\/\/)?(.*?)(:\d+)(:\d+)\)/g;
      this.loadModule = function (baseLoader, fromDir, fromFile, item, opts) {
        if (fromFile == INITIAL_FILE && !opts.initialImport) {
          var stack = new Error().stack;
          var match;
          stackRe.lastIndex = 0;
          do {
            match = stackRe.exec(stack);
          } while (match && /jsio\.js$/.test(match[1]));

          if (match) {
            fromDir = path.dirname(match[1]);
            fromFile = path.basename(match[1]);
          }
        }

        try {
          return baseLoader(null, fromDir, fromFile, item, opts);
        } catch(e) {
          if (e.code == MODULE_NOT_FOUND) {
            var require = req;
            // lookup node module for relative imports
            var module;
            var filename = path.join(fromDir, fromFile);
            module = this.requireCache[filename];
            if (!module) {
              module = new Module(filename);
              module.filename = filename;
              module.paths = Module._nodeModulePaths(path.dirname(filename));
            }
            var request = item.original || item.from;
            try {
              return {
                exports: module ? module.require(request) : require(request),
                path: item.from
              };
            } catch (e2) {
              if (e2.code == MODULE_NOT_FOUND) {
                throw e;
              }

              throw e2;
            }
          } else {
            throw e;
          }
        }
      };
    }

    function ENV_browser() {
      var XHR = window.XMLHttpRequest || function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
        cwd = null,
        path = null,
        JOIN = Array.prototype.join;

      this.name = 'browser';
      this.global = window;
      this.pathSep = "/";

      if (!this.global.jsio) { this.global.jsio = jsio; }

      if (window.console && console.log) {
        if (!console.log.apply || /Android|iPhone|iPad|iPod/.test(navigator.userAgent)) {
          this.log = function () {
            var args = JOIN.call(arguments, ' ');
            console.log(args);
            return args;
          };
        } else {
          this.log = function () {
            console.log.apply(console, arguments);
            return JOIN.call(arguments, ' ');
          };
        }
      } else {
        this.log = function () { return JOIN.call(arguments, ' '); };
      }

      this.getCwd = function() {
        if(!cwd) {
          var loc = window.location, path = loc.pathname;
          cwd = loc.protocol + '//' + loc.host + path.substring(0, path.lastIndexOf('/') + 1);
        }
        return cwd;
      };

      this.getPath = function() {
        if(!path) {
          try {
            var filename = new RegExp('(.*?)' + jsio.__filename + '(\\?.*)?$'),
              scripts = document.getElementsByTagName('script');

            for (var i = 0, script; script = scripts[i]; ++i) {
              var result = script.src.match(filename);
              if (result) {
                path = result[1];
                if (/^[A-Za-z]*:\/\//.test(path)) { path = util.relative(this.getCwd(), path); }
                break;
              }
            }
          } catch(e) {}

          if(!path) { path = '.'; }
        }
        return path;
      };

      var debugHost = location.protocol + '//' + location.host + '/';
      var debugPath = location.pathname;
      this.debugPath = function (path) {
        return util.buildPath(debugHost, path[0] != '/' && debugPath, path);
      };

      // IE6 won't return an anonymous function from eval, so use the function constructor instead
      var rawEval = typeof eval('(function(){})') == 'undefined'
        ? function(src, path) { return (new Function('return ' + src))(); }
        : function(src, path) { var src = src + '\n//@ sourceURL=' + path; return window.eval(src); };

      // provide an eval with reasonable debugging
      this.eval = function(code, path, origCode) {
        try {
          return rawEval(code, this.debugPath(path));
        } catch(e) {
          if(e instanceof SyntaxError) {
            if (DEBUG && this.checkSyntax) {
              this.checkSyntax(origCode, path);
            }
          }
          throw e;
        }
      };

      this.checkSyntax = function(code, path) {
        try {
          var syntax = jsio('import jsio.util.syntax', {suppressErrors: true, dontExport: true});
          syntax(code, path);
        } catch(e) {}
      };

      this.fetch = function(path) {
        var xhr = new XHR();
        try {
          xhr.open('GET', path, false);
          xhr.send(null);
        } catch(e) {
          ENV.log('e:', e);
          return false; // firefox file://
        }

        if (xhr.status == 404 || // all browsers, http://
          xhr.status == -1100 || // safari file://
          // XXX: We have no way to tell in opera if a file exists and is empty, or is 404
          // XXX: Use flash?
          //(!failed && xhr.status == 0 && !xhr.responseText && EXISTS)) // opera
          false)
        {
          return false;
        }

        return xhr.responseText;
      };
    };

    var failedFetch = {};

    function findModule(possibilities) {
      var src;
      for (var i = 0, possible; possible = possibilities[i]; ++i) {
        var path = possible.path,
          cachedVersion = srcCache[path];

        if (cachedVersion) {
          // extract a non-absolute dirname from the cache key: absolute paths
          // built into the cache are made relative during compile time since
          // absolute paths won't match between host and target device. Use
          // the cache key as the relative path so future imports can also
          // successfully lookup paths in the cache.
          var match = path.match(/^(.*\/)[^\\\/]+$/);
          possible.directory = match && match[1] || "";
          possible.src = cachedVersion.src;
          possible.pre = true;
          return possible;
        }

        /*if (/^\.\//.test(path)) {
          // remove one path segment for each dot from the cwd
          path = addEndSlash(ENV.getCwd()) + path;
        }*/

        src = ENV.fetch(path);

        if (src !== false) {
          possible.src = src;
          return possible;
        } else {
          failedFetch[path] = true;
        }
      }

      return false;
    }

    function processStack() {
      return importStack.map(function (item, index) {
        var stack = index == 0 ? new Error().stack : importStack[index - 1].stack;
        var i = stack.indexOf(item.path);
        if (i >= 0) {
          item.line = ':' + parseInt(stack.substring(i + item.path.length + 1));
        }

        return (index + 1) + ': "' + item.friendlyPath + '" ' + item.path + (item.line || '');
      });
    }

    // load a module from a file
    function loadModule (baseLoader, fromDir, fromFile, item, opts) {
      var modulePath = item.from;
      var possibilities = util.resolveModulePath(modulePath, fromDir);
      for (var i = 0, p; p = possibilities[i]; ++i) {
        var path = possibilities[i].path;
        if (!opts.reload && (path in jsio.__modules)) {
          return possibilities[i];
        }

        if (path in failedFetch) { possibilities.splice(i--, 1); }
      }

      if (!possibilities.length) {
        if (opts.suppressErrors) { return false; }
        var e = new Error('Could not import `' + item.from + '`'
            + "\tImport Stack:\n"
            + "\t\t" + processStack().join("\n\t\t"));
        e.jsioLogged = true;
        e.code = MODULE_NOT_FOUND;
        throw e;
      }

      var moduleDef = findModule(possibilities);
      if (!moduleDef) {
        if (opts.suppressErrors) { return false; }
        var paths = [];
        for (var i = 0, p; p = possibilities[i]; ++i) { paths.push(p.path); }
        var e = new Error("Could not import `" + modulePath + "`\n"
          + "\tlooked in:\n"
            + "\t\t" + paths.join('\n\t\t') + "\n"
            + "\tImport Stack:\n"
            + "\t\t" + processStack().join("\n\t\t"));
        e.code = MODULE_NOT_FOUND;
        throw e;
      }

      // a (potentially) nicer way to refer to a module -- how it was referenced in code when it was first imported
      moduleDef.friendlyPath = modulePath;

      // cache the base module's path in the path cache so we don't have to
      // try out all paths the next time we see the same base module.
      if (moduleDef.baseMod && !(moduleDef.baseMod in jsioPath.cache)) {
        jsioPath.cache[moduleDef.baseMod] = moduleDef.basePath;
      }

      // don't apply the standard preprocessors to base.js.  If we're reloading
      // the source code, always apply them.  We also don't want to run them
      // if they've been run once -- moduleDef.pre is set to true already
      // if we're reading the code from the source cache.
      if (modulePath != 'base' && (opts.reload || !opts.dontPreprocess && !moduleDef.pre)) {
        moduleDef.pre = true;

        applyPreprocessors(fromDir, moduleDef, ["import", "typescript", "inlineSlice"], opts);
      }

      // any additional preprocessors?
      if (opts.preprocessors) {
        applyPreprocessors(fromDir, moduleDef, opts.preprocessors, opts);
      }

      return moduleDef;
    }

    function applyPreprocessors(path, moduleDef, names, opts) {
      for (var i = 0, len = names.length; i < len; ++i) {
        var p = getPreprocessor(names[i]);

        // if we have a recursive import and p isn't a function, just
        // skip it (handles the case where a preprocessor imports
        // other modules).
        if (p && typeof p == 'function') {
          p(path, moduleDef, opts);
        }
      }
    }

    function getPreprocessor(name) {
      var module = jsio.__modules['jsio.preprocessors.' + name];
      return typeof name == 'function'
        ? name
        : (module && module.exports
          || localJsio('import jsio.preprocessors.' + name));
    }

    function execModuleDef(context, moduleDef) {
      var src = moduleDef.src;
      delete moduleDef.src;

      var code = "(function(_){with(_){delete _;return function $$" + moduleDef.friendlyPath.replace(/[\:\\\/.-]/g, '_') + "(){" + src + "\n}}})";

      var exports = moduleDef.exports = context.exports;

      var fn = ENV.eval(code, moduleDef.path, src);
      fn = fn(context);

      fn.call(exports);

      if (exports != context.module.exports) {
        // Emulate node.js-style ability to reassign module.exports:
        //   module.exports = ...
        //
        // Note that in node.js and js.io, setting `module.exports` invalidates
        // the context's `exports` alias. See
        // http://nodejs.org/api/modules.html#modules_exports_alias for more
        moduleDef.exports = context.module.exports;
      } else {
        // js.io-style ability to override exports directly (`exports = `)
        moduleDef.exports = context.exports;
      }
    }

    function resolveImportRequest(context, request, opts) {
      var cmds = jsio.__cmds,
        imports = [],
        result = false;

      for (var i = 0, imp; imp = cmds[i]; ++i) {
        if ((result = imp(context, request, opts, imports))) { break; }
      }

      if (result !== true) {
        throw new (typeof SyntaxError != 'undefined' ? SyntaxError : Error)(String(result || 'invalid jsio command: jsio(\'' + request + '\')'));
      }

      return imports;
    }

    function makeContext(ctx, modulePath, moduleDef, dontAddBase) {
      if (!ctx) { ctx = {}; }
      if (!ctx.exports) { ctx.exports = {}; }

      ctx.jsio = util.bind(this, _require, ctx, moduleDef.directory, moduleDef.filename);
      ctx.require = function(request, opts) {
        if (!opts) { opts = {}; }
        opts.dontExport = true;
        return ctx.jsio(request, opts);
      };

      ctx.require.main = ENV.main;

      ctx.module = {id: modulePath, exports: ctx.exports};
      if (!dontAddBase && modulePath != 'jsio.base') {
        ctx.jsio('from jsio.base import *', {dontPreprocess: true});
        ctx.logging.__create(modulePath, ctx);
      }

      // TODO: FIX for "trailing ." case
      ctx.jsio.__jsio = jsio;
      ctx.jsio.__env = jsio.__env;
      ctx.jsio.__dir = moduleDef.directory;
      ctx.jsio.__filename = moduleDef.filename;
      ctx.jsio.path = jsioPath;

      ctx.__dirname = moduleDef.directory;
      ctx.__filename = util.buildPath(ctx.__dirname, moduleDef.filename);
      return ctx;
    }

    var importStack = [];
    function _require(boundContext, fromDir, fromFile, request, opts) {
      opts = opts || {};
      fromDir = fromDir || './';
      fromFile = fromFile || INITIAL_FILE;

      // require is bound to a module's (or global) context -- we can override this
      // by using opts.exportInto
      var exportInto = opts.exportInto || boundContext || ENV.global;

      // parse the import request(s)
      var imports = resolveImportRequest(exportInto, request, opts),
        numImports = imports.length,
        retVal = numImports > 1 ? {} : null;

      // import each requested item
      for (var i = 0; i < numImports; ++i) {
        var item = imports[i];
        var modulePath = item.from;
        var modules = jsio.__modules;
        var path;
        var moduleDef;
        var err;

        try {
          moduleDef = jsio.__env.loadModule(loadModule, fromDir, fromFile, item, opts);
        } catch(e) {
          err = e;
        }

        if (moduleDef) {
          path = moduleDef.path;
        } else if (moduleDef === false) {
          return false;
        }

        if (err) {
          if (opts.suppressErrors) { return false; }
          if (!err.jsioLogged) {
            ENV.log(
              '\nError loading module:\n',
              '    [[', request, ']]\n',
              '    requested by:', fromDir + fromFile, '\n',
              '    current directory:', jsio.__env.getCwd(), '\n',
              '  ' + err.stack.split('\n').join('\n  '));
            err.jsioLogged = true;
          }

          throw err;
        }

        if (moduleDef) {
          importStack.push({
            friendlyPath: moduleDef.friendlyPath,
            path: moduleDef.path,
            stack: new Error().stack
          });
        }

        // eval any packages that we don't know about already
        if (!(path in modules)) {
          modules[path] = moduleDef;
        }

        if (!moduleDef.exports) {
          var newContext = makeContext(opts.context, modulePath, moduleDef, item.dontAddBase);
          if (item.dontUseExports) {
            var src = [';(function(){'], k = 1;
            for (var j in item['import']) {
              newContext.exports[j] = undefined;
              src[k++] = 'if(typeof '+j+'!="undefined"&&exports.'+j+'==undefined)exports.'+j+'='+j+';';
            }
            src[k] = '})();';
            moduleDef.src += src.join('');
          }

          execModuleDef(newContext, moduleDef);
        }

        importStack.pop();

        var module = moduleDef.exports;

        // return the module if we're only importing one module
        if (numImports == 1) { retVal = module; }

        if (!opts.dontExport) {
          // add the module to the current context
          if (item.as) {
            // remove trailing/leading dots
            var as = item.as.match(/^\.*(.*?)\.*$/)[1],
              segments = as.split('.'),
              kMax = segments.length - 1,
              c = exportInto;

            // build the object in the context
            for(var k = 0; k < kMax; ++k) {
              var segment = segments[k];
              if (!segment) continue;
              if (!c[segment]) { c[segment] = {}; }
              c = c[segment];
            }

            c[segments[kMax]] = module;

            // there can be multiple module imports with this syntax (import foo, bar)
            if (numImports > 1) {
              retVal[as] = module;
            }
          } else if (item['import']) {
            // there can only be one module import with this syntax
            // (from foo import bar), so retVal will already be set here
            if (item['import']['*']) {
              for (var k in modules[path].exports) { exportInto[k] = module[k]; }
            } else {
              for (var k in item['import']) { exportInto[item['import'][k]] = module[k]; }
            }
          }
        }
      }

      return retVal;
    }

    // DEFINE SYNTAX FOR JSIO('cmd')

    // from myPackage import myFunc
    // external myPackage import myFunc
    jsio.addCmd(function(context, request, opts, imports) {
      var match = request.match(/^\s*(from|external)\s+([\w.\-$]+)\s+(import|grab)\s+(.*)$/);
      if(match) {
        imports.push({
          from: match[2],
          dontAddBase: match[1] == 'external',
          dontUseExports: match[3] == 'grab' || match[1] == 'external',
          'import': {}
        });

        match[4].replace(/\s*([\w.\-$*]+)(?:\s+as\s+([\w.\-$]+))?/g, function(_, item, as) {
          imports[0]['import'][item] = as || item;
        });
        return true;
      }
    });

    // import myPackage
    jsio.addCmd(function(context, request, opts, imports) {
      var match = request.match(/^\s*import\s+(.*)$/);
      if (match) {
        match[1].replace(/\s*([\w.\-$]+)(?:\s+as\s+([\w.\-$]+))?,?/g, function(_, fullPath, as) {
          imports.push(
            as ? {
              from: fullPath,
              as: as
            } : {
              from: fullPath,
              as: fullPath
            });
        });
        return true;
      }
    });

    // CommonJS syntax
    jsio.addCmd(function(context, request, opts, imports) {

      //    ./../b -> ..b
      //    ../../b -> ...b
      //    ../b -> ..b
      //    ./b -> .b

      var match = request.match(/^\s*[\w.0-9$\/\-:\\]+\s*$/);
      if (match) {

        var req = util.resolveRelativePath(match[0]),
          isRelative = req.charAt(0) == '.';

        req = req
          // .replace(/^\//, '') // remove any leading slash
          .replace(/\.\.\//g, '.') // replace relative path indicators with dots
          .replace(/\.\//g, '')
          .replace(/\/+$/g, '');

        if (ENV.pathSep === '\\' && req.match(/^[a-zA-Z]:.*/)) {
          // leave absolute windows paths (start with drive letter) alone
        } else {
          // any remaining slashes are path separators
         req = req.replace(/\//g, '.');
        }

        imports[0] = { from: (isRelative ? '.' : '') + req, original: request };
        return true;
      }
    });

    jsio.install = function() {
      jsio('from .base import *');
      GLOBAL['logger'] = logging.get('jsiocore');
    };

    jsio.eval = function (src, path) {
      path = ENV.getCwd() || '/';
      var moduleDef = new ModuleDef(path);
      moduleDef.src = src;
      applyPreprocessors(path, moduleDef, ["import", "typescript", "cls"], {});
      execModuleDef(ENV.global, moduleDef);
    };

    jsio.clone = util.bind(null, init, jsio);

    // in node, defines jsio as a module that can be imported
    var moduleInfo = util.resolveModulePath('jsio')[0];
    if (moduleInfo) {
      jsio.__modules[moduleInfo.path] = new ModuleDef(moduleInfo.path);
      jsio.__modules[moduleInfo.path].exports = jsio;
    }

    return jsio;
  })();jsio.path.set([]);jsio.path.cache={"jsio":"./","jsio_compile":"../compilers/jsio_compile"};jsio.setCache({"../compilers/jsio_compile/node_interface.js":{"path":"../compilers/jsio_compile/node_interface.js","friendlyPath":"jsio_compile.node_interface","directory":"../compilers/jsio_compile","filename":"node_interface.js","pre":true,"src":"jsio('import jsio.util.optparse as optparse');\njsio('import .optsDef');\n\nvar fs = require('fs');\nvar path = require('path');\ntry {\n\tvar crypto = require('crypto');\n} catch(e) {}\n\nvar closurePath = '';\n(function() {\n\tvar path = require('path');\n\tvar defaultPath = path.join(path.dirname(jsio.__filename), 'compiler', 'compiler.jar');\n\tif (fs.existsSync(defaultPath)) {\n\t\tclosurePath = defaultPath;\n\t}\n})();\n\nexports.logger = logger;\n\nfunction findMinifier(jarPath) {\n\tvar path = require('path');\n\tif (fs.existsSync(jarPath)) {\n\t\tclosurePath = jarPath;\n\t}\n}\n\nfunction usage() {\n\toptparse.printUsage('jsio_compile <initial import>\\n\\t where <initial import> looks like \"import .myModule\"', optsDef);\n}\n\nvar _compiler;\nexports.setCompiler = function (compiler) {\n\t_compiler = compiler;\n}\n\nexports.run = function(args, opts) {\n\tif (!args) {\n\t\tvar result = optparse(process.argv, optsDef),\n\t\t\targs = result.args,\n\t\t\topts = result.opts;\n\t}\n\n\tif (opts.help) {\n\t\tusage();\n\t\tprocess.exit();\n\t}\n\n\tfindMinifier(opts.closurePath);\n\n\t_compiler.run(args, opts);\n};\n\nexports.onError = function(e) {\n\t//usage();\n\tjsio.__env.log('\\n' + e.message);\n\tjsio.__env.log('\\n' + e.stack);\n\tprocess.exit(1);\n}\n\nexports.onFinish = function(opts, src) {\n\tif (opts.outputFile) {\n\t\tlogger.info('Writing output to', opts.outputFile);\n\t\tvar fs = require('fs');\n\t\tfs.writeFileSync(opts.outputFile, src);\n\t} else {\n\t\tlogger.info('Writing output to stdout');\n\t\tprocess.stdout.write(src);\n\t}\n}\n\nexports.compress = function(filename, src, opts, callback) {\n\tvar cachePath;\n\n\tfunction fail(err) {\n\t\tif (err) {\n\t\t\tlogger.error(err);\n\t\t}\n\t\tcallback(src);\n\t}\n\n\tif (!closurePath) { return fail(); }\n\n\tif (opts.compressorCachePath && filename) {\n\t\ttry {\n\t\t\tvar cacheFilename = (/^\\.\\//.test(filename) ? 'R-' + filename.substring(2) : 'A-' + filename)\n\t\t\t\t.replace(/\\.\\.\\//g, '--U--')\n\t\t\t\t.replace(/\\//g, '---');\n\n\t\t\tcachePath = path.join(opts.compressorCachePath, cacheFilename);\n\n\t\t\tif (crypto) {\n\t\t\t\tvar hash = crypto.createHash('md5');\n\t\t\t\thash.update(src);\n\t\t\t\tvar checksum = hash.digest('hex');\n\t\t\t} else {\n\t\t\t\tvar stat = fs.statSync(filename);\n\t\t\t\tvar checksum = '' + stat.mtime;\n\t\t\t}\n\n\t\t\tif (fs.existsSync(cachePath)) {\n\t\t\t\tvar cachedContents = fs.readFileSync(cachePath, 'utf8');\n\t\t\t\tvar i = cachedContents.indexOf('\\n');\n\t\t\t\tvar cachedChecksum = cachedContents.substring(0, i);\n\t\t\t\tlogger.debug(cachePath, 'current:', checksum, 'cached:', cachedChecksum);\n\t\t\t\tif (checksum == cachedChecksum) {\n\t\t\t\t\tcallback(cachedContents.substring(i + 1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}\n\n\t// http://code.google.com/p/closure-compiler/wiki/Warnings\n\n\tvar spawn = require('child_process').spawn;\n\tvar cmd = ['-jar', closurePath || 'jsio_minify.jar', '--compilation_level', 'SIMPLE_OPTIMIZATIONS'];\n\tif (opts.noIE) {\n\t\tcmd.push('--jscomp_off=internetExplorerChecks')\n\t}\n\n\tvar closure = spawn('java', cmd);\n\tvar stdout = [];\n\tvar stderr = [];\n\n\tclosure.stdout.on('data', function(data) { stdout.push(data); });\n\tclosure.stderr.on('data', function(data) { stderr.push(data); });\n\tclosure.on('exit', function(code) {\n\t\tif (code == 0) {\n\t\t\tvar compressedSrc = stdout.join('');\n\t\t\ttry {\n\t\t\t\tif (cachePath) {\n\t\t\t\t\tlogger.debug('updating cache for', cachePath, checksum);\n\t\t\t\t\tfs.writeFileSync(cachePath, checksum + '\\n' + compressedSrc);\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\tlogger.error(e);\n\t\t\t}\n\n\t\t\tcallback(compressedSrc);\n\t\t} else {\n\t\t\tfail(stderr.join(''));\n\t\t}\n\t});\n\n\tclosure.stdin.write(src);\n\tclosure.stdin.end();\n}\n\n"},"util/optparse.js":{"path":"util/optparse.js","friendlyPath":"jsio.util.optparse","directory":"util/","filename":"optparse.js","pre":true,"src":"jsio('import .jsonSchema');\njsio('import ..lib.Enum');\n\n/* optparser */\n\n/*\n\noptsDef = {\n\t'-v': {\n\t\tname: 'version',\n\t\tdescription: 'prints the version information',\n\t\targs: {\n\t\t\t0: '\n\t\t}\n\t}\n}\n\n*/\n\nfunction ERROR(msg) {\n\tlogger.error(msg);\n\tprocess.exit(1);\n}\n\nfunction addAlso(optsDef, also, value) {\n\tif (typeof also == 'string') {\n\t\toptsDef[also] = value;\n\t} else if (isArray(also)) {\n\t\talso.forEach(function (key) {\n\t\t\toptsDef[key] = value;\n\t\t});\n\t} else {\n\t\tlogger.warn('Key specified in option', optsDef.name, 'is invalid.  Ignoring:', also);\n\t}\n}\n\nvar truthyValues = lib.Enum('true', '1', 'yes'),\n\tfalsyValues = lib.Enum('false', '0', 'no');\n\nfunction addArg(result, optsDef, argv, i) {\n\tvar val,\n\t\tsrcName = argv[i],\n\t\titemSchema = optsDef[argv[i]],\n\t\tlen = argv.length,\n\t\titemType = itemSchema && itemSchema.type && itemSchema.type.toLowerCase();\n\n\t++i;\n\tswitch(itemType) {\n\t\tcase 'boolean':\n\t\t\tif (typeof argv[i] == 'undefined') {\n\t\t\t\tval = true;\n\t\t\t\t--i;\n\t\t\t} else if (argv[i].toLowerCase() in truthyValues) {\n\t\t\t\tval = true;\n\t\t\t} else if (argv[i].toLowerCase() in falsyValues) {\n\t\t\t\tval = false;\n\t\t\t} else {\n\t\t\t\tval = true;\n\t\t\t\t--i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'int':\n\t\tcase 'integer':\n\t\t\tval = parseInt(argv[i]);\n\t\t\tbreak;\n\t\tcase 'float':\n\t\tcase 'double':\n\t\tcase 'number':\n\t\t\tval = parseFloat(argv[i]);\n\t\t\tbreak;\n\t\tcase 'array':\n\t\tcase 'object':\n\t\t\tvar buf = argv[i];\n\t\t\twhile(true) {\n\t\t\t\ttry {\n\t\t\t\t\tvar val = eval('(' + buf + ')');\n\t\t\t\t\tbreak;\n\t\t\t\t} catch(e) {}\n\t\t\t\t++i;\n\t\t\t\tif (i >= len) { ERROR('Could not parse \"' + srcName + '\": ' + itemSchema.type + '\\n' + buf + '\\n' + JSON.stringify(argv)); }\n\t\t\t\tbuf += argv[i];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'any':\n\t\tcase 'string':\n\t\tdefault:\n\t\t\tval = argv[i];\n\t\t\tbreak;\n\t}\n\n\tvar status = jsonSchema.validate(val, itemSchema);\n\tif (status.valid) {\n\t\tresult[itemSchema.name] = val;\n\t\treturn i + 1;\n\t} else {\n\t\tvar log = [];\n\t\tfor(var k = 0, e; e = status.errors[k]; ++k) {\n\t\t\tlog.push('\\n\\t\\t' + (e.property ? e.property + ': ' : '') + e.message)\n\t\t}\n\n\t\tERROR('\\n' + srcName + ': provided value ' + argv[i] + '\\n\\t' + itemSchema.name + ' option:' + log.join(''));\n\t}\n}\n\nexports = function(argv, origDef) {\n\tvar optsDef = merge({}, origDef),\n\t\tresult = {};\n\tfor (var i in optsDef) {\n\t\tvar opt = optsDef[i];\n\t\tif ('default' in opt) { result[opt.name] = opt['default']; }\n\n\t\tvar also = opt.also;\n\t\tif (also) {\n\t\t\tif (isArray(also)) {\n\t\t\t\tfor (var j = 0, len = also.length; j < len; ++j) {\n\t\t\t\t\taddAlso(optsDef, also[j], opt);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddAlso(optsDef, also, opt);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar unprocessed = [],\n\t\ti = 0,\n\t\tlen = argv.length;\n\n\twhile (i < len) {\n\t\tif (argv[i] in optsDef) {\n\t\t\ti = addArg(result, optsDef, argv, i);\n\t\t} else {\n\t\t\tunprocessed.push(argv[i]);\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn {\n\t\targs: unprocessed,\n\t\topts: result\n\t};\n}\n\nexports.printUsage = function(usage, optsDef) {\n\tjsio('import ..util.wordWrap');\n\n\tvar print = jsio.__env.log;\n\tprint('Usage:');\n\tprint('\\t' + usage);\n\tprint('Options:');\n\tfor (var i in optsDef) {\n\t\tvar opt = [i];\n\t\tif (optsDef[i].also) {\n\t\t\tif (isArray(optsDef[i].also)) {\n\t\t\t\topt = opt.concat(optsDef[i].also);\n\t\t\t} else {\n\t\t\t\topt.push(optsDef[i].also);\n\t\t\t}\n\t\t}\n\t\tprint('\\t'+opt.join(', '));\n\t\tif (optsDef[i].description) {\n\t\t\tprint(util.wordWrap(optsDef[i].description, 80, '\\t\\t'));\n\t\t}\n\t}\n}\n"},"util/jsonSchema.js":{"path":"util/jsonSchema.js","friendlyPath":".jsonSchema","directory":"util/","filename":"jsonSchema.js","pre":true,"src":"/**\r\n* JSONSchema Validator\r\n* ====================\r\n*\r\n* Validates JavaScript objects using JSON Schemas\r\n* http://json-schema.org/\r\n*\r\n* Based on jsonschema-b4.js:\r\n*   Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)\r\n*   Licensed under the MIT (MIT-LICENSE.txt) license.\r\n*\r\n* To use the validator call JSONSchema.validate with an instance object\r\n* and an optional schema object. If a schema is provided, it will be used\r\n* to validate. If the instance object refers to a schema\r\n* (self-validating), that schema will be used to validate and the schema\r\n* parameter is not necessary (if both exist, both validations will\r\n* occur). The validate method will return an array of validation errors.\r\n* If there are no errors, then an empty list will be returned. A\r\n* validation error will have two properties:\r\n*\t1. \"property\" - the property that had the error\r\n*\t2. \"message\" - the error message\r\n*/\r\n\r\n// JSONSchema:\r\nexports = {\r\n\t// function (instance, schema):\r\n\t// \t\tTo use the validator call JSONSchema.validate with an instance object and an optional schema object.\r\n\t// \t\tIf a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),\r\n\t// \t\tthat schema will be used to validate and the schema parameter is not necessary (if both exist,\r\n\t// \t\tboth validations will occur).\r\n\t// \t\tThe validate method will return an object with two properties:\r\n\t// \t\t\tvalid: A boolean indicating if the instance is valid by the schema\r\n\t// \t\t\terrors: An array of validation errors. If there are no errors, then an\r\n\t// \t\t\t\t\tempty list will be returned. A validation error will have two properties:\r\n\t// \t\t\t\t\t\tproperty: which indicates which property had the error\r\n\t// \t\t\t\t\t\tmessage: which indicates what the error was\r\n\t//\r\n\tvalidate: validate,\r\n\r\n\t// Summary:\r\n\t// \t\tThe checkPropertyChange method will check to see if a value can legally be in a property with the given schema\r\n\t// \t\tThis is slightly different than the validate method in that it will fail if the schema is readonly and it will\r\n\t// \t\tnot check for self-validation, it is assumed that the passed in value is already internally valid.\r\n\t// \t\tThe checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for\r\n\t// \t\tinformation.\r\n\t//\r\n\tcheckPropertyChange: function(/*Any*/value,/*Object*/schema, /*String*/ property) {\r\n\t\treturn validate(value, schema, property || \"property\");\r\n\t}\r\n}\r\n\r\nvar gCheckPropChange = false;\r\nfunction validate(instance, schema, property) {\r\n\tgCheckPropChange = property;\r\n\r\n\tvar errors = schema ? checkProp(instance, schema, '', property || '') : [];\r\n\tif (!property && instance && instance.$schema) {\r\n\t\tcheckProp(instance, instance.$schema, '', '', errors);\r\n\t}\r\n\r\n\treturn {\r\n\t\tvalid: !errors.length,\r\n\t\terrors: errors\r\n\t};\r\n}\r\n\r\n// validate a value against a property definition\r\nfunction checkProp(value, schema, path, i, errors) {\r\n\tif (!errors) { errors = []; }\r\n\r\n\tpath +=\r\n\t\tpath ? typeof i == 'number' ? '[' + i + ']'\r\n\t\t\t : typeof i == 'undefined' ? '' : '.' + i : i;\r\n\r\n\tfunction addError(message) {\r\n\t\terrors.push({\r\n\t\t\tproperty: path,\r\n\t\t\tmessage:message\r\n\t\t});\r\n\t}\r\n\r\n\tvar schemaType = typeof schema,\r\n\t\tisObject = schemaType == 'object',\r\n\t\tisFunction = schemaType == 'function';\r\n\r\n\tif ((!isObject || Array.isArray(schema)) && (path || !isFunction)) {\r\n\t\tif (isFunction) {\r\n\t\t\tif (!(value instanceof schema)) {\r\n\t\t\t\taddError(\"is not an instance of the class/constructor \" + schema.name);\r\n\t\t\t}\r\n\t\t} else if (schema) {\r\n\t\t\taddError(\"Invalid schema/property definition \" + schema);\r\n\t\t}\r\n\r\n\t\treturn errors;\r\n\t}\r\n\r\n\tif (gCheckPropChange && schema.readonly) { addError(\"is a readonly field, it can not be changed\"); }\r\n\r\n\t// if it extends another schema, it must pass that schema as well\r\n\tif (schema['extends']) { checkProp(value, schema['extends'], path, i, errors); }\r\n\r\n\tif (value === undefined) {\r\n\t\tif (!schema.optional) { addError(\"is missing and it is not optional\"); }\r\n\t} else {\r\n\t\terrors = errors.concat(checkType(schema.type,value));\r\n\t\tif (schema.disallow && !checkType(schema.disallow,value).length) { addError(\" disallowed value was matched\"); }\r\n\r\n\t\tif (value !== null) {\r\n\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\tif (schema.items) {\r\n\t\t\t\t\tif (Array.isArray(schema.items)) {\r\n\t\t\t\t\t\tfor (i=0,l=value.length; i<l; i++) {\r\n\t\t\t\t\t\t\terrors.concat(checkProp(value[i],schema.items[i],path,i, errors));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (i=0,l=value.length; i<l; i++) {\r\n\t\t\t\t\t\t\terrors.concat(checkProp(value[i],schema.items,path,i, errors));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (schema.minItems && value.length < schema.minItems) {\r\n\t\t\t\t\taddError(\"There must be a minimum of \" + schema.minItems + \" in the array\");\r\n\t\t\t\t}\r\n\t\t\t\tif (schema.maxItems && value.length > schema.maxItems) {\r\n\t\t\t\t\taddError(\"There must be a maximum of \" + schema.maxItems + \" in the array\");\r\n\t\t\t\t}\r\n\t\t\t} else if (schema.properties) {\r\n\t\t\t\terrors.concat(checkObj(value, schema.properties, path, schema.additionalProperties, errors));\r\n\t\t\t}\r\n\t\t\tif (schema.pattern && typeof value == 'string' && !value.match(schema.pattern)) {\r\n\t\t\t\taddError(\"does not match the regex pattern \" + schema.pattern);\r\n\t\t\t}\r\n\t\t\tif (schema.maxLength && typeof value == 'string' && value.length > schema.maxLength) {\r\n\t\t\t\taddError(\"may only be \" + schema.maxLength + \" characters long\");\r\n\t\t\t}\r\n\t\t\tif (schema.minLength && typeof value == 'string' && value.length < schema.minLength) {\r\n\t\t\t\taddError(\"must be at least \" + schema.minLength + \" characters long\");\r\n\t\t\t}\r\n\t\t\tif (typeof schema.minimum !== undefined\r\n\t\t\t\t\t&& typeof value == typeof schema.minimum\r\n\t\t\t\t\t&& schema.minimum > value)\r\n\t\t\t{\r\n\t\t\t\taddError(\"must have a minimum value of \" + schema.minimum);\r\n\t\t\t}\r\n\t\t\tif (typeof schema.maximum !== undefined\r\n\t\t\t\t\t&& typeof value == typeof schema.maximum\r\n\t\t\t\t\t&& schema.maximum < value)\r\n\t\t\t{\r\n\t\t\t\taddError(\"must have a maximum value of \" + schema.maximum);\r\n\t\t\t}\r\n\r\n\t\t\tif (schema['enum']) {\r\n\r\n\t\t\t\tvar enumer = schema['enum'],\r\n\t\t\t\t\tfound;\r\n\r\n\t\t\t\tvar l = enumer.length;\r\n\t\t\t\tfor(var j = 0; j < l; j++) {\r\n\t\t\t\t\tif (enumer[j]===value) {\r\n\t\t\t\t\t\tfound=1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!found) { addError(\"does not have a value in the enumeration \" + enumer.join(\", \")); }\r\n\t\t\t}\r\n\t\t\tif (typeof schema.maxDecimal == 'number' &&\r\n\t\t\t(value.toString().match(new RegExp(\"\\\\.[0-9]{\" + (schema.maxDecimal + 1) + \",}\")))) {\r\n\t\t\t\taddError(\"may only have \" + schema.maxDecimal + \" digits of decimal places\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn errors;\r\n}\r\n\r\n// validate an object against a schema\r\nfunction checkObj(instance, objTypeDef, path, additionalProp, errors) {\r\n\r\n\tif (typeof objTypeDef =='object') {\r\n\t\tif (typeof instance != 'object' || Array.isArray(instance)) {\r\n\t\t\terrors.push({\r\n\t\t\t\tproperty: path,\r\n\t\t\t\tmessage: \"an object is required\"\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfor(var i in objTypeDef) {\r\n\t\t\tif (objTypeDef.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_')) {\r\n\t\t\t\tvar value = instance[i];\r\n\t\t\t\tvar propDef = objTypeDef[i];\r\n\t\t\t\tcheckProp(value,propDef,path,i, errors);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor(i in instance) {\r\n\t\tif (instance.hasOwnProperty(i)\r\n\t\t\t\t&& !(i.charAt(0) == '_'\r\n\t\t\t\t&& i.charAt(1) == '_')\r\n\t\t\t\t&& objTypeDef\r\n\t\t\t\t&& !objTypeDef[i]\r\n\t\t\t\t&& additionalProp === false)\r\n\t\t{\r\n\t\t\terrors.push({\r\n\t\t\t\tproperty: path,\r\n\t\t\t\tmessage: (typeof value) + \"The property \" + i +\r\n\t\t\t\t\t\" is not defined in the schema and the schema does not allow additional properties\"\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tvar requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;\r\n\t\tif (requires && !(requires in instance)) {\r\n\t\t\terrors.push({\r\n\t\t\t\tproperty: path,\r\n\t\t\t\tmessage: \"the presence of the property \" + i + \" requires that \"\r\n\t\t\t\t\t+ requires + \" also be present\"\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tvalue = instance[i];\r\n\t\tif (objTypeDef && typeof objTypeDef == 'object' && !(i in objTypeDef)) {\r\n\t\t\tcheckProp(value, additionalProp, path, i, errors);\r\n\t\t}\r\n\r\n\t\tif (!gCheckPropChange && value && value.$schema) {\r\n\t\t\terrors = errors.concat(checkProp(value, value.$schema, path, i, errors));\r\n\t\t}\r\n\t}\r\n\r\n\treturn errors;\r\n}\r\n\r\n// validate a value against a type definition\r\nfunction checkType(type, value, errors) {\r\n\tif (type) {\r\n\t\tvar actualType = typeof value;\r\n\r\n\t\tif (typeof type == 'string') {\r\n\t\t\ttype = type.toLowerCase();\r\n\t\t\tswitch(type) {\r\n\t\t\t\tcase 'any':\r\n\t\t\t\t\treturn [];\r\n\t\t\t\tcase 'array':\r\n\t\t\t\t\tif (!Array.isArray(value)) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\tproperty: path,\r\n\t\t\t\t\t\t\tmessage: 'expected an array, but ' + actualType + ' found instead'\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'integer':\r\n\t\t\t\tcase 'int':\r\n\t\t\t\t\ttype = 'integer';\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'float':\r\n\t\t\t\tcase 'double':\r\n\t\t\t\tcase 'number':\r\n\t\t\t\t\ttype = 'number';\r\n\t\t\t\t\t// fall through\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (actualType != type) {\r\n\t\t\t\t\t\treturn [{\r\n\t\t\t\t\t\t\tproperty: path,\r\n\t\t\t\t\t\t\tmessage: 'expected ' + type + ', but ' + actualType + ' found instead'\r\n\t\t\t\t\t\t}];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\tif (Array.isArray(type)) {\r\n\t\t\tvar unionErrors = [];\r\n\t\t\tfor(var j = 0; j < type.length; j++) { // a union type\r\n\t\t\t\tvar errs = checkType(type[j], value, errors);\r\n\t\t\t\tif (!errs.length) { return []; }\r\n\t\t\t\tunionErrors = unionErrors.concat(errs);\r\n\t\t\t}\r\n\t\t\treturn unionErrors;\r\n\t\t} else if (typeof type == 'object') {\r\n\t\t\treturn checkProp(value, type, path);\r\n\t\t}\r\n\t}\r\n\r\n\treturn [];\r\n}\r\n"},"lib/Enum.js":{"path":"lib/Enum.js","friendlyPath":"..lib.Enum","directory":"lib/","filename":"Enum.js","pre":true,"src":"exports = function() {\n\tif (arguments.length == 1) {\n\t\tif (typeof arguments[0] == 'object') {\n\t\t\tvar obj = arguments[0];\n\t\t\tfor (var i in obj) {\n\t\t\t\tif (!(obj[i] in obj)) {\n\t\t\t\t\tobj[obj[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t} else if (typeof arguments[0] != 'string') {\n\t\t\tkeys = arguments[0];\n\t\t}\n\t}\n\t\n\tif (!keys) { var keys = arguments; }\n\tvar obj = {};\n\tfor(var i = 0, len = keys.length; i < len; ++i) {\n\t\tif (keys[i]) {\n\t\t\tobj[keys[i]] = i + 1;\n\t\t}\n\t\tobj[i + 1] = keys[i];\n\t}\n\treturn obj;\n}"},"util/wordWrap.js":{"path":"util/wordWrap.js","friendlyPath":"..util.wordWrap","directory":"util/","filename":"wordWrap.js","src":"exports = function(str, maxWidth, prefix, tabWidth) {\n\tprefix = prefix || '';\n\tmaxWidth -= exports.getLengthWithTabs(prefix, tabWidth);\n\t\n\tif (!maxWidth) { return prefix + str; }\n\t\n\tvar words = str.split(' '),\n\t\tnumWords = words.length,\n\t\tlines = [{\n\t\t\tstr: [],\n\t\t\tlen: 0\n\t\t}],\n\t\ti = 0;\n\t\n\tfunction finalize() {\n\t\tlines[i] = prefix + curLine.str.join(' ');\n\t\t++i;\n\t}\n\t\n\tvar curLine = lines[i];\n\tfor (var j = 0; j < numWords; ++j) {\n\t\tvar word = words[j],\n\t\t\twordLen = word.length;\n\t\tif (curLine.len && curLine.len + wordLen + 1 > maxWidth) {\n\t\t\tfinalize();\n\t\t\tcurLine = lines[i] = {str: [word], len: wordLen};\n\t\t} else {\n\t\t\tcurLine.str.push(word);\n\t\t\tif (curLine.len) { curLine.len++; }\n\t\t\tcurLine.len += wordLen;\n\t\t}\n\t}\n\t\n\tif (curLine.len) {\n\t\tfinalize();\n\t} else {\n\t\tlines.pop();\n\t}\n\t\n\treturn lines.join('\\n');\n}\n\nexports.getLengthWithTabs = function(str, tabWidth) {\n\tvar tabs = 0;\n\tstr = str.replace(/\\t/g, function() { ++tabs; });\n\treturn str.length + tabs * (tabWidth || 8);\n}\n","pre":true},"../compilers/jsio_compile/optsDef.js":{"path":"../compilers/jsio_compile/optsDef.js","friendlyPath":".optsDef","directory":"../compilers/jsio_compile","filename":"optsDef.js","pre":true,"src":"exports = {\n\t'-g': {\n\t\talso: '--compressResult',\n\t\tname: 'compressResult',\n\t\ttype: 'boolean',\n\t\tdescription: \"Compress final output with Google's Closure Compiler\"\n\t},\n\t'-c': {\n\t\talso: '--compress',\n\t\tname: 'compressSources',\n\t\ttype: 'boolean',\n\t\t'default': false,\n\t\tdescription: \"Compress individual source files with Google's Closure Compiler\"\n\t},\n\t'--cwd': {\n\t\tname: 'cwd',\n\t\tdescription: \"sets the current working directory\"\n\t},\n\t'--pathCache': {\n\t\tname: 'pathCache',\n\t\ttype: 'object'\n\t},\n\t'--closure': {\n\t\tname: 'closurePath',\n\t\ttype: 'string',\n\t\tdescription: \"Path to closure.jar, if using compression (default: cwd)\"\n\t},\n\t'--environment': {\n\t\tname: 'environment',\n\t\ttype: 'string',\n\t\tdescription: 'runtime environment to target'\n\t},\n\t'-d': {\n\t\talso: '--debug',\n\t\tname: 'debug',\n\t\ttype: 'integer',\n\t\tminimum: 0,\n\t\tmaximum: 5,\n\t\tconstants: {\n\t\t\t'DEBUG': 1,\n\t\t\t'LOG': 2,\n\t\t\t'INFO': 3,\n\t\t\t'WARN': 4,\n\t\t\t'ERROR': 5\n\t\t},\n\t\tdescription: \"Turn on the compiler logger. A value of i logs all levels i and higher. 1: DEBUG, 2: LOG, 3: INFO, 4: WARN, 5: ERROR\"\n\t},\n\t'--dynamic': {\n\t\tname: 'dynamicImports',\n\t\ttype: 'object',\n\t\tdescription: 'Specify dynamic jsio imports'\n\t},\n\t'-p': {\n\t\tname: 'package',\n\t\talso: '--package',\n\t\ttype: 'object',\n\t\tdescription: \"Specifies a package file.  The compiler looks for configuration parameters from the command line as well as the package file.  Command line options have precedence over package settings provided in the package file.\"\n\t},\n\t'--no-ie': {\n\t\tname: 'noIE',\n\t\talso: '--noIE',\n\t\ttype: 'boolean',\n\t\t'default': false,\n\t\tdescription: 'Disables IE checks like trailing commas'\n\t},\n\t'-j': {\n\t\tname: 'jsioPath',\n\t\ttype: 'string',\n\t\talso: ['--jsio', '--jsioPath'],\n\t\tdescription: \"Provides an alternative path for jsio.  This path must contain the file 'jsio.js'.  The compiler contains a copy of jsio, so this is optional (can be used to compile against custom versions of jsio).\"\n\t},\n\t'--path': {\n\t\tname: 'path',\n\t\ttype: 'array',\n\t\tdescription: \"Provide extra paths (follow --path with a JSON literal array of strings)\"\n\t},\n\t'-o': {\n\t\tname: 'outputFile',\n\t\ttype: 'string',\n\t\talso: '--output',\n\t\tdescription: \"The filename to write the compiled code to.  Defaults to stdout (prints to the console).\"\n\t},\n\t'--includeJsio': {\n\t\tname: 'includeJsio',\n\t\ttype: 'boolean',\n\t\t'default': true,\n\t\tdescription: \"(advanced option) Defaults to true.  Set to false to exclude jsio from the resulting source.  Setting to false enables --preserveJsioSource.\"\n\t},\n\t'--appendImport': {\n\t\tname: 'appendImport',\n\t\ttype: 'boolean',\n\t\t'default': true,\n\t\tdescription: \"Defaults to true.  When true, the import statement passed to the compiler is appended to the end of the file.\"\n\t},\n\t'--compressorCachePath': {\n\t\tname: 'compressorCachePath',\n\t\ttype: 'string',\n\t\tdescription: \"Provide a path to cache compressed source.\"\n\t},\n\t'--help': {\n\t\ttype: 'boolean',\n\t\tdescription: \"prints this help message\"\n\t}\n}\n"},"preprocessors/compiler.js":{"path":"preprocessors/compiler.js","friendlyPath":"jsio.preprocessors.compiler","directory":"preprocessors/","filename":"compiler.js","pre":true,"src":"var path = require(\"jsio/util/path\");\n\n// compiler should be able to compile itself, so use a different name for calls to jsio that we don't want to try to compile\nvar JSIO = jsio.__jsio;\n\nvar gSrcTable = {};\nvar gDynamicList = {};\nvar gCompilerOpts = {};\n\nfunction testComment(match) {\n\treturn !/\\/\\//.test(match[1]);\n}\n\nexports = function(path, moduleDef, opts) {\n\topts = opts || {};\n\n\tif (gSrcTable[moduleDef.path]) {\n\t\tmoduleDef.src = '';\n\t\treturn;\n\t}\n\n\tlogger.info('compiling', moduleDef.path);\n\tcheckDynamicImports(moduleDef);\n\n\t// prevent double import\n\tgSrcTable[moduleDef.path] = true;\n\n\tvar self = moduleDef.path;\n\n\tif (gCompilerOpts.autoDetectPaths) {\n\t\tlogger.debug('detecting paths for', self);\n\n\t\tvar jsioAddPath = /^(.*)jsio\\.path\\.add\\s*\\(\\s*(['\"][^'\"]+?['\"])\\s*\\)/gm;\n\t\twhile (true) {\n\t\t\tvar match = jsioAddPath.exec(moduleDef.src);\n\t\t\tif (!match || !testComment(match)) { break; }\n\t\t\ttry {\n\t\t\t\tvar path = match[2];\n\t\t\t\tjsio.path.add(eval(path));\n\t\t\t\tlogger.info('added path', path);\n\t\t\t} catch(e) {\n\t\t\t\tlogger.info('failed to add path', path);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar jsioNormal = /^(.*)jsio\\s*\\(\\s*(['\"].+?['\"])\\s*(,\\s*\\{[^}]+\\})?\\)/gm;\n\twhile (true) {\n\t\tvar match = jsioNormal.exec(moduleDef.src);\n\t\tif (!match) { break; }\n\t\tif (!testComment(match)) { continue; }\n\n\t\tlogger.debug(moduleDef.path, 'detected', match[0])\n\n\t\tvar cmd = match[2],\n\t\t\tinlineOpts = match[3] ? match[3].substring(1) : '';\n\n\t\ttry {\n\t\t\tcmd = eval(cmd);\n\t\t} catch(e) {\n\t\t\tlogger.warn('could not compile import from', self + ':', cmd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (inlineOpts) {\n\t\t\ttry {\n\t\t\t\tinlineOpts = eval(\"(\" + inlineOpts + \")\") || {};\n\t\t\t} catch(e) {\n\t\t\t\tlogger.warn('could not parse opts for jsio in', self + ':', inlineOpts);\n\t\t\t}\n\t\t}\n\n\t\tif (!inlineOpts) {\n\t\t\tinlineOpts = {};\n\t\t}\n\n\t\tif (gCompilerOpts.preprocessors) {\n\t\t\tif (!inlineOpts.preprocessors) {\n\t\t\t\tinlineOpts.preprocessors = gCompilerOpts.preprocessors.slice(0);\n\t\t\t} else {\n\t\t\t\tgCompilerOpts.preprocessors.forEach(function (preprocessor) {\n\t\t\t\t\tif (inlineOpts.preprocessors.indexOf(preprocessor) == -1) {\n\t\t\t\t\t\tinlineOpts.preprocessors.push(preprocessor);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\trun(moduleDef, cmd, inlineOpts);\n\t\t} catch (e) {\n\t\t\tlogger.warn('could not compile import from', self + ':', cmd);\n\t\t}\n\t}\n\n\tvar jsioDynamic = /^(.*)jsio\\s*\\(\\s*DYNAMIC_IMPORT_(.*?)\\s*(,\\s*\\{[^}]+\\})?\\)/gm;\n\twhile(true) {\n\t\tvar match = jsioDynamic.exec(moduleDef.src);\n\t\tif (!match || !testComment(match)) { break; }\n\n\t\tvar cmd = match[2];\n\t\tvar inlineOpts;\n\t\ttry {\n\t\t\tinlineOpts = eval(match[3] || '') || {};\n\t\t} catch(e) {\n\t\t\tinlineOpts = {};\n\t\t}\n\n\t\tif (gCompilerOpts.dynamicImports && cmd in gCompilerOpts.dynamicImports) {\n\t\t\tvar dynamicImports = gCompilerOpts.dynamicImports[cmd];\n\t\t\tif (!dynamicImports) {\n\t\t\t\tlogger.debug('Dynamic import ' + cmd + ': <nothing>');\n\t\t\t\tcontinue;\n\t\t\t} else if (isArray(dynamicImports)) {\n\t\t\t\tfor (var j = 0, line; line = dynamicImports[j]; ++j) {\n\t\t\t\t\tlogger.debug('Dynamic import ' + cmd + ': ' + line);\n\t\t\t\t\trun(moduleDef, line, inlineOpts);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.debug('Dynamic import ' + cmd + ': ' + dynamicImports);\n\t\t\t\trun(moduleDef, dynamicImports, inlineOpts);\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.error('Missing: import definition\\nConstant', cmd, 'for DYNAMIC_IMPORT_' + cmd, ' was not provided to the compiler for ', path, 'from', moduleDef.path);\n\t\t}\n\t}\n\n\t// store a copy of the module def (with the source code)\n\tgSrcTable[moduleDef.path] = merge({}, moduleDef);\n\n\t// make sure to delete exports if we've executed this module for some reason (e.g. dynamic import files, base.js)\n\t// since we can't JSON.stringify exports (circular reference exports.module.exports)\n\tdelete gSrcTable[moduleDef.path].exports;\n\n\t// don't actually execute the source!\n\tmoduleDef.src = '';\n}\n\nexports.reset = function() {\n\tgSrcTable = {};\n}\n\n/**\n * opts.compressSources: compress each source file ** requires an active compressor (see exports.setCompressor)\n * opts.compressResult: compress the resulting file ** requires an active compressor (see exports.setCompressor)\n * opts.includeJsio: include a copy of jsio.js in the output\n */\nexports.generateSrc = function(opts, callback) {\n\tvar opts = merge(opts, {\n\t\t\tcompressSources: false,\n\t\t\tincludeJsio: true\n\t\t});\n\n\tif (opts.preCompress) {\n\t\topts.preCompress(gSrcTable);\n\t}\n\n\tvar cb = bind(this, buildJsio, opts, callback);\n\tif (opts.compressSources) {\n\t\tcompressTable(gSrcTable, opts, cb);\n\t} else {\n\t\tcb();\n\t}\n}\n\nexports.getPathJS = function() {\n\tvar cwd = jsio.__env.getCwd();\n\n\tvar cache = {};\n\tObject.keys(jsio.path.cache).forEach(function (key) {\n\t\tcache[key] = path.relative(cwd, jsio.path.cache[key]) || './';\n\t});\n\n\treturn 'jsio.path.set('\n\t\t+ JSON.stringify(jsio.path.get().map(function (value) {\n\t\t\treturn path.relative(cwd, value);\n\t\t})) + ');jsio.path.cache=' + JSON.stringify(cache) + ';';\n\n}\n\nfunction buildJsio(opts, callback) {\n\tfunction getJsioSrc() {\n\t\tvar src = jsio.__jsio.__init__.toString(-1);\n\t\tif (src.substring(0, 8) == 'function') {\n\t\t\tsrc = 'jsio=(' + src + ')();';\n\t\t}\n\t\treturn src;\n\t}\n\n\tvar src;\n\tvar jsioSrc = (opts.includeJsio ? getJsioSrc() : '')\n\t\t\t\t+ exports.getPathJS();\n\n\tvar cwd = jsio.__env.getCwd();\n\tvar table = {};\n\tfor (var entry in gSrcTable) {\n\t\tvar relPath = path.relative(cwd, entry);\n\t\ttable[relPath] = gSrcTable[entry];\n\t\ttable[relPath].path = relPath;\n\t\ttable[relPath].directory = path.relative(cwd, gSrcTable[entry].directory);\n\t}\n\n\t// if we're not allowed to modify the jsio source or we're not including the jsio source\n\t// then use jsio.setCachedSrc to include the source strings\n\tif (!opts.includeJsio) {\n\t\tlogger.info('source include method: jsio.setCachedSrc');\n\n\t\tvar lines = [];\n\t\tfor (var i in table) {\n\t\t\tlines.push(\"jsio.setCachedSrc('\" + table[i].path + \"',\" + JSON.stringify(table[i].src) + \");\");\n\t\t}\n\t\tsrc = jsioSrc + lines.join('\\n');\n\t} else {\n\t\tlogger.info('source include method: jsio.setCache');\n\n\t\tsrc = jsioSrc + \"jsio.setCache(\" + JSON.stringify(table) + \");\";\n\t}\n\n\tif (opts.compressResult && gCompilerOpts.compressor) {\n\t\tlogger.info('compressing final code...');\n\t\tgCompilerOpts.compressor(null, src, opts, callback);\n\t} else {\n\t\tcallback(src);\n\t}\n}\n\nfunction compressTable(table, opts, callback) {\n\tlogger.info('compressing sources');\n\n\tvar queue = [];\n\tfor (var i in table) { queue.push(i); }\n\n\tcompressStep(queue, table, opts, queue.pop(), callback);\n}\n\nfunction compressStep(queue, table, opts, key, callback) {\n\tif (key && gCompilerOpts.compressor) {\n\t\tlogger.log('compressing', key + '...');\n\t\tgCompilerOpts.compressor(key, table[key].src, opts, function(result) {\n\t\t\ttable[key].src = result;\n\t\t\tcompressStep(queue, table, opts, queue.pop(), callback);\n\t\t});\n\t} else {\n\t\tcallback();\n\t}\n}\n\nexports.getTable = function() { return gSrcTable; }\n\n// opts.compressor must have the signature function (string source, function callback)\nexports.setCompilerOpts = function(opts) {\n\tgCompilerOpts = opts;\n\n\tif ('debugLevel' in opts) {\n\t\tlogger.setLevel(opts.debugLevel);\n\t}\n\n\tif (opts.path) {\n\t\tif (isArray(opts.path)) {\n\t\t\tfor (var i = 0, len = opts.path.length; i < len; ++i) {\n\t\t\t\tjsio.path.add(opts.path[i]);\n\t\t\t}\n\t\t} else if (typeof opts.path == 'string') {\n\t\t\tjsio.path.add(opts.path);\n\t\t}\n\t}\n}\n\nexports.compile = function(statement, opts) {\n\tJSIO(statement, updateOpts(opts));\n}\n\nfunction run(moduleDef, cmd, opts) {\n\tJSIO.__require({}, moduleDef.directory, moduleDef.filename, cmd, updateOpts(opts));\n}\n\nfunction updateOpts(opts) {\n\topts = opts || {};\n\n\tif (!opts.preprocessors) {\n\t\topts.preprocessors = ['compiler'];\n\t} else if (opts.preprocessors.indexOf('compiler') == -1) {\n\t\topts.preprocessors.push('compiler');\n\t}\n\n\topts.reload = true;\n\topts.initialImport = true;\n\treturn opts;\n}\n\nfunction checkDynamicImports(moduleDef) {\n\tvar directory = moduleDef.directory;\n\n\t// have we checked this directory for dynamic imports?\n\tif (!gDynamicList[directory]) {\n\t\tgDynamicList[directory] = true;\n\n\t\tlogger.info(\"Checking directory\", directory, \"for dynamic imports... (\" + gCompilerOpts.environment + \")\");\n\n\t\t// try to do a commonJS-style import\n\t\tvar filename = path.join(directory, '__imports__');\n\t\tvar module = JSIO.__require(null, directory, 'compiler', './__imports__', {dontExport: true, suppressErrors: true});\n\t\tif (module && module.resolve) {\n\t\t\ttry {\n\t\t\t\tvar imports = module.resolve(gCompilerOpts.environment, gCompilerOpts);\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(\"Error running module.resolve for\", filename, \"\\n\\n\", e, \"\\n\\n\");\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tif (imports && imports.forEach) {\n\t\t\t\timports.forEach(function(imp) {\n\t\t\t\t\tlogger.log(\"dynamic import:\", imp);\n\n\t\t\t\t\tvar opts = {};\n\t\t\t\t\tif (gCompilerOpts.preprocessors) {\n\t\t\t\t\t\topts.preprocessors = gCompilerOpts.preprocessors.slice(0);\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\trun(moduleDef, \"import \" + imp, opts);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tlogger.error(\"module\", imp, \"failed to compile (requested from\", filename, \")\\n\\n\");\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.info(\"None found.\");\n\t\t}\n\t}\n}\n"},"../compilers/jsio_compile/compiler.js":{"path":"../compilers/jsio_compile/compiler.js","friendlyPath":"jsio_compile.compiler","directory":"../compilers/jsio_compile","filename":"compiler.js","src":"jsio('import jsio.util.path as path');\n\nvar JSIO = 'jsio';\n\nvar J;\n\nvar supportedEnvs = {\n\tnode: true,\n\tbrowser: true\n};\n\nvar _interface = null;\n\nexports.start = function(/*optional*/ args, opts) {\n\tif (opts && opts['interface']) {\n\t\t_interface = opts['interface'];\n\t\tdelete opts['interface'];\n\t} else {\n\t\tif (!J) {\n\t\t\tJ = jsio.__jsio.clone();\n\t\t}\n\n\t\tif (!J.__env.name in supportedEnvs) {\n\t\t\tlogger.error(\"autostart failed: unknown environment.\\n\\n\\tTry using compiler.run(args, opts) instead.\");\n\t\t\treturn;\n\t\t}\n\n\t\t_interface = jsio('import .' + J.__env.name + '_interface');\n\t}\n\n\t// expects the interface to eventually call run to do the actual compile\n\t_interface.setCompiler(this);\n\n\ttry {\n\t\t_interface.run(args, opts);\n\t} catch (e) {\n\t\t_interface.onError(e);\n\t}\n}\n\nfunction getPackage(fileName) {\n\ttry {\n\t\tvar pkg = eval('(' + J.__env.fetch(fileName) + ')');\n\t\tlogger.info('Package definition loaded from', fileName);\n\t\treturn pkg;\n\t} catch(e) {\n\t\tlogger.log(J.__env.getCwd())\n\t\tlogger.warn('If \"' + fileName + '\" is a package file, it could not be read.', e);\n\t}\n\treturn false;\n}\n\nexports.setDebugLevel = function(level) {\n\tlogger.setLevel(level);\n\t_interface.logger && _interface.logger.setLevel(level);\n}\n\n/**\n * args : array of arguments\n *   - args[0] : string - initial import string (optional if opts.package is provided)\n * opts : see optsDef.js\n *   - package : string - filename of a package definition\n *   - debug : integer - debug level (1 - 5)\n */\nexports.run = function(args, opts) {\n\tJ = jsio.__jsio.clone();\n\n\tif (opts.cwd) {\n\t\tJ.__env.getCwd = function () { return opts.cwd; };\n\t}\n\n\tvar debugLevel = 'debug' in opts ? opts.debug : 5;\n\texports.setDebugLevel(debugLevel);\n\n\tvar strOpts = JSON.stringify(opts, null, '\\t');\n\tlogger.info('Starting compiler with args: ', args, 'and options:', strOpts.substring(1, strOpts.length - 1));\n\n\t// use external copy of jsio rather than cached copy\n\tif (opts.jsioPath) {\n\t\t// update where import jsio.* comes from\n\t\tJ.path.cache['jsio'] = opts.jsioPath;\n\n\t\t// hack to 'set' the js.io source code\n\t\tJ.__jsio.__init__.toString = function() { return J.__env.fetch(J.__jsio.__util.buildPath(opts.jsioPath, 'jsio.js')); }\n\n\t\t// delete the cache copy\n\t\tvar sourceCache = J.__jsio.__srcCache;\n\t\tfor (var i in sourceCache) {\n\t\t\tdelete sourceCache[i];\n\t\t}\n\t}\n\n\tif (opts.path) {\n\t\tfor(var i = 0, len = opts.path.length; i < len; ++i) {\n\t\t\topts.path[i] && J.path.add(opts.path[i]);\n\t\t}\n\n\t\tdelete opts.path;\n\t}\n\n\tif (opts.pathCache) {\n\t\tfor (var key in opts.pathCache) {\n\t\t\tJ.path.cache[key] = opts.pathCache[key];\n\t\t}\n\t}\n\n\tlogger.info('js.io path:', JSON.stringify(J.path.get()));\n\n\tvar initial;\n\n\t// -- parse options --\n\t// try to maintain consistency with pyjsiocompile\n\n\t// accept a pkg file as the first argument\n\tif (/\\.pkg$/.test(args[2])) {\n\t\tvar pkg = getPackage(args[2]);\n\n\t\t// was it a valid pkg file?\n\t\t// (our test would also return true for \"import foo.bar.pkg\")\n\t\tif (pkg != false) {\n\t\t\targs.splice(2, 1); // consume the argument\n\t\t\topts['package'] = pkg; // treat the package the same as if it was specified on the command line\n\t\t}\n\t}\n\n\t// opts.package is probably the filename of the package\n\tif (typeof opts['package'] == 'string' && /\\.pkg$/.test(opts['package'])) {\n\t\topts['package'] = getPackage(opts['package']);\n\t}\n\n\t// parse the package contents\n\tif (opts['package']) {\n\t\tvar pkgDef = opts['package'];\n\n\t\tlogger.debug(pkgDef);\n\n\t\t// in pyjsiocompile, root does two things:\n\t\tif ('root' in pkgDef) {\n\t\t\t// 1. provide the initial import\n\t\t\tinitial = pkgDef.root;\n\n\t\t\t// pyjsiocompile package files don't have a relative import indicator (a prefix dot: '.')\n\t\t\t// to indicate that the first import is relative, so manually add one here\n\t\t\tif (!/^\\./.test(initial)) { initial = '.' + initial; }\n\n\t\t\t// 2. generate a statement to include at the bottom of the file\n\t\t\topts.appendImport = true;\n\t\t}\n\n\n\t\t// pyjsiocompile has keys for building the dynamic import ENV for the jsio net module.\n\t\t// All pairs of (environment, transport) should be included as dependencies.\n\n\t\tfunction extendArray(destKey, srcKey) {\n\t\t\topts[destKey] = (opts[destKey] || []).concat(pkgDef[srcKey || destKey]);\n\t\t}\n\n\t\tfunction extendObject(destKey, srcKey) {\n\t\t\topts[destKey] = JS.merge((opts[destKey] || {}), pkgDef[srcKey || destKey]);\n\t\t}\n\n\t\tif (pkgDef.environments) { extendArray('environments'); }\n\t\tif (pkgDef.transports) { extendArray('transports'); }\n\n\t\t// pyjsiocompile never supported additional dependencies, but the package files\n\t\t// have an empty key, so let's implement it anyway\n\t\tif (pkgDef.additional_dependancies) { extendArray('additionalDeps', 'additional_dependancies'); }\n\n\t\t// introduce new key 'dynamicImports' for handling dynamic import resolution\n\t\t//  -> a statement of jsio(DYNAMIC_IMPORT_foo) looks up 'foo' in the dynamicImports\n\t\t//     dictionary (each key maps to a string or array of strings)\n\t\tif (pkgDef.dynamicImports) { extendObject('dynamicImports'); }\n\t}\n\n\t// default argument is an import statement:\n\t//    jsio_compile \"import .myModule\"\n\t// (this will be args[2])\n\t// We do this after package resolution since the arguments on the\n\t// command-line should override any settings in the package file.\n\tif (args.length > 2) { initial = args[2]; }\n\n\tif (!initial) {\n\t\t_interface.onError(new Error('No initial import specified'));\n\t\treturn;\n\t}\n\n\t// pyjsiocompile built the dynamic import table for the net environment\n\t// which depends on runtime environment and desired transports.  This\n\t// code does the same thing, building a list of imports that need to\n\t// happen upon import of the net.env module.\n\tlogger.info('dynamic imports: ', opts.dynamicImports);\n\tif (!opts.dynamicImports) { opts.dynamicImports = {}; }\n\tif (!opts.dynamicImports.ENV) { opts.dynamicImports.ENV = null; }\n\tif (opts.transports && opts.environments) {\n\t\tvar ENV = opts.dynamicImports.ENV = opts.dynamicImports.ENV || [];\n\t\tfor (var i = 0, numT = opts.transports.length; i < numT; ++i) {\n\t\t\tfor (var j = 0, numE = opts.environments.length; j < numE; ++j) {\n\t\t\t\topts.dynamicImports.ENV.push('import net.env.' + opts.environments[j] + '.' + opts.transports[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar result = initial.match(/^(.*)\\.[j|t]s$/);\n\tif (result) {\n\t\tinitial = result[1];\n\t\tif (initial.charAt[0] != '/' && initial.charAt[0] != '.') {\n\t\t\tinitial = './' + initial;\n\t\t}\n\t}\n\n\t// run the actual compiler\n\tvar compiler = J('import jsio.preprocessors.compiler');\n\tcompiler.setCompilerOpts({\n\t\tdebugLevel: debugLevel,\n\t\tcompressor: opts.compressor || ('compress' in _interface ? bind(_interface, 'compress') : null),\n\t\tdefines: opts.defines,\n\t\tpath: opts.path,\n\t\tautoDetectPaths: true,\n\t\tenvironment: opts.environment,\n\t\tdynamicImports: opts.dynamicImports,\n\t\tpreprocessors: opts.preprocessors,\n\t\trawOpts: opts\n\t});\n\n\tcompiler.compile('import jsio.base');\n\n\tif (opts.additionalDeps) {\n\t\tvar deps = opts.additionalDeps;\n\t\tvar n = deps.length;\n\n\t\tfor (var i = 0; i < n; ++i) {\n\t\t\tlogger.info('compiling dependencies...', deps[i]);\n\t\t\tcompiler.compile(deps[i]);\n\t\t}\n\t}\n\n\tlogger.info('compiling main program', initial);\n\n\tcompiler.compile(initial);\n\n\tcompiler.generateSrc(opts, function(src) {\n\t\tif (opts.appendImport) {\n\t\t\tsrc = src + ';' + JSIO + '(\"' + initial + '\")';\n\t\t}\n\n\t\tif (opts.footer) {\n\t\t\tsrc = src + (opts.footer || '');\n\t\t}\n\n\t\t_interface.onFinish(opts, src);\n\t});\n}\n\n","pre":true},"util/path.js":{"path":"util/path.js","friendlyPath":"jsio.util.path","directory":"util/","filename":"path.js","pre":true,"src":"var util = jsio.__jsio.__util;\n\nexports.join = util.buildPath;\nexports.resolveRelativePath = util.resolveRelativePath;\nexports.splitPath = util.splitPath;\nexports.relative = util.relative;\nexports.splitExt = function(path) {\n\tvar res = exports.splitPath(path);\n\tvar i = res.filename.lastIndexOf('.');\n\tif (i == -1) {\n\t\tres.basename = res.filename;\n\t\tres.ext = '';\n\t} else {\n\t\tres.basename = res.filename.substring(0, i);\n\t\tres.ext = res.filename.substring(i);\n\t}\n\treturn res;\n}\n"},"lib/Callback.js":{"path":"lib/Callback.js","friendlyPath":"jsio.lib.Callback","directory":"lib/","filename":"Callback.js","pre":true,"src":"exports = Class(function() {\n\n\tthis._fired = false;\n\tthis._id = 0;\n\tthis._pending = null;\n\n\tthis.init = function() { this._run = []; };\n\t\n\t/* fired is @deprecated in favor of hasFired*/\n\tthis.hasFired = this.fired = function() { return this._fired; } ;\n\n\t// preserve pending callbacks, but clear fired status\n\tthis.reset = function() { this._args = []; this._fired = false; };\n\n\t// clear fired status and remove any pending callbacks\n\tthis.clear = function() { this.reset(); this._run = []; this._pending = null; this._stat = null; };\n\n\t// a convenience function to proxy arguments to `this.run`: arguments passed as the first argument\n\tthis.forward = function(args) { this.run.apply(this, args); };\n\n\t// when the lib.Callback object fires, run a ctx, method, and\n\t// (optional) curried arguments or a single callback function\n\tthis.run = function(ctx, method) {\n\t\tvar f = method ? bind.apply(this, arguments) : ctx;\n\t\tif (f) {\n\t\t\tif (this._fired) {\n\t\t\t\tf.apply(this, this._args);\n\t\t\t} else {\n\t\t\t\tthis._run.push(f);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.runOrTimeout = function(onFire, onTimeout, duration) {\n\t\tif (!onFire && !onTimeout) { return; }\n\n\t\tif (this._fired) {\n\t\t\tonFire.apply(this, this._args);\n\t\t} else {\n\t\t\tvar f = bind(this, function() {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tonFire.apply(this, this._args);\n\t\t\t});\n\n\t\t\tthis.run(f);\n\n\t\t\tvar timeout = setTimeout(bind(this, function() {\n\t\t\t\tfor (var i = 0, n = this._run.length; i < n; ++i) {\n\t\t\t\t\tif (this._run[i] == f) {\n\t\t\t\t\t\tthis._run.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tonTimeout();\n\t\t\t}), duration);\n\t\t}\n\t};\n\n\tthis.fire = function() {\n\t\tif (this._fired) { return; }\n\t\tthis._fired = true;\n\n\t\tvar cbs = this._run;\n\t\tthis._args = arguments;\n\t\tfor(var i = 0, len = cbs.length; i < len; ++i) {\n\t\t\tif (cbs[i]) { cbs[i].apply(this, arguments); }\n\t\t}\n\t};\n\n\tthis.chain = function(id) {\n\t\tif (!this._pending) { this._pending = {}; }\n\t\tif (id === undefined) { id = this._id++; }\n\t\tthis._pending[id] = true;\n\n\t\tthis.reset();\n\t\treturn bind(this, '_deferred', id);\n\t};\n\n\tthis._deferred = function(id) {\n\t\tif (!this._stat) { this._stat = {}; }\n\t\tif (this._stat.hasOwnProperty(id)) { return; }\n\n\t\tthis._stat[id] = Array.prototype.slice.call(arguments, 1);\n\t\tvar pending = this._pending;\n\t\tdelete pending[id];\n\t\tfor (var id in pending) {\n\t\t\tif (pending.hasOwnProperty(id)) { return; }\n\t\t}\n\n\t\tthis.fire(this._stat);\n\t};\n});\n"},"lib/Hash.js":{"path":"lib/Hash.js","friendlyPath":"jsio.lib.Hash","directory":"lib/","filename":"Hash.js","src":"/**\n * Summary: a basic Hash/Set class for number and string values.\n * Methods:\n *  - init(args...) - if args is a single JS object, this will be used to define\n *      the keys and values for the Hash.  \n *  - contains(value) \n * Example:\n *  var h = new Hash('a', 'b', 'c');\n *  h.contains('a') ==> true\n *\n *  var h = new Hash({a: '1', b: '2', c: '3'});\n *  h.contains('1') ==> true\n *  h.hasKey('a') ==> true\n */\nexports = Class(function() {\n\tthis.init = function() {\n\t\tthis._keys = {};\n\t\tthis._dict = {};\n\t\tthis._values = {};\n\t\tif (arguments.length == 1 && typeof arguments == 'object') {\n\t\t\tvar dict = arguments[0];\n\t\t\tfor (var i in dict) {\n\t\t\t\tif (dict.hasOwnProperty(i)) {\n\t\t\t\t\tthis._keys[i] = true;\n\t\t\t\t\tthis._values[i] = dict[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = 0, len = arguments.length; i < len; i++) {\n\t\t\t\tthis._keys[arguments[i]] = true;\n\t\t\t\tthis._values[arguments[i]] = true;\n\t\t\t};\n\t\t}\n\t}\n\t\n\tthis.contains = function(val) { return this._values.hasOwnProperty(val); }\n\tthis.hasKey = this.containsKey = function(key) { return this._keys.hasOwnProperty(key); }\n\tthis.each = function(f, ctx) {\n\t\tfor (var i in keys) {\n\t\t\tif (this._keys.hasOwnProperty(i)) {\n\t\t\t\tf.call(ctx || GLOBAL, i, this._values[i], this);\n\t\t\t}\n\t\t}\n\t}\n});\n","pre":true},"lib/PubSub.js":{"path":"lib/PubSub.js","friendlyPath":"jsio.lib.PubSub","directory":"lib/","filename":"PubSub.js","src":"/**\n * Summary: inherit from lib.PubSub if a class wants publish/subscribe ability\n * Methods:\n *  - publish(signal, args...) - all subscribers to signal will be called\n *     with the list of arguments provided.\n *  - subscribe(signal, ctx, method, args...) - register a bound method\n *     to a signal.  Any args that are passed in will be the first args\n *     when the method is invoked during a publish.\n *  Usage notes: There is one special signal '__any'.  Any subscribers to\n *     '__any' will be called on every publish with the first publish\n *     argument being the signal itself (after any args passed in during\n *     the corresponding subscribe).\n *     Calling the super constructor is not required for descendants of\n *     lib.PubSub.\n */\n\njsio('from ..std.uuid import uuid');\n\nvar ctx = jsio.__env.global,\n\tSLICE = Array.prototype.slice;\n\nexports = Class(function () {\n\n\tthis.init = function () {};\n\n\tthis.publish = function (signal) {\n\t\tif (this._subscribers) {\n\t\t\tvar args = SLICE.call(arguments, 1);\n\t\t\tif (this._subscribers.__any) {\n\t\t\t\tvar anyArgs = [signal].concat(args),\n\t\t\t\t\tsubs = this._subscribers.__any.slice(0);\n\t\t\t\tfor(var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\t\tsub.apply(ctx, anyArgs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this._subscribers[signal]) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar subs = this._subscribers[signal].slice(0);\n\t\t\tfor (var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\tsub.apply(ctx, args);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.subscribe = function (signal, ctx, method) {\n\t\tvar cb;\n\t\tif (arguments.length == 2) {\n\t\t\tcb = ctx;\n\t\t} else {\n\t\t\tcb = bind.apply(GLOBAL, SLICE.call(arguments, 1));\n\t\t\tcb._ctx = ctx; // references for unsubscription\n\t\t\tcb._method = method;\n\t\t}\n\n\t\tvar s = this._subscribers || (this._subscribers = {});\n\t\t(s[signal] || (s[signal] = [])).push(cb);\n\t\treturn this;\n\t};\n\n\tthis.subscribeOnce = function (signal, ctx, method) {\n\t\tvar args = arguments,\n\t\t\tcb = bind(this, function () {\n\t\t\t\tthis.unsubscribe(signal, cb);\n\t\t\t\tif (args.length == 2) {\n\t\t\t\t\tctx.apply(GLOBAL, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tbind.apply(GLOBAL, SLICE.call(args, 1))\n\t\t\t\t\t\t.apply(GLOBAL, arguments);\n\t\t\t\t}\n\t\t\t});\n\n\t\tif (args.length >= 3) {\n\t\t\tcb._ctx = ctx;\n\t\t\tcb._method = method;\n\t\t}\n\n\t\treturn this.subscribe(signal, cb);\n\t};\n\n\t// If no method is specified, all subscriptions with a callback context\n\t// of ctx will be removed.\n\n\tthis.unsubscribe = function (signal, ctx, method) {\n\t\tif (!this._subscribers || !this._subscribers[signal]) {\n\t\t\treturn this;\n\t\t}\n\t\tvar subs = this._subscribers[signal];\n\t\tfor (var i = 0, c; c = subs[i]; ++i) {\n\t\t\tif (c == ctx || c._ctx == ctx && (!method || c._method == method)) {\n\t\t\t\tsubs.splice(i--, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * EventEmitter-style API\n\t * http://nodejs.org/api/events.html\n\t */\n\n\tthis.listeners = function (type) {\n\t\tthis._subscribers = (this._subscribers ? this._subscribers : {});\n\t\treturn (this.hasOwnProperty.call(this._subscribers, type))\n\t\t\t? this._subscribers[type]\n\t\t\t: (this._subscribers[type] = []);\n\t};\n\n\tthis.addListener = this.on = function (type, f) {\n\t\tif (this.listeners(type).length + 1 > this._maxListeners && this._maxListeners !== 0) {\n\t\t\tif (typeof console !== \"undefined\") {\n\t\t\t\tconsole.warn(\"Possible EventEmitter memory leak detected. \" + this._subscribers[type].length + \" listeners added. Use emitter.setMaxListeners() to increase limit.\");\n\t\t\t}\n\t\t}\n\t\tthis.emit(\"newListener\", type, f);\n\t\treturn this.subscribe(type, this, f);\n\t};\n\n\tthis.once = function (type, f) {\n\t\treturn this.subscribeOnce(type, this, f);\n\t};\n\n\tthis.removeListener = function (type, f) {\n\t\tthis.unsubscribe(type, this, f);\n\t\treturn this;\n\t};\n\n\tthis.removeAllListeners = function (type) {\n\t\tif (this._subscribers) {\n\t\t\tfor (var k in this._subscribers) {\n\t\t\t\tif (type == null || type == k) {\n\t\t\t\t\tdelete this._subscribers[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.emit = function (type) {\n\t\tthis.publish.apply(this, arguments);\n\t\treturn this.listeners(type).length > 0;\n\t};\n\n\tthis._maxListeners = 10;\n\n\tthis.setMaxListeners = function (_maxListeners) {\n\t\tthis._maxListeners = _maxListeners;\n\t};\n\n\tthis.hasListeners = function (type) {\n\t\treturn this._subscribers && this._subscribers[type] && this._subscribers[type].length;\n\t};\n\n\t/**\n\t * listenTo for inverting control of #subscribe, #on, etc.\n\t * @param {object} obj something extending js.io's lib.PubSub\n\t * @param {string} name the event name to listen to\n\t * @param {callback} function to run on event\n\t * @return {this}\n\t */\n\tthis.listenTo = function (obj, name, callback) {\n\t\tvar listeningTo = this._listeningTo || (this._listeningTo = {});\n\t\tvar id = obj._listenId || (obj._listenId = uuid(8, 16));\n\t\tlisteningTo[id] = obj;\n\t\tobj.subscribe(name, this, callback);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stop listening to objects previously passed to `listenTo`.\n\t *\n\t * @example\n\t *     // Stop listening to all events on all objects\n\t *     this.stopListening();\n\t *\n\t *     // Stop listening to all events on `obj`\n\t *     this.stopListening(obj);\n\t *\n\t *     // Stop all of my callbacks for a given event\n\t *     this.stopListening(obj, name);\n\t *\n\t *     // Stop a single callback from firing\n\t *     this.stopListening(obj, name, callback);\n\t *\n\t * @param {object} [obj] object extending lib.PubSub and using listenTo\n\t * @param {string} [name] the event name to listen to\n\t * @param {callback} [callback] function to stop running\n\t * @return {this}\n\t */\n\tthis.stopListening = function (obj, name, callback) {\n\t\tvar events, names, retain, i, j, k, l, ev;\n\t\tvar listeningTo = this._listeningTo;\n\t\tif (!listeningTo) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlogger.log(obj);\n\t\tvar remove = !name && !callback;\n\t\tif (obj) {\n\t\t\t(listeningTo = {})[obj._listenId] = obj;\n\t\t}\n\n\t\tfor (var id in listeningTo) {\n\t\t\tobj = listeningTo[id];\n\n\t\t\tnames = name ? [name] : Object.keys(obj._subscribers);\n\t\t\tfor (i = 0, l = names.length; i < l; i++) {\n\t\t\t\tname = names[i];\n\t\t\t\tif (events = obj._subscribers[name]) {\n\t\t\t\t\tobj._subscribers[name] = retain = [];\n\t\t\t\t\tfor (j = 0, k = events.length; j < k; j++) {\n\t\t\t\t\t\tev = events[j];\n\t\t\t\t\t\tif ((callback && callback !== ev._method) ||\n\t\t\t\t\t\t\t\t(this && this !== ev._ctx)) {\n\t\t\t\t\t\t\tretain.push(ev);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!retain.length) delete obj._subscribers[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remove) {\n\t\t\t\tdelete this._listeningTo[id];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n});\n\n","pre":true},"std/uuid.js":{"path":"std/uuid.js","friendlyPath":"..std.uuid","directory":"std/","filename":"uuid.js","src":"/*\nBased on Math.uuid.js 1.4 by Robert Kieffer\n\n----\nCopyright (c) 2008, Robert Kieffer\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice,\n\tthis list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright\n\tnotice, this list of conditions and the following disclaimer in the\n\tdocumentation and/or other materials provided with the distribution.\n  * Neither the name of Robert Kieffer nor the names of its contributors\n\tmay be used to endorse or promote products derived from this software\n\twithout specific prior written permission.\n  \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n\n\n/*\n * Generate a random uuid.\n *\n * USAGE: uuid.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> std.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n * \n *   // One argument - returns ID of the specified length\n *   >>> std.uuid(15)\t // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> std.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> std.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> std.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n\n\nvar CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); \nexports.uuid = function (len, radix) {\n\tvar chars = CHARS, uuid = [], rnd = Math.random;\n\tradix = radix || chars.length;\n\n\tif (len) {\n\t\t// Compact form\n\t\tfor (var i = 0; i < len; i++) uuid[i] = chars[0 | rnd()*radix];\n\t} else {\n\t\t// rfc4122, version 4 form\n\t\tvar r;\n\n\t\t// rfc4122 requires these characters\n\t\tuuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n\t\tuuid[14] = '4';\n\n\t\t// Fill in random data.  At i==19 set the high bits of clock sequence as\n\t\t// per rfc4122, sec. 4.1.5\n\t\tfor (var i = 0; i < 36; i++) {\n\t\t\tif (!uuid[i]) {\n\t\t\t\tr = 0 | rnd()*16;\n\t\t\t\tuuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r & 0xf];\n\t\t\t}\n\t\t}\n\t}\n\treturn uuid.join('');\n};\n\n","pre":true},"lib/Sortable.js":{"path":"lib/Sortable.js","friendlyPath":"jsio.lib.Sortable","directory":"lib/","filename":"Sortable.js","src":"exports = Class('lib.Sortable', function(logger) {\n\n\tthis.toStringPush = function(indexer) {\n\t\tif (!this._toString || !this._toString.push) {\n\t\t\tthis._toString = [this.toString];\n\t\t} else {\n\t\t\tthis._toString.push(this.toString);\n\t\t}\n\n\t\tthis.toString = indexer;\n\t}\n\n\tthis.toStringPop = function() {\n\t\tthis.toString = this._toString.pop();\n\t}\n});\n\nvar zeroPadding = [];\nfunction ensurePadding(n) {\n\tfor (var i = zeroPadding.length; i < n; ++i) {\n\t\tvar str = [];\n\t\tfor (var j = 0; j < i; ++j) { str.push('0'); }\n\t\tzeroPadding[i] = str.join('');\n\t}\n}\n\n/**\n * Here we handle arbitrary sorting indexes transparently converting numbers to strings\n * for efficient sorting with toString.  Unfortunately, this does not work for large floating\n * point values, but that functionality could theoretically be added if desired.\n */\nfunction sortIndex(i) { return this[i]; }\n\nexports.sort = function(arr, indexer) {\n\n\tvar len = arr.length,\n\t\tindex = new Array(len),\n\t\tresult = new Array(len),\n\t\ttoString = new Array(len),\n\t\tindexers = Array.prototype.slice.call(arguments, 1),\n\t\thaveMultiple = !!indexers[1];\n\n\tif (haveMultiple) {\n\t\tfor (var i = 0; i < len; ++i) {\n\t\t\tresult[i] = [];\n\t\t}\n\t}\n\n\tfor (var k = 0, indexer; indexer = indexers[k]; ++k) {\n\t\tfor (var i = 0; i < len; ++i) {\n\t\t\tindex[i] = indexer.call(arr[i], i);\n\t\t}\n\n\t\tif (typeof index[0] == 'number') {\n\t\t\t// we do two passes here:\n\t\t\t//  1: find the max and min numerical indices\n\t\t\t//  2: convert the indices to strings with appropriate zero-padding\n\t\t\tvar largest = index[0],\n\t\t\t\tsmallest = index[0];\n\n\t\t\tfor (var i = 1; i < len; ++i) {\n\t\t\t\tif (index[i] > largest) {\n\t\t\t\t\tlargest = index[i];\n\t\t\t\t} else if (index[i] < smallest) {\n\t\t\t\t\tsmallest = index[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we have to be very careful here - large floating point numbers will break the\n\t\t\t// string padding code\n\t\t\tvar paddingPositive = String(Math.floor(largest)).length,\n\t\t\t\tpaddingNegative = String(Math.floor(smallest)).length;\n\n\t\t\tensurePadding(Math.max(paddingPositive, paddingNegative));\n\n\t\t\tvar strLen;\n\t\t\tfor (var i = 0; i < len; ++i) {\n\t\t\t\tvar val = index[i];\n\t\t\t\tif (val < 0) {\n\t\t\t\t\tval = -(smallest - val);\n\t\t\t\t\tstrLen = ('' + Math.floor(val)).length;\n\t\t\t\t\tindex[i] = '-' + zeroPadding[paddingNegative - strLen] + val;\n\t\t\t\t} else {\n\t\t\t\t\tstrLen = ('' + Math.floor(val)).length;\n\t\t\t\t\tindex[i] = zeroPadding[paddingPositive - strLen] + val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (haveMultiple) {\n\t\t\tfor (var i = 0; i < len; ++i) {\n\t\t\t\tresult[i].push(index[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tresult = index;\n\t\t}\n\t}\n\n\tfor (var i = 0; i < len; ++i) {\n\t\tif (haveMultiple) {\n\t\t\tresult[i] = result[i].join('|');\n\t\t}\n\n\t\ttoString[i] = arr[i].hasOwnProperty('toString') && arr[i].toString || null;\n\t\tarr[i].toString = bind(result, sortIndex, i);\n\t}\n\n\tArray.prototype.sort.apply(arr);\n\n\tfor (var i = 0; i < len; ++i) {\n\t\tif (toString[i]) {\n\t\t\tarr[i].toString = toString[i];\n\t\t} else {\n\t\t\tdelete arr[i].toString;\n\t\t}\n\t}\n}\n","pre":true},"lib/sort.js":{"path":"lib/sort.js","friendlyPath":"jsio.lib.sort","directory":"lib/","filename":"sort.js","src":"var zeroPadding = [];\nfunction ensurePadding(n) {\n\tfor (var i = zeroPadding.length; i < n; ++i) {\n\t\tvar str = [];\n\t\tfor (var j = 0; j < i; ++j) { str.push('0'); }\n\t\tzeroPadding[i] = str.join('');\n\t}\n}\n\n/**\n * Here we handle arbitrary sorting indexes transparently converting numbers to strings\n * for efficient sorting with toString.  Unfortunately, this does not work for large floating\n * point values, but that functionality could theoretically be added if desired.\n */\nfunction sortIndex(i) { return this[i]; }\n\nexports = function(arr, indexer) {\n\n\tvar len = arr.length,\n\t\tindex = new Array(len),\n\t\tresult = new Array(len),\n\t\ttoString = new Array(len),\n\t\tindexers = Array.prototype.slice.call(arguments, 1),\n\t\thaveMultiple = !!indexers[1];\n\n\tif (haveMultiple) {\n\t\tfor (var i = 0; i < len; ++i) {\n\t\t\tresult[i] = [];\n\t\t}\n\t}\n\n\tfor (var k = 0, indexer; indexer = indexers[k]; ++k) {\n\t\tfor (var i = 0; i < len; ++i) {\n\t\t\tindex[i] = indexer.call(arr[i], i);\n\t\t}\n\n\t\tif (typeof index[0] == 'number') {\n\t\t\t// we do two passes here:\n\t\t\t//  1: find the max and min numerical indices\n\t\t\t//  2: convert the indices to strings with appropriate zero-padding\n\t\t\tvar largest = index[0],\n\t\t\t\tsmallest = index[0];\n\n\t\t\tfor (var i = 1; i < len; ++i) {\n\t\t\t\tif (index[i] > largest) {\n\t\t\t\t\tlargest = index[i];\n\t\t\t\t} else if (index[i] < smallest) {\n\t\t\t\t\tsmallest = index[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we have to be very careful here - large floating point numbers will break the\n\t\t\t// string padding code\n\t\t\tvar paddingPositive = String(Math.floor(largest)).length,\n\t\t\t\tpaddingNegative = String(Math.floor(smallest)).length;\n\n\t\t\tensurePadding(Math.max(paddingPositive, paddingNegative));\n\n\t\t\tvar strLen;\n\t\t\tfor (var i = 0; i < len; ++i) {\n\t\t\t\tvar val = index[i];\n\t\t\t\tif (val < 0) {\n\t\t\t\t\tval = -(smallest - val);\n\t\t\t\t\tstrLen = ('' + Math.floor(val)).length;\n\t\t\t\t\tindex[i] = '-' + zeroPadding[paddingNegative - strLen] + val;\n\t\t\t\t} else {\n\t\t\t\t\tstrLen = ('' + Math.floor(val)).length;\n\t\t\t\t\tindex[i] = zeroPadding[paddingPositive - strLen] + val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (haveMultiple) {\n\t\t\tfor (var i = 0; i < len; ++i) {\n\t\t\t\tresult[i].push(index[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tresult = index;\n\t\t}\n\t}\n\n\tfor (var i = 0; i < len; ++i) {\n\t\tif (haveMultiple) {\n\t\t\tresult[i] = result[i].join('|');\n\t\t}\n\n\t\ttoString[i] = arr[i].hasOwnProperty('toString') && arr[i].toString || null;\n\t\tarr[i].toString = bind(result, sortIndex, i);\n\t}\n\n\tArray.prototype.sort.apply(arr);\n\n\tfor (var i = 0; i < len; ++i) {\n\t\tif (toString[i]) {\n\t\t\tarr[i].toString = toString[i];\n\t\t} else {\n\t\t\tdelete arr[i].toString;\n\t\t}\n\t}\n}\n","pre":true},"math/geom/Circle.js":{"path":"math/geom/Circle.js","friendlyPath":"jsio.math.geom.Circle","directory":"math/geom/","filename":"Circle.js","src":"jsio('import .Point');\n\n/**\n * @extends math.geom.Point\n * Models a circle given a radius.\n *   Circle(x, y, radius)\n *   Circle({x: default 0, y: default 0, radius: default 0})\n */\nexports = Class(Point, function(supr) {\n\tthis.init = function(a, b, c) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.radius = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tthis.x = a.x || 0;\n\t\t\t\tthis.y = a.y || 0;\n\t\t\t\tthis.radius = a.radius || 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.x = a;\n\t\t\t\tthis.y = b;\n\t\t\t\tthis.radius = c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Scale the position and radius of this circle by a percentage.\n\t */\n\t\n\tthis.scale = function(s) {\n\t\tsupr(this, 'scale', arguments);\n\t\tthis.radius *= s;\n\t\treturn this;\n\t}\n});","pre":true},"math/geom/Point.js":{"path":"math/geom/Point.js","friendlyPath":".Point","directory":"math/geom/","filename":"Point.js","src":"/**\n * @package math.geom.Point;\n * Models a Point in 2D space.\n */\n\nvar Point = exports = Class(function() {\n\tthis.init = function(a, b) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.x = a.x || 0;\n\t\t\t\tthis.y = a.y || 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.x = a || 0;\n\t\t\t\tthis.y = b || 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Rotates this point around the origin by a value in radians.\n\t */\n\t\n\tthis.rotate = function(r) {\n\t\tvar x = this.x,\n\t\t\ty = this.y,\n\t\t\tcosr = Math.cos(r),\n\t\t\tsinr = Math.sin(r);\n\t\t\n\t\tthis.x = x * cosr - y * sinr;\n\t\tthis.y = x * sinr + y * cosr;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Translate this point by two scalars or by another point.\n\t */\n\t\n\tthis.translate = this.add = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x += x;\n\t\t\tthis.y += y;\n\t\t} else {\n\t\t\tthis.x += x.x;\n\t\t\tthis.y += x.y;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Subtract this point by two scalars or by another point.\n\t */\n\t\n\tthis.subtract = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x -= x;\n\t\t\tthis.y -= y;\n\t\t} else {\n\t\t\tthis.x -= x.x;\n\t\t\tthis.y -= x.y;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Scale this number.\n\t */\n\n\tthis.scale = function(sx, sy) {\n\t\t//if no scaleY specified\n\t\tif(sy === undefined) sy = sx;\n\n\t\tthis.x *= sx;\n\t\tthis.y *= sy;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the magnitude of this point at a constant angle.\n\t */\n\t\n\tthis.setMagnitude = function(m) {\n\t\tvar theta = this.getAngle();\n\t\tthis.x = m * Math.cos(theta);\n\t\tthis.y = m * Math.sin(theta);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normalize this point to the unit circle.\n\t */\n\t\n\tthis.normalize = function() {\n\t\tvar m = this.getMagnitude();\n\t\tthis.x /= m;\n\t\tthis.y /= m;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add magnitude to this point.\n\t */\n\t\n\tthis.addMagnitude = function(m) {\n\t\treturn this.setMagnitude(this.getMagnitude() + m);\n\t};\n\n\tthis.getMagnitude = function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t};\n\n\tthis.getSquaredMagnitude = function() {\n\t\treturn this.x * this.x + this.y * this.y;\n\t};\n\n\tthis.getDirection = this.getAngle = function() {\n\t\treturn Math.atan2(this.y, this.x);\n\t};\n\t\n});\n\n/*\n */\nPoint.getPolarR = function(x, y) { \n\tthrow \"notImplemented\";\n}\n\n/*\n\t### Class Method: Point.getPolarTheta (x, y)\n\t1. `x {number}`\n\t2. `y {number}`\n\t3. Return: `{number}`\n*/\nPoint.getPolarTheta = function(x, y) { \n\tvar val = Math.atan2(y,x) + (Math.PI * 2); \n\treturn val > Math.PI * 2 ? val % (Math.PI * 2) : val;\n}\n\n/*\n\t### Class Method: Point.add (a, b, c, d)\n\t### Class Method: Point.translate (a, b, c, d)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. `d {number}`\n\t5. Return: `{Point}`\n */\nPoint.add = Point.translate = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).add(b);\n\t\tcase 3: return new Point(a).add(b, c);\n\t\tcase 4: return new Point(a, b).add(c, d);\n\t}\n}\n\n/*\n\t### Class Method: Point.subtract (a, b, c, d)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. `d {number}`\n\t5. Return: `{Point}`\n */\nPoint.subtract = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).subtract(b);\n\t\tcase 3: return new Point(a).subtract(b, c);\n\t\tcase 4: return new Point(a, b).subtract(c, d);\n\t}\n}\n\n/*\n\t### Class Method: Point.scale (a, b, c) \n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n */\nPoint.scale = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).scale(b);\n\t\tcase 3: return new Point(a, b).scale(c);\n\t}\n}\n\n/*\n\t### Class Method: Point.setMagnitude (a, b, c)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n*/\nPoint.setMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).setMagnitude(c);\n\t\tcase 3: return new Point(a, b).setMagnitude(c);\n\t}\n}\n\n/*\n\t### Class Method: Point.addMagnitude (a, b, c)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n */\nPoint.addMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: pt = new Point(a); break;\n\t\tcase 3: pt = new Point(a, b); b = c; break;\n\t}\n\t\n\treturn pt.addMagnitude(b);\n}\n\n/*\n\t### Class Method: Point.getMagnitude (a, b)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. Return: `{Point}`\n */\nPoint.getMagnitude = function(a, b) { return new Point(a, b).getMagnitude(); }\n\n/*\n\t### Class Method: Point.rotate (a, b, c)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n */\nPoint.rotate = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).rotate(b);\n\t\tcase 3: return new Point(a, b).rotate(c);\n\t}\n}\n\n/**\n * Treat two points as vectors and project a onto b\n *  (a dot unit(b)) * unit(b)\n */\nPoint.project = function (a, b) {\n\tvar unitB = new Point(b).normalize();\n\treturn unitB.scale(unitB.x * a.x + unitB.y * a.y);\n}\n","pre":true},"math/geom/Line.js":{"path":"math/geom/Line.js","friendlyPath":"jsio.math.geom.Line","directory":"math/geom/","filename":"Line.js","src":"jsio('import .Point');\n\nexports = Class(function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.start = new Point();\n\t\t\t\tthis.end = new Point();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.start = new Point(a.start);\n\t\t\t\tthis.end = new Point(a.end);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b, c);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tthis.start = new Point(a, b);\n\t\t\t\tthis.end = new Point(c, d);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.getMagnitude = \n\tthis.getLength = function() {\n\t\tvar dx = this.end.x - this.start.x,\n\t\t\tdy = this.end.y - this.start.y;\n\t\t\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n});\n","pre":true},"math/geom/Polygon.js":{"path":"math/geom/Polygon.js","friendlyPath":"jsio.math.geom.Polygon","directory":"math/geom/","filename":"Polygon.js","src":"exports = Class(function() {\n\n\tthis.init = function (opts) {\n\t\tthis.x = opts.x;\n\t\tthis.y = opts.y;\n\n\t\tif ('convex' in opts) {\n\t\t\tthis.convex = opts.convex;\n\t\t}\n\t}\n\t\n\t/**\n\t *\n\t * Polygon representation : { \n\t *                                 x : [x1, x2, ... , xn], \n\t *                                 y : [y1, y2, ... , yn],\n\t *                            convex : boolean\n\t *                                                          } \n\t * \n\t **/\n\n\t/*\n\t * Check for convexity using Jarvis's march (aka giftwrapping)\n\t */\n\tthis.isConvex = function () {\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar length = x.length;\n\n\t\t// Polygon is non-degenerate\n\t\tif (length < 3) { return false; }\n\t\n\t\tvar ax = x[0] - x[length - 1];\n\t\tvar ay = y[0] - y[length - 1];\n\t\tvar bx = x[1] - x[0];\n\t\tvar by = y[1] - y[0];\n\t\n\t\tvar theta = Math.asin((by * ax - bx * ay) / (norm([ax, ay]) * norm([bx, by])));\n\t\tvar orientation = sign(theta);\n\t\n\t\tfor (var k = 1; k < length-1; k++) {\n\t\t\tax = x[k] - x[k - 1];\n\t\t\tay = y[k] - y[k - 1];\n\t\t\tbx = x[k + 1] - x[k];\n\t\t\tby = y[k + 1] - y[k];\n\t\t\t\n\t\t\ttheta = Math.asin((by * ax - bx * ay) / (norm([ax, ay]) * norm([bx, by])));\n\n\t\t\tif (theta != 0 && orientation + sign(theta) == 0) { \n\t\t\t\tthis.convex = false;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tax = x[length - 1] - x[length - 2];\n\t\tay = y[length - 1] - y[length - 2];\n\t\tbx = x[0]-x[length - 1];\n\t\tby = y[0]-y[length - 1];\n\t\ttheta = Math.asin((by * ax - bx * ay) / (norm([ax, ay]) * norm([bx, by])));\n\t\t\n\t\tif (theta != 0 && orientation + sign(theta) == 0) {\n\t\t\tthis.convex = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.convex = true;\n\t\treturn true;\n\t};\n\n\t\n\tthis.getCenter = function() {\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar center = [array_sum(x) / x.length, array_sum(y) / y.length];\n\t\treturn center;\n\t}\n\n\tthis.containsPoint = function (point) {\n\t\tvar x = point[0];\n\t\tvar y = point[1];\n\t\tvar j = 0;\n\t\tvar polyx = this.x;\n\t\tvar polyy = this.y;\n\t\tvar x1, x2, y1, y2;\n\t\tvar v1x, v1y, v2x, v2y;\n\t\tvar theta = 0;\n\t\tvar l = this.x.length;\n\t\t\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tj = (i === l - 1) ? 0 : i + 1;\n\t\t\tx1 = polyx[i];\n\t\t\ty1 = polyy[i];\n\t\t\tx2 = polyx[j];\n\t\t\ty2 = polyy[j];\n\t\t\t\n\t\t\tv1x = x1 - x;\n\t\t\tv1y = y1 - y;\n\t\t\tv2x = x2 - x;\n\t\t\tv2y = y2 - y;\n\t\t\t\n\t\t\ttheta += Math.asin((v1x * v2y - v1y * v2x) / (norm([v1x,v1y]) * norm([v2x, v2y])));\n\t\t}\n\n\t\ttheta = Math.abs(theta);\n\t\treturn approx(theta, 2 * Math.PI, 1e-6); \n\t};\n\t\n\t/* \n\t * Scale the polygon about the 'center of mass'\n\t * @scalar : the scaling factor\n\t */\n\tthis.scale = function (scalar) {\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar center = [array_sum(x) / x.length, array_sum(y) / y.length];\n\t\t\n\t\tfor (var k = 0; k < x.length; k++) {\n\t\t\tx[k] = center[0] + (x[k] - center[0]) * scalar;\n\t\t\ty[k] = center[1] + (y[k] - center[1]) * scalar;\n\t\t}\n\t};\n\n\t/* \n\t * Translate the polygon along the given vector\n\t * @displacement : vector specifying translation\n\t */\n\tthis.translate = function (displacement) {\n\t\tfor (var k = 0; k < this.x.length; k++){\n\t\t\tthis.x[k] += displacement[0], this.y[k] += displacement[1];\n\t\t}\n\t};\n\t\n\t/* \n\t * Rotate the polygon about the center*\n\t * @theta : angle which to rotate counterclockwise\n\t */\n\tthis.rotate = function (theta) {\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar center = [array_sum(x) / x.length, array_sum(y) / y.length];\n\n\t\tvar cos = Math.cos(theta);\n\t\tvar sin = Math.sin(theta);\n\t\t\n\t\tfor (var k = 0; k < x.length; k++){\n\t\t\tvar offset = [x[k] - center[0], y[k] - center[1]];\n\t\t\tthis.x[k] = cos * offset[0] - sin * offset[1];\n\t\t\tthis.y[k] = sin * offset[0] - cos * offset[1];\n\t\t}\n\t};\n\n\t/*\n\t * Find the smallest element in an array, wrt compare (avoids sorting)\n\t * @compare : return -1 || 0 || 1\n\t */\n\tfunction smallest (arr, compare) {\n\t\tvar n = arr.length;\n\t\tif (!n) { return; }\n\n\t\tvar min = arr[0];\n\t\tfor (var k = 1; k < n; k++){\n\t\t\tif (compare(arr[k], min) == -1) {\n\t\t\t\tmin = arr[k];\n\t\t\t}\n\t\t}\n\n\t\treturn min;\n\t}\n\n\t/*\n\t * Sum an array of numbers\n\t */\n\tfunction array_sum (arr) {\n\t\tvar ans = 0;\n\t\tfor (k = 0; k < arr.length; k++) {\n\t\t\tans += arr[k];\n\t\t}\n\t\treturn ans;\n\t}\n\n\tfunction len (vec) {\n\t\treturn Math.pow(vec[0] * vec[0] + vec[1] * vec[1], 0.5);\n\t}\n\n\tfunction normalize (v) {\n\t\tvar len = len(v);\n\t\treturn [v[0] / len, v[1] / len];\n\t}\n\n\tfunction vec_len (v) {\n\t\treturn Math.pow(v[0] * v[0] + v[1] * v[1], 0.5)\n\t}\n\t\n\tfunction sign (n) {\n\t\treturn n < 0 ? -1 : n > 0 ? 1 : 0;\n\t}\n\t\n\tfunction approx(a,b,epsilon) {\n\t\treturn (Math.abs(a - b) < epsilon);\n\t}\n\t\n\tfunction norm (v) {\n\t\treturn Math.pow(v[0] * v[0] + v[1] * v[1], 0.5);\n\t}\n});\n","pre":true},"math/geom/Rect.js":{"path":"math/geom/Rect.js","friendlyPath":"jsio.math.geom.Rect","directory":"math/geom/","filename":"Rect.js","src":"jsio('import lib.Enum');\njsio('import .Point');\njsio('import .Line');\njsio('import .intersect');\n\n/**\n * Model a rectangle.\n */\n\nvar Rect = exports = Class(function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0: // init\n\t\t\t\tthis.width = this.height = this.x = this.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1: // copy\n\t\t\t\tthis.width = a.width;\n\t\t\t\tthis.height = a.height;\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tbreak;\n\t\t\tcase 2: // (x, y), (width, height)\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b.x;\n\t\t\t\tthis.height = b.y;\n\t\t\t\tbreak;\n\t\t\tcase 3: // (x, y), width, height\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b;\n\t\t\t\tthis.height = c;\n\t\t\t\tbreak;\n\t\t\tcase 4: // x, y, width, height\n\t\t\t\tthis.x = a;\n\t\t\t\tthis.y = b;\n\t\t\t\tthis.width = c;\n\t\t\t\tthis.height = d;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Normalize negative height and width dimensions by adjusting the position\n\t * of the rect.\n\t */\n\t\n\tthis.normalize = function() {\n\t\tif (this.width < 0) {\n\t\t\tthis.x -= this.width;\n\t\t\tthis.width = -this.width;\n\t\t}\n\t\t\n\t\tif (this.height < 0) {\n\t\t\tthis.y -= this.height;\n\t\t\tthis.height = -this.height;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Generate the intersection of a rectange with another rectangle.\n\t */\n\n\tthis.intersectRect = function (rect) {\n\t\tif (intersect.isRectAndRect(this, rect)) {\n\t\t\tvar x1 = this.x;\n\t\t\tvar y1 = this.y;\n\t\t\tvar x2 = this.x + this.width;\n\t\t\tvar y2 = this.y + this.height;\n\n\t\t\tthis.x = Math.max(x1, rect.x),\n\t\t\tthis.y = Math.max(y1, rect.y),\n\t\t\tthis.width = Math.min(x2, rect.x + rect.width) - this.x;\n\t\t\tthis.height = Math.min(y2, rect.y + rect.height) - this.y;\n\t\t} else {\n\t\t\tthis.width = 0;\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\t\n\t/**\n\t * Generate the union of a rectange with another rectangle.\n\t */\n\t\n\tthis.unionRect = function(rect) {\n\t\tthis.normalize();\n\t\tif (rect.normalize) { rect.normalize(); }\n\t\t\n\t\tvar x2 = this.x + this.width,\n\t\t\ty2 = this.y + this.height;\n\t\t\n\t\tvar rx2 = rect.x + rect.width,\n\t\t\try2 = rect.y + rect.height;\n\t\t\n\t\tthis.x = this.x < rect.x ? this.x : rect.x;\n\t\tthis.y = this.y < rect.y ? this.y : rect.y;\n\t\t\n\t\tthis.width = (x2 > rx2 ? x2 : rx2) - this.x;\n\t\tthis.height = (y2 > ry2 ? y2 : ry2) - this.y;\n\t};\n\n\t/**\n\t * Get a point for the given corner.\n\t */\n\t\n\tthis.getCorner = function(i) {\n\t\tswitch(i) {\n\t\t\tcase CORNERS.TOP_LEFT:\n\t\t\t\treturn new Point(this.x, this.y);\n\t\t\tcase CORNERS.TOP_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y);\n\t\t\tcase CORNERS.BOTTOM_LEFT:\n\t\t\t\treturn new Point(this.x, this.y + this.height);\n\t\t\tcase CORNERS.BOTTOM_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y + this.height);\n\t\t}\n\t}\n\t\n\t/**\n\t * Return a line corresponding to the given side.\n\t */\n\t\n\tthis.getSide = function(i) {\n\t\tswitch(i) {\n\t\t\tcase SIDES.TOP:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_LEFT), this.getCorner(CORNERS.TOP_RIGHT));\n\t\t\tcase SIDES.RIGHT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_RIGHT), this.getCorner(CORNERS.BOTTOM_RIGHT));\n\t\t\tcase SIDES.BOTTOM:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_RIGHT), this.getCorner(CORNERS.BOTTOM_LEFT));\n\t\t\tcase SIDES.LEFT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_LEFT), this.getCorner(CORNERS.TOP_LEFT));\n\t\t}\n\t}\n\n\t/**\n\t * Return the center point of a rectangle.\n\t */\n\t\n\tthis.getCenter = function() {\n\t\treturn new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t}\n});\n\nvar SIDES = Rect.SIDES = lib.Enum('TOP', 'BOTTOM', 'LEFT', 'RIGHT');\nvar CORNERS = Rect.CORNERS = lib.Enum('TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_RIGHT', 'BOTTOM_LEFT');\n","pre":true},"math/geom/intersect.js":{"path":"math/geom/intersect.js","friendlyPath":".intersect","directory":"math/geom/","filename":"intersect.js","src":"jsio('import .Point');\njsio('import .Line');\njsio('import .Rect');\n\n/**\n * @package math.geom.intersect\n */\nvar intersect = exports;\n\nintersect.pointAndRect = intersect.ptAndRect = function (pt, rect) {\n\tvar x = pt.x,\n\t\t\ty = pt.y;\n\treturn (x >= rect.x &&\n\t\t\t\t\tx <= rect.x + rect.width &&\n\t\t\t\t\ty >= rect.y &&\n\t\t\t\t\ty <= rect.y + rect.height);\n};\n\nintersect.rectAndPoint = intersect.rectAndPt = function (rect, pt) {\n\treturn intersect.pointAndRect(pt, rect);\n};\n\nintersect.pointAndCircle = intersect.ptAndCirc = function(pt, circle) {\n\tvar dx = pt.x - circle.x,\n\t\t\tdy = pt.y - circle.y;\n\treturn dx * dx + dy * dy < circle.radius * circle.radius;\n};\n\nintersect.circleAndPoint = intersect.circAndPt = function (circle, pt) {\n\treturn intersect.pointAndCircle(pt, circle);\n};\n\nintersect.circleAndCircle = function(circle1, circle2) {\n\tvar dx = circle2.x - circle1.x,\n\t\tdy = circle2.y - circle1.y;\n\tvar radiusSum = circle1.radius + circle2.radius;\n\treturn dx * dx + dy * dy <= radiusSum * radiusSum;\n};\n\nintersect.isRectAndRect = function (rect1, rect2) {\n\treturn !((rect1.y + rect1.height < rect2.y) ||\n\t\t\t\t\t (rect2.y + rect2.height < rect1.y) ||\n\t\t\t\t\t (rect1.x + rect1.width < rect2.x) ||\n\t\t\t\t\t (rect2.x + rect2.width < rect1.x));\n};\n\nintersect.circleAndRect = function(circle, rect) {\n\tif (intersect.pointAndRect(circle, rect)) {\n\t\treturn true;\n\t}\n\treturn (intersect.lineAndCircle(rect.getSide(1), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(2), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(3), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(4), circle));\n};\n\nintersect.rectAndCircle = function(rect, circle) {\n\treturn intersect.circleAndRect(circle, rect);\n};\n\nintersect.lineAndCircle = function (line, circle) {\n\tvar vec = intersect.pointToLine(circle, line);\n\treturn vec.getMagnitude() < circle.radius;\n};\n\nintersect.circleAndLine = function (circle, line) {\n\treturn intersect.lineAndCircle(line, circle);\n};\n\n// returns line from pt to nearest pt on line\nintersect.pointToLine = intersect.ptToLine = function (pt, line) {\n\tvar dx = (line.end.x - line.start.x),\n\t\t\tdy = (line.end.y - line.start.y),\n\t\t\tu = ((pt.x - line.start.x) * dx\t// TODO can we abstract this from 2D to 2D/3D?\n\t\t\t\t\t + (pt.y - line.start.y) * dy) / (dx * dx + dy * dy);\n\n\tvar i;\n\tif (u < 0) {\n\t\ti = new Point(line.start);\n\t} else if (u > 1) {\n\t\ti = new Point(line.end);\n\t} else {\n\t\ti = new Point(line.start.x + u * dx, line.start.y + u * dy);\n\t}\n\treturn new Line(i, pt);\n};\n\n// returns rectangle of intersection\nintersect.rectAndRect = function (rect1, rect2) {\n\tjsio('import .Rect');\n\treturn (intersect.rectAndRect = function(rect1, rect2) {\n\t\tif (rect1 === true) { return new Rect(rect2); }\n\t\tif (rect2 === true) { return new Rect(rect2); }\n\n\t\tif (intersect.isRectAndRect(rect1, rect2)) {\n\t\t\tvar x1 = Math.max(rect1.x, rect2.x),\n\t\t\t\t\ty1 = Math.max(rect1.y, rect2.y),\n\t\t\t\t\tx2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width),\n\t\t\t\t\ty2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);\n\t\t\treturn new Rect(x1, y1, x2 - x1, y2 - y1);\n\t\t}\n\t\treturn null;\n\t})(rect1, rect2);\n}\n","pre":true},"math/geom/Vec2D.js":{"path":"math/geom/Vec2D.js","friendlyPath":"jsio.math.geom.Vec2D","directory":"math/geom/","filename":"Vec2D.js","src":"/**\n * Model a vector in two-dimensional space.\n * Pass an \"angle\" option in radians to this function to initialize an angle.\n */\n\nvar Vec2D = exports = Class(function() {\n\tthis.init = function(opts) {\n\t\tif ('angle' in opts) {\n\t\t\tthis.x = opts.magnitude * Math.cos(opts.angle);\n\t\t\tthis.y = opts.magnitude * Math.sin(opts.angle);\n\t\t} else {\n\t\t\tthis.x = opts.x;\n\t\t\tthis.y = opts.y;\n\t\t}\n\t}\n\n\t/**\n\t * Add a force vector to this vector.\n\t */\n\t\n\tthis.addForce = function(f) {\n\t\tthis.x += f.x; this.y += f.y;\n\t};\n\n\t/**\n\t * Return the angle of this vector.\n\t */\n\n\tthis.getAngle = function() {\n\t\treturn Math.atan2(this.y, this.x);\n\t};\n\n\t/**\n\t * Return the magnitude of this vector.\n\t */\n\n\tthis.getMagnitude = function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t}\n\n\t/**\n\t * Get a unit vector corresponding to this vector's angle.\n\t */\n\n\tthis.getUnitVector = function() {\n\t\treturn new Vec2D({\n\t\t\tmagnitude:1,\n\t\t\tangle: this.getAngle()\n\t\t});\n\t};\n\n\t/**\n\t * Return the dot product of this and another vector.\n\t */\n\t\t\t\t\t\t\n\tthis.dot = function(vec) {\n\t\treturn (this.x * vec.x) + (this.y * vec.y);\n\t};\n\n\t/**\n\t * Returns a vector that is the addition of this and another vector.\n\t */\n\n\tthis.add = function(vec) {\n\t\treturn new Vec2D({x:this.x + vec.x, y:this.y+vec.y});\n\t};\n\n\t/**\n\t * Returns a vector that is this vector subtracted by another.\n\t */\n\t\n\tthis.minus = function(vec) {\n\t\treturn new Vec2D({x: this.x-vec.x, y: this.y-vec.y});\n\t};\n\n\t/**\n\t * Returns a vector that would negate this vector when added.\n\t */\n\t\n\tthis.negate = function() {\n\t\treturn new Vec2D({x: -this.x, y: -this.y});\n\t};\n\n\t/**\n\t * Returns a vector that multiplies this vector's magnitude by a scalar.\n\t */\n\t\n\tthis.multiply = function(scalar) {\n\t\treturn new Vec2D({\n\t\t\tangle: this.getAngle(),\n\t\t\tmagnitude: this.getMagnitude()*scalar\n\t\t});\n\t};\n\n});\n\n","pre":true},"math/geom/angle.js":{"path":"math/geom/angle.js","friendlyPath":"jsio.math.geom.angle","directory":"math/geom/","filename":"angle.js","src":"var PI = Math.PI;\nvar TAU = Math.PI * 2;\n\nexports.average = function (a, b, weight) {\n\tif (weight === undefined) { weight = 0.5; }\n\tvar r1 = exports.range(a, b);\n\tvar avg = r1 < PI\n\t\t? a + r1 * (1 - weight)\n\t\t: b + (2 * PI - r1) * weight;\n\n\treturn avg > PI ? avg - 2 * PI : avg < -PI ? avg + 2 * PI : avg;\n};\n\n// between -PI and PI\nexports.normalize = function (a) {\n\treturn a - (((a + Math.PI) / TAU) | 0) * TAU;\n};\n\nexports.add = function (a, b) {\n\tvar sum = a + b;\n\treturn sum > PI ? sum - TAU : sum < -PI ? sum + TAU : sum;\n};\n\n// smaller of two angles a - b, b - a\nexports.difference = function (a, b) {\n\tvar diff = exports.range(a, b);\n\treturn diff > PI ? diff - TAU : diff;\n};\n\n// angular range from a to b, returns float between [0, 2PI]\nexports.range = function (a, b) {\n\tvar r = b - a;\n\treturn r < 0 ? r + TAU : r;\n};","pre":true},"math/array.js":{"path":"math/array.js","friendlyPath":"jsio.math.array","directory":"math/","filename":"array.js","src":"jsio('import math.util as util');\n\n/**\n * @package math.array;\n *\n * Functions to manipulate one or more arrays in tandem.\n */\n\n/**\n * Returns the weighted average\n */ \n\nexports.weightedAverage = function (a, w, n) {\n\tn = n || a.length;\n\tvar s = 0;\n\tfor (var i = n - 1; i >= 0; --i) {\n\t\ts += a[i] * w;\n\t}\n\treturn s / n;\n}\n\n/**\n * Subtract two arrays, (a - b)\n */\n\nexports.subtract = function (a, b) {\n\tvar length = a.length,\n\t\t\tdiff = new Array(length);\n\tfor (var i = 0; i < length; ++i) {\n\t\tdiff[i] = a[i] - b[i];\n\t}\n\treturn diff;\n};\n\n/**\n * Average an array.\n */\n\nexports.average = function (a, n) {\n\tn = n || a.length;\n\tvar s = 0;\n\tfor (var i = n - 1; i >= 0; --i) {\n\t\ts += a[i];\n\t}\n\treturn s / n;\n}\n\n/**\n * Return the standard deviation of an array.\n */\n\nexports.stddev = function (a, n) {\n\tvar avg = exports.average(a, n);\n\tn = n || a.length;\n\tvar s = 0;\n\tfor (var i = n - 1; i >= 0; --i) {\n\t\tvar diff = (a[i] - avg);\n\t\ts += diff * diff;\n\t}\n\treturn Math.sqrt(s / (n - 1));\n}\n\n/**\n * Shuffle an array. Takes an optional random seed.\n */\n\nexports.shuffle = function(a, randGen) {\n\tvar len = a.length;\n\tfor (var i = 0; i < len; ++i) {\n\t\tvar j = util.random(i, len, randGen),\n\t\t\ttemp = a[j];\n\t\ta[j] = a[i];\n\t\ta[i] = temp;\n\t}\n\treturn a;\n}\n\n/**\n * Rotate an array's elements left.\n */\n\nexports.rotate = function(a, count) {\n\tvar len = a.length,\n\t\tb = new Array(len),\n\t\tj = count % len;\n\t\n\tif (j < 0) {\n\t\tj = j % len;\n\t\tif (j) { j += len; }\n\t}\n\t\n\tfor (var i = 0; i < len; ++i) {\n\t\tb[i] = a[j];\n\t\tj = (j + 1) % len;\n\t}\n\t\n\treturn b;\n}\n","pre":true},"math/random.js":{"path":"math/random.js","friendlyPath":"jsio.math.random","directory":"math/","filename":"random.js","src":"/*\n * GCRand\n * \tA new Marsaglia's KISS -style PRNG\n * \t- Period ~2^^96, enough to generate 2^^32 random numbers with a 32-bit seed\n * \t- Passes all BigCrush tests\n * \t- Performance is good\n * \t\tIt's 10% faster than a JavaScript Mersenne Twister I found for\n * \t\tlong output and much faster for short output\n * \t- No multiply/divide/modulus instructions required\n *  - Completely avoids floating-point operations, so it should be fairly fast\n *    and portable across all platforms\n *  - For additional performance in inner loops use the cached version below\n *\n * Technical contact: Christopher A. Taylor <chris@gameclosure.com>\n */\n\nvar RNG = Class(function() {\n\n\t// Initialize the random number generator from an optional seed (opts.seed)\n\tthis.init = function(seed) {\n\t\t// If seed was not specified,\n\t\tif (typeof(seed) != 'number') {\n\t\t\tvar mrx = Math.random() * 4294967296.0;\n\t\t\tvar mry = new Date().getTime();\n\t\t\tseed = mrx ^ mry;\n\t\t}\n\n\t\t// XOR Shift\n\t\tif (seed !== 234567891) {\n\t\t\tthis.x = seed ^ 234567891;\n\t\t}\n\n\t\t// Weyl Generator\n\t\tthis.y = seed ^ 123456789;\n\n\t\t// Add-With-Carry\n\t\tthis.z = 345678912 >>> 0;\n\t\tthis.w = 456789123 >>> 0;\n\t\tthis.c = 0;\n\t}\n\n\t// Iterate state object returning the next 32-bit unsigned random value\n\tthis.uint32 = function() {\n\t\t// XOR Shift\n\t\tvar x = this.x;\n\t\tx ^= x << 5;\n\t\tx ^= x >>> 7;\n\t\tx ^= x << 22;\n\t\tthis.x = x;\n\n\t\t// Weyl Generator\n\t\tvar y = this.y;\n\t\ty += 1411392427;\n\t\tthis.y = y >>> 0;\n\n\t\t// Add-With-Carry\n\t\tvar w = this.w;\n\t\tvar t = (this.z + w + this.c) >>> 0;\n\t\tthis.z = w;\n\t\tthis.c = t >>> 31;\n\t\tw = t & 2147483647;\n\t\tthis.w = w;\n\n\t\treturn (x + y + w) >>> 0;\n\t}\n\n\t// Produce a 31-bit integer number in the range [0 ... 0x7fffffff] inclusive\n\tthis.uint31 = function() {\n\t\treturn this.uint32() >>> 1;\n\t}\n\n\t// Produce a 32-bit floating-point number in the range [0.0 ... 1.0] inclusive\n\tthis.random = function() {\n\t\treturn this.uint32() * (1.0/4294967296.0);\n\t}\n\n\t// Produce a floating-point number in the range [a ... b] inclusive\n\tthis.rangeReal = function(a, b) {\n\t\treturn ( this.uint32() * (1.0/4294967296.0) ) * (b - a) + a;\n\t}\n\n\t// Produce an integer number in the range [a ... b] inclusive\n\tthis.rangeInteger = function(a, b) {\n\t\treturn ( ( this.uint32() * (1.0/4294967296.0) ) * (b - a) + a + 0.5 ) >>> 0;\n\t}\n\n\t// Produce a 53-bit floating-point number according to a normal distribution\n\t// with mean = 0 and variance = 1, using the Box-Mulder (trigonometric) method\n\tthis.normal = function() {\n\t\tvar u1 = 0,\n\t\t\tu2 = 0;\n\n\t\twhile (u1 * u2 == 0.0) {\n\t\t\tu1 = this.random();\n\t\t\tu2 = this.random();\n\t\t}\n\n\t\treturn Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);\n\t}\n\n\t// Produce a 53-bit floating-point number according to a Gaussian distribution\n\t// with your specified mean and variance\n\tthis.gaussian = function(mean, stddev) {\n\t\treturn stddev * this.normal() + mean;\n\t}\n\n\t// Same as kiss96_gauss except it also clamps to a specified range\n\tthis.gaussianClamp = function(mean, stddev, clamp_lo, clamp_hi) {\n\t\tvar x = stddev * this.normal() + mean;\n\n\t\t// Clamp to range\n\t\tif (x < clamp_lo) {\n\t\t\tx = clamp_lo;\n\t\t} else {\n\t\t\tif (x > clamp_hi) {\n\t\t\t\tx = clamp_hi;\n\t\t\t}\n\t\t}\n\n\t\treturn x;\n\t}\n});\n\n/**\n * Module API.\n */\n\nexports = new RNG(Date.now());\nexports.RNG = RNG;\n","pre":true},"math/util.js":{"path":"math/util.js","friendlyPath":"jsio.math.util","directory":"math/","filename":"util.js","src":"jsio('import lib.Enum as Enum');\n\n/**\n * @package math.util;\n */\n\n/**\n * Interpolate between values a and b at the point x in the interval.\n */\n\nexports.interpolate = function(a, b, x) { return a * (1 - x) + b * x; }\n\n/**\n * Return a random integer between a and b. Optionally, a random seed can be\n * given.\n */\n\nexports.random = function(a, b, rand) { return a + ((rand || Math.random)() * (b - a) | 0); }\n\n/**\n * Return a random integer between a and b, inclusive. Optionally, a random seed\n * can be given.\n */\n\nexports.randomInclusive = function(a, b, rand) { return exports.random(a, b+1, rand); }\n\n/**\n * Return a value where min <= num <= max.\n */\n\nexports.clip = function(num, min, max) { return Math.max(Math.min(num, max), min); }\n\n/**\n * Return the sign of a number.\n */\n\nexports.sign = function (num) {\n\treturn num && num / Math.abs(num);\n};\n\n/**\n * An actual modulo operator.\n */\nexports.mod = function(m, n) {\n    return ((m % n) + n) % n;\n};\n\n/**\n * Rounding a value with the given precision, given the provided rounding method.\n * NOTE: Number.toFixed returns a string, I'm not sure this is desired.\n \n ### util.round (n [, precision, method])\n 1. `n {number} value`\n 2. `precision {number} = null` ---Optional.\n 3. `method {number}` ---Optional enum from `util.round`.\n 4. Return `{number}`\n \n Round a number to a given precision, or by a given method.\n \n The precision method can be one of the following:\n \n   * `util.round.ROUND_HALF_UP` ---Round 0.5 to 1.\n   * `util.round.ROUND_HALF_AWAY_FROM_ZERO`\n   * `util.round.ROUND_HALF_TO_EVEN` ---Round to the nearest even number.\n   * `util.round.ROUND_HALF_TO_ODD` ---Round to the nearest odd number.\n   * `util.round.ROUND_HALF_STOCHASTIC` ---Round at random.\n   * `util.round.ROUND_HALF_ALTERNATE` ---Alternate rounding up/down with sequential uses of this function.\n *\n */\n\nvar round = exports.round = function(a, precision, method) {\n\tif (!method || method == round.ROUND_HALF_AWAY_FROM_ZERO) {\n\t\treturn a.toFixed(precision);\n\t}\n\t\n\tif(!precision) {\n\t\tif (method == round.ROUND_HALF_UP) { Math.round(a); }\n\t\n\t\tvar i = a | 0,\n\t\t\t\tfrac = a - i,\n\t\t\t\thalf = frac == 0.5 || frac == -0.5;\n\t\tif (!half) { return Math.round(a); }\n\t\t\n\t\tvar sign = a < 0 ? -1 : 1;\n\t\tswitch(method) {\n\t\t\tcase round.ROUND_HALF_TO_EVEN:\n\t\t\t\treturn i % 2 ? i + sign : i;\n\t\t\tcase round.ROUND_HALF_TO_ODD:\n\t\t\t\treturn i % 2 ? i : i + sign;\n\t\t\tcase round.ROUND_HALF_STOCHASTIC:\n\t\t\t\treturn Math.random() < 0.5 ? i + sign : i;\n\t\t\tcase round.ROUND_HALF_ALTERNATE:\n\t\t\t\treturn (round.alt = !round.alt) ? i + sign : i;\n\t\t}\n\t}\n\t\n\tvar i = a | 0,\n\t\t\tfrac = a - i,\n\t\t\tp = Math.pow(10, precision);\n\treturn (i + round(frac * p, 0, method) / p).toFixed(precision);\n}\n\n/**\n * Available rounding possibilities.\n */\n\nEnum.call(round, 'ROUND_HALF_UP', 'ROUND_HALF_AWAY_FROM_ZERO', 'ROUND_HALF_TO_EVEN', 'ROUND_HALF_TO_ODD', 'ROUND_HALF_STOCHASTIC', 'ROUND_HALF_ALTERNATE');\n\n/**\n * Alternating flag for rounding strategy ROUND_HALF_ALTERNATE.\n */\n\nround.alt = true;\n","pre":true},"math2D/Circle.js":{"path":"math2D/Circle.js","friendlyPath":"jsio.math2D.Circle","directory":"math2D/","filename":"Circle.js","src":"/*\n* @shim\n*/\njsio('import math.geom.Circle');\nexports = math.geom.Circle;\nlogger.log(\"Warning: math2D.Circle is deprecated\");\n","pre":true},"math2D/Line.js":{"path":"math2D/Line.js","friendlyPath":"jsio.math2D.Line","directory":"math2D/","filename":"Line.js","src":"/*\n* @shim\n*/\njsio('import math.geom.Line');\nexports = math.geom.Line;\nlogger.log(\"Warning: math2D.Line is deprecated\");\n","pre":true},"math2D/Point.js":{"path":"math2D/Point.js","friendlyPath":"jsio.math2D.Point","directory":"math2D/","filename":"Point.js","src":"/*\n* @shim\n*/\njsio('import math.geom.Point');\nexports = math.geom.Point;\nlogger.log(\"Warning: math2D.Point is deprecated\");\n","pre":true},"math2D/Polygon.js":{"path":"math2D/Polygon.js","friendlyPath":"jsio.math2D.Polygon","directory":"math2D/","filename":"Polygon.js","src":"/*\n* @shim\n*/\njsio('import math.geom.Polygon');\nexports = math.geom.Polygon;\nlogger.log(\"Warning: math2D.Polygon is deprecated\");\n","pre":true},"math2D/Rect.js":{"path":"math2D/Rect.js","friendlyPath":"jsio.math2D.Rect","directory":"math2D/","filename":"Rect.js","src":"/*\n* @shim\n*/\njsio('import math.geom.Rect');\nexports = math.geom.Rect;\nlogger.log(\"Warning: math2D.Rect is deprecated\");\n","pre":true},"math2D/Vec2D.js":{"path":"math2D/Vec2D.js","friendlyPath":"jsio.math2D.Vec2D","directory":"math2D/","filename":"Vec2D.js","src":"/*\n* @shim\n*/\njsio('import math.geom.Vec2D');\nexports = math.geom.Vec2D;\nlogger.log(\"Warning: math2D.Vec2D is deprecated\");\n","pre":true},"math2D/angle.js":{"path":"math2D/angle.js","friendlyPath":"jsio.math2D.angle","directory":"math2D/","filename":"angle.js","src":"/*\n* @shim\n*/\njsio('import math.geom.angle');\nexports = math.geom.angle;\nlogger.log(\"Warning: math2D.angle is deprecated\");\n","pre":true},"math2D/intersect.js":{"path":"math2D/intersect.js","friendlyPath":"jsio.math2D.intersect","directory":"math2D/","filename":"intersect.js","src":"/*\n* @shim\n*/\njsio('import math.geom.intersect');\nexports = math.geom.intersect;\nlogger.log(\"Warning: math2D.intersect is deprecated\");\n","pre":true},"math2D/morphology.js":{"path":"math2D/morphology.js","friendlyPath":"jsio.math2D.morphology","directory":"math2D/","filename":"morphology.js","src":"/*\n* @shim\n*/\nlogger.log(\"Warning: math2D.morphology is deprecated\");\n","pre":true},"net/csp/client.js":{"path":"net/csp/client.js","friendlyPath":"jsio.net.csp.client","directory":"net/csp/","filename":"client.js","src":"jsio('import std.base64 as base64');\njsio('import std.utf8 as utf8');\njsio('import std.uri as uri'); \njsio('import net.errors as errors');\njsio('import .transports');\njsio('import lib.Enum as Enum');\n\nvar READYSTATE = exports.READYSTATE = Enum({\n\tINITIAL: 0,\n\tCONNECTING: 1,\n\tCONNECTED: 2,\n\tDISCONNECTING: 3,\n\tDISCONNECTED:  4\n});\n\n\nexports.CometSession = Class(function(supr) {\n\tvar id = 0;\n\tvar kDefaultBackoff = 50;\n\tvar kDefaultTimeoutInterval = 45000;\n\tvar kDefaultHandshakeTimeout = 10000;\n\tthis.init = function() {\n\t\tthis._id = ++id;\n\t\tthis._url = null;\n\t\tthis.readyState = READYSTATE.INITIAL;\n\t\tthis._sessionKey = null;\n\t\tthis._transport = null;\n\t\tthis._options = null;\n\t\t\n\t\tthis._utf8ReadBuffer = \"\";\n\t\tthis._writeBuffer = \"\";\n\t\t\n\t\tthis._packetsInFlight = null;\n\t\tthis._lastEventId = null;\n\t\tthis._lastSentId = null;\n\t\t\n\t\tthis._handshakeLater = null;\n\t\tthis._handshakeBackoff = kDefaultBackoff;\n\t\tthis._handshakeRetryTimer = null;\n\t\tthis._handshakeTimeoutTimer = null;\n\n\t\tthis._timeoutTimer = null;\n\n\t\t\n\t\tthis._writeBackoff = kDefaultBackoff;\n\t\tthis._cometBackoff = kDefaultBackoff;\n\t\t\n\t\tthis._nullInBuffer = false;\n\t\tthis._nullInFlight= false;\n\t\tthis._nullSent = false;\n\t\tthis._nullReceived = false;\n\t}\n\t\n\t\n\tthis.setEncoding = function(encoding) {\n\t\tif (encoding == this._options.encoding) { \n\t\t\treturn; \n\t\t}\n\t\tif (encoding != 'utf8' && encoding != 'plain') {\n\t\t\tthrow new errors.InvalidEncodingError();\n\t\t}\n\t\tif (encoding == 'plain' && this._buffer) {\n\t\t\tvar buffer = this._utf8ReadBuffer;\n\t\t\tthis._utf8ReadBuffer = \"\";\n\t\t\tthis._doOnRead(buffer);\n\t\t}\n\t\tthis._options.encoding = encoding;\n\t}\n\n\n\tthis.connect = function(url, options) {\n\t\tthis._url = url.replace(/\\/$/,'');\n\t\tthis._options = options || {};\n\t\t\n\t\tthis._options.encoding = this._options.encoding || 'utf8';\n\t\tthis.setEncoding(this._options.encoding); // enforce encoding constraints\n\t\t\n\t\tthis._options.connectTimeout = this._options.connectTimeout || kDefaultHandshakeTimeout;\n\t\t\n\t\tvar transportClass = transports.chooseTransport(url, this._options);\n\t\tthis._transport = new transportClass();\n\t\t\n\t\tthis._transport.handshakeFailure = bind(this, this._handshakeFailure);\n\t\tthis._transport.handshakeSuccess = bind(this, this._handshakeSuccess);\n\t\t\n\t\tthis._transport.cometFailure = bind(this, this._cometFailure);\n\t\tthis._transport.cometSuccess = bind(this, this._cometSuccess);\n\t\t\n\t\tthis._transport.sendFailure = bind(this, this._writeFailure);\n\t\tthis._transport.sendSuccess = bind(this, this._writeSuccess);\n\t\tthis.readyState = READYSTATE.CONNECTING;\n\t\tthis._transport.handshake(this._url, this._options);\n\t\t\n\t\tthis._handshakeTimeoutTimer = setTimeout(bind(this, this._handshakeTimeout), \n\t\t\tthis._options.connectTimeout);\n\t}\n\n\tthis.write = function(data, encoding) {\n\t\tif (this.readyState != READYSTATE.CONNECTED) {\n\t\t\tthrow new errors.ReadyStateError();\n\t\t}\n\t\tencoding = encoding || this._options.encoding || 'utf8';\n\t\tif (encoding == 'utf8') {\n\t\t\tdata = utf8.encode(data);\n\t\t}\n\t\tthis._writeBuffer += data;\n\t\tthis._doWrite();\n\t}\n\t\n\t// Close due to protocol error\n\tthis._protocolError = function(msg) {\n\t\tlogger.debug('_protocolError', msg);\n\t\t// Immediately fire the onclose\n\t\t// send a null packet to the server\n\t\t// don't wait for a null packet back.\n\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\tthis._doWrite(true);\n\t\tthis._doOnDisconnect(new errors.ServerProtocolError(msg));\n\t}\n\t\n\tthis._receivedNullPacket = function() {\n\t\tlogger.debug('_receivedNullPacket');\n\t\t// send a null packet back to the server\n\t\tthis._receivedNull = true;\n\t\t\n\t\t// send our own null packet back. (maybe)\n\t\tif (!(this._nullInFlight || this._nullInBuffer || this._nullSent)) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTING;\n\t\t\tthis._doWrite(true);\n\t\t}\n\t\telse {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t\t\n\t\t// fire an onclose\n\t\tthis._doOnDisconnect(new errors.ConnectionClosedCleanly());\n\n\t}\n\t\n\tthis._sentNullPacket = function() {\n\t\tlogger.debug('_sentNullPacket');\n\t\tthis._nullSent = true;\n\t\tif (this._nullSent && this._nullReceived) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t}\n\t\n\t\n\t// User Calls close\n\tthis.close = function(err) {\n\t\tlogger.debug('close called', err, 'readyState', this.readyState);\n\n\t\t// \n\t\tswitch(this.readyState) {\n\t\t\tcase READYSTATE.CONNECTING:\n\t\t\t\tclearTimeout(this._handshakeRetryTimer);\n\t\t\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t\t\tthis._doOnDisconnect(err);\n\t\t\t\tbreak;\n\t\t\tcase READYSTATE.CONNECTED:\n\t\t\t\tthis.readyState = READYSTATE.DISCONNECTING;\n\t\t\t\tthis._doWrite(true);\n\t\t\t\tclearTimeout(this._timeoutTimer);\n\t\t\t\tbreak;\n\t\t\tcase READYSTATE.DISCONNECTED:\n\t\t\t\tthrow new errors.ReadyStateError(\"Session is already disconnected\");\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\tthis._opened = false; // what is this used for???\n\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t\n\t\tthis._doOnDisconnect(err);\n\t\tthis._sessionKey = null;\n\t}\n\t\n\tthis._handshakeTimeout = function() {\n\t\tlogger.debug('handshake timeout');\n\t\tthis._handshakeTimeoutTimer = null;\n\t\tclearTimeout(this._handshakeRetryTimer);\n\t\tif (this.readyState == READYSTATE.CONNECTING) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t\t\n\t\tthis._doOnDisconnect(new errors.ServerUnreachable());\n\t}\n\t\n\tthis._handshakeSuccess = function(data) {\n\t\tlogger.debug('handshake success', data);\n\t\tif (this.readyState != READYSTATE.CONNECTING) { \n\t\t\tlogger.debug('received handshake success in invalid readyState:', this.readyState);\n\t\t\treturn; \n\t\t}\n\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\tthis._handshakeTimeoutTimer = null;\n\t\tthis._sessionKey = data.response.session;\n\t\tthis._opened = true;\n\t\tthis.readyState = READYSTATE.CONNECTED;\n\t\tthis._doOnConnect();\n\t\tthis._doConnectComet();\n\t}\n\t\n\tthis._handshakeFailure = function(data) {\n\t\tlogger.debug('handshake failure', data);\n\t\tif (this.readyState != READYSTATE.CONNECTING) { return; }\n\t\tif (data.status == 404) {\n\t\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\t\treturn this._doOnDisconnect(new errors.ServerUnreachable());\n\t\t}\n\t\t\n\t\tlogger.debug('trying again in ', this._handshakeBackoff);\n\t\tthis._handshakeRetryTimer = setTimeout(bind(this, function() {\n\t\t\tthis._handshakeRetryTimer = null;\n\t\t\tthis._transport.handshake(this._url, this._options);\n\t\t}), this._handshakeBackoff);\n\t\t\n\t\tthis._handshakeBackoff *= 2;\n\t}\n\t\n\tthis._writeSuccess = function() {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._nullInFlight) {\n\t\t\treturn this._sentNullPacket();\n\t\t}\n\t\tthis._resetTimeoutTimer();\n\t\tthis.writeBackoff = kDefaultBackoff;\n\t\tthis._packetsInFlight = null;\n\t\tif (this._writeBuffer || this._nullInBuffer) {\n\t\t\tthis._doWrite(this._nullInBuffer);\n\t\t}\n\t}\n\t\n\tthis._writeFailure = function() {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.READYSTATE != READYSTATE.DISCONNECTING) { return; }\n\t\tthis._writeTimer = setTimeout(bind(this, function() {\n\t\t\tthis._writeTimer = null;\n\t\t\tthis.__doWrite(this._nullInBuffer);\n\t\t}), this._writeBackoff);\n\t\tthis._writeBackoff *= 2;\n\t}\t\n\n\tthis._doWrite = function(sendNull) {\n\t\tif (this._packetsInFlight) {\n\t\t\tif (sendNull) {\n\t\t\t\tthis._nullInBuffer = true;\n\t\t\t\treturn; \n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.__doWrite(sendNull);\n\t}\n\t\n\tthis.__doWrite = function(sendNull) {\n\t\tlogger.debug('_writeBuffer:', this._writeBuffer);\n\t\tif (!this._packetsInFlight && this._writeBuffer) {\n\t\t\tthis._packetsInFlight = [this._transport.encodePacket(++this._lastSentId, this._writeBuffer, this._options)];\n\t\t\tthis._writeBuffer = \"\";\n\t\t}\n\t\tif (sendNull && !this._writeBuffer) {\n\t\t\tif (!this._packetsInFlight) {\n\t\t\t\tthis._packetsInFlight = [];\n\t\t\t}\n\t\t\tthis._packetsInFlight.push([++this._lastSentId, 0, null]);\n\t\t\tthis._nullInFlight = true;\n\t\t}\n\t\tif (!this._packetsInFlight) {\n\t\t\tlogger.debug(\"no packets to send\");\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug('sending packets:', JSON.stringify(this._packetsInFlight));\n\t\tthis._transport.send(this._url, this._sessionKey, this._lastEventId || 0, JSON.stringify(this._packetsInFlight), this._options);\n\t}\n\t\n\tthis._doConnectComet = function() {\n\t\tlogger.debug('_doConnectComet');\n//\t\treturn;\n\t\tthis._transport.comet(this._url, this._sessionKey, this._lastEventId || 0, this._options);\n\t}\n\n\tthis._cometFailure = function(data) {\n\t\tif (this.readyState != READYSTATE.CONNECTED) { return; }\n\t\tif (data.status == 404 && data.response == 'Session not found') {\n\t\t\treturn this.close(new errors.ExpiredSession(data));\n\t\t}\n\t\t\n\t\tthis._cometTimer = setTimeout(bind(this, '_doConnectComet'), this._cometBackoff);\n\t\tthis._cometBackoff *= 2;\n\t}\n\t\n\tthis._cometSuccess = function(data) {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) { return; }\n\t\tlogger.debug('comet Success:', data);\n\t\tthis._cometBackoff = kDefaultBackoff;\n\t\tthis._resetTimeoutTimer();\n\t\t\n\t\tvar response = data.response;\n\t\tfor (var i = 0, packet; (packet = response[i]) || i < response.length; i++) {\n\t\t\tlogger.debug('process packet:', packet);\n\t\t\tif (packet === null) {\n\t\t\t\treturn this.close(new errors.ServerProtocolError(data));\n\t\t\t}\n\t\t\tlogger.debug('process packet', packet);\n\t\t\tvar ackId = packet[0];\n\t\t\tvar encoding = packet[1];\n\t\t\tvar data = packet[2];\n\t\t\tif (typeof(this._lastEventId) == 'number' && ackId <= this._lastEventId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof(this._lastEventId) == 'number' && ackId != this._lastEventId+1) {\n\t\t\t\treturn this._protocolError(\"Ack id too high\");\n\t\t\t}\n\t\t\tthis._lastEventId = ackId;\n\t\t\tif (data == null) {\n\t\t\t\treturn this._receivedNullPacket();\n\t\t\t}\n\t\t\tif (encoding == 1) { // base64 encoding\n\t\t\t\ttry {\n\t\t\t\t\tlogger.debug('before base64 decode:', data);\n\t\t\t\t\tdata = base64.decode(data);\n\t\t\t\t\tlogger.debug('after base64 decode:', data);\n\t\t\t\t} catch(e) {\n\t\t\t\t\treturn this._protocolError(\"Unable to decode base64 payload\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._options.encoding == 'utf8') {\n\t\t\t\t// TODO: need an incremental utf8 decoder for this stuff.\n\t\t\t\tthis._utf8ReadBuffer += data;\n\t\t\t\tlogger.debug('before utf8 decode, _utf8ReadBuffer:', this._utf8ReadBuffer);\n\t\t\t\tvar result = utf8.decode(this._utf8ReadBuffer);\n\t\t\t\tdata = result[0];\n\t\t\t\tthis._utf8ReadBuffer = this._utf8ReadBuffer.slice(result[1]);\n\t\t\t\tlogger.debug('after utf8 decode, _utf8ReadBuffer:', this._utf8ReadBuffer, 'data:', data );\n\t\t\t}\n\t\t\tlogger.debug('dispatching data:', data);\n\n\t\t\t// TODO: possibly catch this error in production? but not in dev\n\t\t\tthis._doOnRead(data);\n\t\t}\n\t\t\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) { return; }\n\t\t\n\t\t// reconnect comet last, after we process all of the packet ids\n\t\tthis._doConnectComet();\n\t\t\n\t}\n\n\tthis._doOnRead = function(data) {\n\t\tif (typeof(this.onread) == 'function') {\n\t\t\tlogger.debug('call onread function', data);\n\t\t\tthis.onread(data);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping onread callback (function missing)');\n\t\t}\n\t}\n\t\n\tthis._doOnDisconnect = function(err) {\n\t\tif (typeof(this.ondisconnect) == 'function') {\n\t\t\tlogger.debug('call ondisconnect function', err);\n\t\t\tthis.ondisconnect(err);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping ondisconnect callback (function missing)');\n\t\t}\n\t}\n\t\n\tthis._doOnConnect = function() {\n\t\tif (typeof(this.onconnect) == 'function') {\n\t\t\tlogger.debug('call onconnect function');\n\t\t\ttry {\n\t\t\t\tthis.onconnect();\n\t\t\t} catch(e) {\n\t\t\t\tlogger.debug('onconnect caused errror', e);\n\t\t\t\t// throw error later\n\t\t\t\tsetTimeout(function() { throw e }, 0);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping onconnect callback (function missing)');\n\t\t}\n\t}\n\n\tthis._resetTimeoutTimer = function() {\n\t\tclearTimeout(this._timeoutTimer);\n\t\tthis._timeoutTimer = setTimeout(bind(this, function() {\n\t\t\tlogger.debug('connection timeout expired');\n\t\t\tthis.close(new errors.ConnectionTimeout())\n\t\t}), this._getTimeoutInterval())\n\t}\n\t\n\tthis._getTimeoutInterval = function() {\n\t\treturn kDefaultTimeoutInterval;\n\t}\n\n});\n","pre":true},"net/csp/transports.js":{"path":"net/csp/transports.js","friendlyPath":".transports","directory":"net/csp/","filename":"transports.js","src":"jsio('import std.uri as uri'); \njsio('import std.base64 as base64');\njsio('from util.browserdetect import BrowserDetect');\n\n;(function() {\n\tvar doc;\n\texports.getDoc = function() {\n\t\tif (doc) { return doc; }\n\t\ttry {\n\t\t\tdoc = window.ActiveXObject && new ActiveXObject('htmlfile');\n\t\t\tif (doc) {\n\t\t\t\tdoc.open().write('<html></html>');\n\t\t\t\tdoc.close();\n\t\t\t\twindow.attachEvent('onunload', function() {\n\t\t\t\t\ttry { doc.body.innerHTML = ''; } catch(e) {}\n\t\t\t\t\tdoc = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} catch(e) {}\n\t\t\n\t\tif (!doc) { doc = document; }\n\t\treturn doc;\n\t};\n\n\texports.XHR = function() {\n\t\tvar win = window,\n\t\t\tdoc = exports.getDoc();\n\t\t//if (doc.parentWindow) { win = doc.parentWindow; }\n\t\t\n\t\treturn new (exports.XHR = win.XMLHttpRequest ? win.XMLHttpRequest\n\t\t\t: function() { return win.ActiveXObject && new win.ActiveXObject('Msxml2.XMLHTTP') || null; });\n\t}\n\t\n\texports.createXHR = function() { return new exports.XHR(); }\n\n})();\n\nfunction isLocalFile(url) { return /^file:\\/\\//.test(url); }\nfunction isWindowDomain(url) { return uri.isSameDomain(url, window.location.href); }\n\nvar xhrSupportsBinary = undefined;\nfunction checkXHRBinarySupport(xhr) {\n\txhrSupportsBinary = !!xhr.sendAsBinary;\n}\n\nfunction canUseXHR(url) {\n\t// always use jsonp for local files\n\tif (isLocalFile(url)) { return false; }\n\t\n\t// try to create an XHR using the same function the XHR transport uses\n\tvar xhr = new exports.XHR();\n\tif (!xhr) { return false; }\n\t\n\tcheckXHRBinarySupport(xhr);\n\t\n\t// if the URL requested is the same domain as the window,\n\t// then we can use same-domain XHRs\n\tif (isWindowDomain(url)) { return true; }\n\t\n\t// if the URL requested is a different domain than the window,\n\t// then we need to check for cross-domain support\n\tif (window.XMLHttpRequest\n\t\t\t&& (xhr.__proto__ == XMLHttpRequest.prototype // WebKit Bug 25205\n\t\t\t\t|| xhr instanceof window.XMLHttpRequest)\n\t\t\t&& xhr.withCredentials !== undefined\n\t\t|| window.XDomainRequest \n\t\t\t&& xhr instanceof window.XDomainRequest) {\n\t\treturn true;\n\t}\n};\n\nvar transports = exports.transports = {};\n\nexports.chooseTransport = function(url, options) {\n\tswitch(options.preferredTransport) {\n\t\tcase 'jsonp':\n\t\t\treturn transports.jsonp;\n\t\tcase 'xhr':\n\t\tdefault:\n\t\t\tif (canUseXHR(url)) { return transports.xhr; };\n\t\t\treturn transports.jsonp;\n\t}\n};\n\n// TODO: would be nice to use these somewhere...\n\nvar PARAMS = {\n\t'xhrstream':   {\"is\": \"1\", \"bs\": \"\\n\"},\n\t'xhrpoll':     {\"du\": \"0\"},\n\t'xhrlongpoll': {},\n\t'sselongpoll': {\"bp\": \"data: \", \"bs\": \"\\r\\n\", \"se\": \"1\"},\n\t'ssestream':   {\"bp\": \"data: \", \"bs\": \"\\r\\n\", \"se\": \"1\", \"is\": \"1\"}\n};\n\nexports.Transport = Class(function(supr) {\n\tthis.handshake = function(url, options) {\n\t\tthrow new Error(\"handshake Not Implemented\"); \n\t};\n\tthis.comet = function(url, sessionKey, lastEventId, options) { \n\t\tthrow new Error(\"comet Not Implemented\"); \n\t};\n\tthis.send = function(url, sessionKey, data, options) { \n\t\tthrow new Error(\"send Not Implemented\");\n\t};\n\tthis.encodePacket = function(packetId, data, options) { \n\t\tthrow new Error(\"encodePacket Not Implemented\"); \n\t};\n\tthis.abort = function() { \n\t\tthrow new Error(\"abort Not Implemented\"); \n\t};\n});\n\nvar baseTransport = Class(exports.Transport, function(supr) {\n\tthis.init = function() {\n\t\tthis._aborted = false;\n\t\tthis._handshakeArgs = {ct:'application/javascript'};\n\t\tthis._handshakeData = '{}'\n\t};\n\t\n\tthis.handshake = function(url, options) {\n\t\tlogger.debug('handshake:', url, options);\n\t\tthis._makeRequest('send', url + '/handshake', \n\t\t\t\t\t\t  this._handshakeArgs,\n\t\t\t\t\t\t  this._handshakeData,\n\t\t\t\t\t\t  this.handshakeSuccess, \n\t\t\t\t\t\t  this.handshakeFailure);\n\t};\n\t\n\tthis.comet = function(url, sessionKey, lastEventId, options) {\n\t\tlogger.debug('comet:', url, sessionKey, lastEventId, options);\n\t\tvar args = {\n\t\t\ts: sessionKey,\n\t\t\ta: lastEventId\n\t\t};\n\t\tthis._makeRequest('comet', url + '/comet', \n\t\t\t\t\t\t  args,\n\t\t\t\t\t\t  null,\n\t\t\t\t\t\t  this.cometSuccess, \n\t\t\t\t\t\t  this.cometFailure);\n\t};\n\t\n\tthis.send = function(url, sessionKey, lastEventId, data, options) {\n\t\t//logger.debug('send:', url, sessionKey, data, options);\n\t\tvar args = {\n\t\t\ts: sessionKey,\n\t\t\ta: lastEventId\n\t\t};\n\t\tthis._makeRequest('send', url + '/send', \n\t\t\t\t\t\t  args,\n\t\t\t\t\t\t  data,\n\t\t\t\t\t\t  this.sendSuccess, \n\t\t\t\t\t\t  this.sendFailure);\n\t};\n});\n\ntransports.xhr = Class(baseTransport, function(supr) {\n\t\n\tthis.init = function() {\n\t\tsupr(this, 'init');\n\t\n\t\tthis._xhr = {\n\t\t\t'send': new exports.XHR(),\n\t\t\t'comet': new exports.XHR()\n\t\t};\n\t};\n\n\tthis.abort = function() {\n\t\tthis._aborted = true;\n\t\tfor(var i in this._xhr) {\n\t\t\tif(this._xhr.hasOwnProperty(i)) {\n\t\t\t\tthis._abortXHR(i);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis._abortXHR = function(type) {\n\t\tlogger.debug('aborting XHR');\n\n\t\tvar xhr = this._xhr[type];\n\t\ttry {\n\t\t\tif('onload' in xhr) {\n\t\t\t\txhr.onload = xhr.onerror = xhr.ontimeout = null;\n\t\t\t} else if('onreadystatechange' in xhr) {\n\t\t\t\txhr.onreadystatechange = null;\n\t\t\t}\n\t\t\tif(xhr.abort) { xhr.abort(); }\n\t\t} catch(e) {\n\t\t\tlogger.debug('error aborting xhr', e);\n\t\t}\n\t\t\n\t\t// do not reuse aborted XHRs\n\t\tthis._xhr[type] = new exports.XHR();\n\t};\n\t\n\tthis.encodePacket = function(packetId, data, options) {\n\t\t// we don't need to base64 encode things unless there's a null character in there\n\t\treturn !xhrSupportsBinary ? [ packetId, 1, base64.encode(data) ] : [ packetId, 0, data ];\n\t};\n\n\tfunction onReadyStateChange(xhr, rType, cb, eb) {\n\t\ttry {\n\t\t\tvar data = {status: xhr.status};\n\t\t} catch(e) { eb({response: 'Could not access status'}); }\n\t\t\n\t\ttry {\n\t\t\tif(xhr.readyState != 4) { return; }\n\t\t\t\n\t\t\tdata.response = eval(xhr.responseText);\n\t\t\tif(data.status != 200) { \n\t\t\t\tlogger.debug('XHR failed with status ', xhr.status);\n\t\t\t\teb(data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlogger.debug('XHR data received');\n\t\t} catch(e) {\n\t\t\tlogger.debug('Error in XHR::onReadyStateChange', e);\n\t\t\teb(data);\n\t\t\tthis._abortXHR(rType);\n\t\t\tlogger.debug('done handling XHR error');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tcb(data);\n\t};\n\n\t/**\n\t * even though we encode the POST body as in application/x-www-form-urlencoded\n\t */\n\tthis._makeRequest = function(rType, url, args, data, cb, eb) {\n\t\tif (this._aborted) { return; }\n\t\tvar xhr = this._xhr[rType];\n\t\txhr.open('POST', url + '?' + uri.buildQuery(args)); // must open XHR first\n\t\txhr.setRequestHeader('Content-Type', 'text/plain'); // avoid preflighting\n\t\tif('onload' in xhr) {\n\t\t\txhr.onload = bind(this, onReadyStateChange, xhr, rType, cb, eb);\n\t\t\txhr.onerror = xhr.ontimeout = eb;\n\t\t} else if('onreadystatechange' in xhr) {\n\t\t\txhr.onreadystatechange = bind(this, onReadyStateChange, xhr, rType, cb, eb);\n\t\t}\n\t\t// NOTE WELL: Firefox (and probably everyone else) likes to encode our nice\n\t\t//\t\t\t\t\t\tbinary strings as utf8. Don't let them! Say no to double utf8\n\t\t//\t\t\t\t\t\tencoding. Once is good, twice isn't better.\n\t\t// if (xhrSupportsBinary) {\n\t\t// \t\txhr.setRequestHeader('x-CSP-SendAsBinary', 'true');\n\t\t// }\n\t\tsetTimeout(function() {\n\t\t\txhr[xhrSupportsBinary ? 'sendAsBinary' : 'send'](data || null)\n\t\t}, 0);\n\t};\n});\n\nvar EMPTY_FUNCTION = function() {},\n\tSLICE = Array.prototype.slice;\n\ntransports.jsonp = Class(baseTransport, function(supr) {\n\tvar doc;\n\t\n\tvar createIframe = function() {\n\t\tvar doc = exports.getDoc();\n\t\tif (!doc.body) { return false; }\n\t\t\n\t\tvar i = doc.createElement(\"iframe\");\n\t\twith(i.style) { display = 'block'; width = height = border = margin = padding = '0'; overflow = visibility = 'hidden'; position = 'absolute'; top = left = '-999px'; }\n\t\ti.cbId = 0;\n\t\tdoc.body.appendChild(i);\n\t\ti.src = 'about:blank';\n\t\treturn i;\n\t};\n\n\tvar cleanupIframe = function(ifr) {\n\t\tvar win = ifr.contentWindow, doc = win.document;\n\t\tlogger.debug('removing script tags');\n\t\t\n\t\tvar scripts = doc.getElementsByTagName('script');\n\t\tfor (var i = scripts.length - 1; i >= 0; --i) {\n\t\t\tdoc.body.removeChild(scripts[i]);\n\t\t}\n\t\t\n\t\tlogger.debug('deleting iframe callbacks');\n\t\twin['cb' + ifr.cbId] = win['eb' + ifr.cbId] = EMPTY_FUNCTION;\n\t};\n\n\tvar removeIframe = function(ifr) {\n\t\tsetTimeout(function() {\n\t\t\tif(ifr && ifr.parentNode) { ifr.parentNode.removeChild(ifr); }\n\t\t}, 60000);\n\t};\n\n\tthis.init = function() {\n\t\tsupr(this, 'init');\n\n\t\tthis._onReady = [];\n\t\tthis._isReady = false;\n\n\t\tthis._createIframes();\n\t};\n\n\tthis._createIframes = function() {\n\t\tthis._ifr = {\n\t\t\tsend: createIframe(),\n\t\t\tcomet: createIframe()\n\t\t};\n\t\t\n\t\tif(this._ifr.send === false) { return setTimeout(bind(this, '_createIframes'), 100); }\n\t\t\n\t\tthis._isReady = true;\n\n\t\tvar readyArgs = this._onReady;\n\t\tthis._onReady = [];\n\t\tfor(var i = 0, args; args = readyArgs[i]; ++i) {\n\t\t\tthis._makeRequest.apply(this, args);\n\t\t}\n\t};\n\n\tthis.encodePacket = function(packetId, data, options) {\n\t\treturn [ packetId, 1, base64.encode(data) ];\n\t};\n\n\tthis.abort = function() {\n\t\tthis._aborted = true;\n\t\tfor(var i in this._ifr) {\n\t\t\tif(this._ifr.hasOwnProperty(i)) {\n\t\t\t\tvar ifr = this._ifr[i];\n\t\t\t\tcleanupIframe(ifr);\n\t\t\t\tremoveIframe(ifr);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis._makeRequest = function(rType, url, args, data, cb, eb) {\n\t\tif(!this._isReady) { return this._onReady.push(arguments); }\n\t\t\n\t\tvar ifr = this._ifr[rType],\n\t\t\tid = ++ifr.cbId,\n\t\t\treq = {\n\t\t\t\ttype: rType,\n\t\t\t\tid: id,\n\t\t\t\tcb: cb,\n\t\t\t\teb: eb,\n\t\t\t\tcbName: 'cb' + id,\n\t\t\t\tebName: 'eb' + id,\n\t\t\t\tcompleted: false\n\t\t\t};\n\t\t\n\t\targs.d = data;\n\t\targs.n = Math.random();\t\n\t\tswitch(rType) {\n\t\t\tcase 'send': args.rs = ';'; args.rp = req.cbName; break;\n\t\t\tcase 'comet': args.bs = ';'; args.bp = req.cbName; break;\n\t\t}\n\t\t\n\t\treq.url = url + '?' + uri.buildQuery(args)\n\t\t\n\t\tsetTimeout(bind(this, '_request', req), 0);\n\t}\n\t\n\tthis._request = function(req) {\n\t\tvar ifr = this._ifr[req.type],\n\t\t\twin = ifr.contentWindow,\n\t\t\tdoc = win.document,\n\t\t\tbody = doc.body;\n                /*added by skysbird for opera support*/\n                if (!body){return setTimeout(bind(this,'_request',req),100); }\n\t\twin[req.ebName] = bind(this, checkForError, req);\n\t\twin[req.cbName] = bind(this, onSuccess, req);\n\t\t\n\t\tif(BrowserDetect.isWebKit) {\n\t\t\t// this will probably cause loading bars in Safari -- might want to rethink?\n\t\t\tdoc.open();\n\t\t\tdoc.write('<scr'+'ipt src=\"'+req.url+'\"></scr'+'ipt><scr'+'ipt>'+ebName+'(false)</scr'+'ipt>');\n\t\t\tdoc.close();\n\t\t} else {\n\t\t\tvar s = doc.createElement('script');\n\t\t\ts.src = req.url;\n\t\t\t\n\t\t\t// IE\n\t\t\tif(s.onreadystatechange === null) { s.onreadystatechange = bind(this, onReadyStateChange, req, s); }\n\t\t\tbody.appendChild(s);\n\t\t\t\n\t\t\tif(!BrowserDetect.isIE) {\n\t\t\t\tvar s = doc.createElement('script');\n\t\t\t\ts.innerHTML = req.ebName+'(false)';\n\t\t\t\tbody.appendChild(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tkillLoadingBar();\n\t};\n\t\n\tfunction onSuccess(req, response) {\n\t\tlogger.debug('successful: ', req.url, response);\n\t\treq.completed = true;\n\t\t\n\t\tlogger.debug('calling the cb');\n\t\treq.cb.call(GLOBAL, {status: 200, response: response});\n\t\tlogger.debug('cb called');\n\t}\n\t\n\t// IE6/7 onReadyStateChange\n\tfunction onReadyStateChange(req, scriptTag) {\n\t\tif (scriptTag && scriptTag.readyState != 'loaded') { return; }\n\t\tscriptTag.onreadystatechange = function() {};\n\t\tcheckForError.call(this, req);\n\t}\n\n\tfunction checkForError(req, response) {\n\t\tcleanupIframe(this._ifr[req.type]);\n\t\t\n\t\tif (!req.completed) {\n\t\t\tvar data = {\n\t\t\t\tstatus: response ? 200 : 404,\n\t\t\t\tresponse: response || 'Unable to load resouce'\n\t\t\t};\n\t\t\t\n\t\t\tlogger.debug('error making request:', req.url, data);\n\t\t\tlogger.debug('calling eb');\n\t\t\treq.eb.call(GLOBAL, data);\n\t\t}\n\t}\n\t\n\tvar killLoadingBar = BrowserDetect.isFirefox || BrowserDetect.isOpera ? function() {\n\t\tvar b = document.body;\n\t\tif (!b) { return; }\n\t\t\n\t\tif (!killLoadingBar.iframe) { killLoadingBar.iframe = document.createElement('iframe'); }\n\t\tb.insertBefore(killLoadingBar.iframe, b.firstChild);\n\t\tb.removeChild(killLoadingBar.iframe);\n\t} : function() {};\n});\n\t\n","pre":true},"net/env/browser/csp.js":{"path":"net/env/browser/csp.js","friendlyPath":"jsio.net.env.browser.csp","directory":"net/env/browser/","filename":"csp.js","src":"jsio('import ...interfaces');\njsio('from ...csp.client import CometSession');\njsio('import ....std.utf8 as utf8');\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector = Class(interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._state = interfaces.STATE.CONNECTING;\n\n\t\tvar conn = new CometSession();\n\t\tconn.onconnect = bind(this, 'cometSessionOnConnect', conn);\n\t\tconn.ondisconnect = bind(this, 'onDisconnect');\n\n\t\tlogger.debug('opening the connection');\n\t\tif (!this._opts.encoding) { this._opts.encoding = 'utf8'; }\n\t\tconn.connect(this._opts.url, this._opts);//{encoding: 'plain'});\n\t}\n\n\tthis.cometSessionOnConnect = function(conn) {\n\t\tlogger.debug('conn has opened');\n\t\tthis.onConnect(new Transport(conn));\n\t}\n});\n\nvar Transport = Class(interfaces.Transport, function() {\n\tthis.init = function(conn) {\n\t\tthis._conn = conn;\n\t}\n\n\tthis.makeConnection = function(protocol) {\n\t\tthis._conn.onread = bind(protocol, 'dataReceived');\n\t}\n\n\tthis.write = function(data) {\n\t\tthis._conn.write(data);\n\t}\n\n\tthis.loseConnection = function(protocol) {\n\t\tthis._conn.close();\n\t}\n});\n","pre":true},"std/utf8.js":{"path":"std/utf8.js","friendlyPath":"....std.utf8","directory":"std/","filename":"utf8.js","src":"/*\nFast incremental JavaScript UTF-8 encoder/decoder, by Jacob Rus.\n\nAPI for decode from Orbited: as far as I know, the first incremental\nJavaScript UTF-8 decoder.\n\nInspired by the observation by Johan Sundström published at:\nhttp://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\nNote that this code throws an error for invalid UTF-8. Because it is so much\nfaster than previous implementations, the recommended way to do lenient\nparsing is to first try this decoder, and then fall back on a slower lenient\ndecoder if necessary for the particular use case.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n//var utf8 = this.utf8 = exports;\n\nexports.UnicodeCodecError = function (message) { \n\tthis.message = message; \n};\n\nvar UnicodeCodecError = exports.UnicodeCodecError;\n\nUnicodeCodecError.prototype.toString = function () {\n\treturn 'UnicodeCodecError' + (this.message ? ': ' + this.message : '');\n};\n\nexports.encode = function (unicode_string) {\n\t// Unicode encoder: Given an arbitrary unicode string, returns a string\n\t// of characters with code points in range 0x00 - 0xFF corresponding to\n\t// the bytes of the utf-8 representation of those characters.\n\ttry {\n\t\treturn unescape(encodeURIComponent(unicode_string));\n\t}\n\tcatch (err) {\n\t\tthrow new UnicodeCodecError('invalid input string');\n\t};\n};\nexports.decode = function (bytes) {\n\t// Unicode decoder: Given a string of characters with code points in\n\t// range 0x00 - 0xFF, which, when interpreted as bytes, are valid UTF-8,\n\t// returns the corresponding Unicode string, along with the number of\n\t// bytes in the input string which were successfully parsed.\n\t//\n\t// Unlike most JavaScript utf-8 encode/decode implementations, properly\n\t// deals with partial multi-byte characters at the end of the byte string.\n\tif (/[^\\x00-\\xFF]/.test(bytes)) {\n\t\tthrow new UnicodeCodecError('invalid utf-8 bytes');\n\t};\n\tvar len, len_parsed;\n\tlen = len_parsed = bytes.length;\n\tvar last = len - 1;\n\t// test for non-ascii final byte. if last byte is ascii (00-7F) we're done.\n\tif (bytes.charCodeAt(last) >= 0x80) {\n\t\t// loop through last 3 bytes looking for first initial byte of unicode\n\t\t// multi-byte character. If the initial byte is 4th from the end, we'll\n\t\t// parse the whole string.\n\t\tfor (var i = 1; i <= 3; i++) {\n\t\t\t// initial bytes are in range C0-FF\n\t\t\tif (bytes.charCodeAt(len - i) >= 0xC0) {\n\t\t\t\tlen_parsed = len - i;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\t\ttry {\n\t\t\t// if the last few bytes are a complete multi-byte character, parse\n\t\t\t// everything (by setting len_parsed)\n\t\t\tdecodeURIComponent(escape(bytes.slice(len_parsed)));\n\t\t\tlen_parsed = len;\n\t\t}\n\t\tcatch (err) { /* pass */ };\n\t};\n\ttry {\n\t\treturn [\n\t\t\tdecodeURIComponent(escape(bytes.slice(0, len_parsed))),\n\t\t\tlen_parsed\n\t\t];\n\t}\n\tcatch (err) {\n\t\tthrow new UnicodeCodecError('invalid utf-8 bytes');\n\t};\n};\n","pre":true},"net/env/browser/postmessage.js":{"path":"net/env/browser/postmessage.js","friendlyPath":"jsio.net.env.browser.postmessage","directory":"net/env/browser/","filename":"postmessage.js","src":"jsio('import net.interfaces');\njsio('from util.browser import $');\njsio('import std.uuid');\n\n/**\n * @extends net.interfaces.Listener\n */\nexports.Listener = Class(net.interfaces.Listener, function(supr) {\n\tvar ID = 0;\n\n\tthis.init = function() {\n\t\tsupr(this, 'init', arguments);\n\t\tthis._clients = {};\n\t\tif (!this._opts.clientUrl) {\n\t\t\tthis._opts.clientUrl = jsio.__dir + '/networkConsole.html';\n\t\t}\n\n\t\tthis._port = '' + (this._opts.port || '');\n\t}\n\n\tthis.listen = function() {\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\t}\n\n\tthis.getButton = function(url, text) {\n\t\tvar button = $({\n\t\t\ttagName: 'button',\n\t\t\ttext: text || 'launch client',\n\t\t\tclassName: 'clientButton'\n\t\t});\n\t\t$.onEvent(button, 'click', bind(this, 'openWindow', url || this._opts.clientUrl));\n\t\treturn button;\n\t}\n\n\tvar uniqueId = 1;\n\tthis.openWindow = function (url) {\n\t\tvar options = { menubar: 'no', location: 'no', toolbar: 'no',\n\t\t\twidth: 550, height: 350, // left: 200, top: 200,\n\t\t\tscrollbars: 'yes', status: 'yes', resizable: 'yes' };\n\n\t\tvar arr = [];\n\t\tfor (var i in options) { arr.push(i + '=' + options[i]) }\n\t\tvar win = window.open(url, 'W' + uniqueId++, arr.join(','));\n\t\twin.focus();\n\t}\n\n\tthis._onMessage = function (evt) {\n\t\tif (typeof evt.data != 'string' || this._port != evt.data.substring(0, this._port.length)) { return; }\n\t\tvar data = evt.data.substring(this._port.length);\n\n\t\ttry {\n\t\t\tdata = JSON.parse(data);\n\t\t} catch (e) {\n\t\t\tlogger.warn('invalid packet', evt.data);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (data.type) {\n\t\t\tcase 'open':\n\t\t\t\tvar transport = this._clients[data.uid] = new exports.Transport(evt.source, this._port, data.uid);\n\t\t\t\tevt.source.postMessage(this._port + JSON.stringify({\"type\":\"open\", uid: data.uid}), '*');\n\t\t\t\tthis.onConnect(transport);\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tvar transport = this._clients[data.uid];\n\t\t\t\tif (transport) { transport.onData(data.payload); }\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\tvar transport = this._clients[data.uid];\n\t\t\t\tif (transport) { transport.onClose(); }\n\t\t\t\tevt.source.postMessage(this._port + JSON.stringify({\"type\":\"close\", uid: data.uid}), '*');\n\t\t\t\tdelete this._clients[data.uid];\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector = Class(net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._port = '' + (this._opts.port || '');\n\t\tthis._win = this._opts.win || window.opener || window.parent;\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\n\t\tthis._uid = std.uuid.uuid();\n\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'open', uid: this._uid}), '*');\n\t}\n\n\tthis._onMessage = function(evt) {\n\t\tif (typeof evt.data != 'string' || this._port != evt.data.substring(0, this._port.length)) { return; }\n\t\tvar data = evt.data.substring(this._port.length);\n\n\t\t// At the moment, we include the uid in the data.  If we have many clients\n\t\t// on the same port with different UIDs then this would get expensive, but\n\t\t// this is a very rare use case for postmessage.\n\t\ttry {\n\t\t\tdata = JSON.parse(data);\n\t\t} catch (e) {\n\t\t\tlogger.warn('invalid packet', evt.data);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (data.type) {\n\t\t\tcase 'open':\n\t\t\t\tthis._transport = new exports.Transport(evt.source, this._port, this._uid);\n\t\t\t\tthis.onConnect(this._transport);\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\tif (data.uid != this._uid) { return; }\n\t\t\t\tthis._transport.onClose();\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tif (data.uid != this._uid) { return; }\n\t\t\t\tthis._transport.onData(data.payload);\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\n/**\n * @extends net.interfaces.Transport\n */\nexports.Transport = Class(net.interfaces.Transport, function() {\n\tthis.init = function (win, port, uid) {if (!uid) debugger\n\t\tthis._win = win;\n\t\tthis._port = port;\n\t\tthis._uid = uid; // unique identifier for clients\n\t}\n\n\tthis.makeConnection = function (protocol) {\n\t\tthis._protocol = protocol;\n\t}\n\n\tthis.write = function (data, encoding) {\n\t\tif (this.encoding == 'utf8') {\n\t\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'data', uid: this._uid, payload: utf8.encode(data)}), '*');\n\t\t} else {\n\t\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'data', uid: this._uid, payload: data}), '*');\n\t\t}\n\t}\n\n\tthis.loseConnection = function (protocol) {\n\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'close', uid: this._uid, code: 301}), '*');\n\t}\n\n\tthis.onData = function () { this._protocol.dataReceived.apply(this._protocol, arguments); }\n\tthis.onClose = function () { this._protocol._connectionLost.apply(this._protocol, arguments); }\n});\n","pre":true},"net/env/browser/socketio.js":{"path":"net/env/browser/socketio.js","friendlyPath":"jsio.net.env.browser.socketio","directory":"net/env/browser/","filename":"socketio.js","src":"jsio('import lib.Callback');\njsio('import net.interfaces');\njsio('import std.utf8 as utf8');\n\nvar _script;\nvar _scriptOnLoad = new lib.Callback();\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector = Class(net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._state = net.interfaces.STATE.CONNECTING;\n\n\t\tvar url = this._opts.url || '/';\n\t\tif (!/\\/$/.test(url)) { url += '/'; }\n\n\t\tif (typeof io != 'function' && typeof document != 'undefined') {\n\t\t\t_script = document.createElement('script');\n\t\t\t_script.onload = _script.onreadystatechange = function () {\n\t\t\t\tif (typeof io == 'function') {\n\t\t\t\t\t_script.onload = _script.onreadystatechange = null;\n\t\t\t\t\t_scriptOnLoad.fire(io);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t_script.src = '/socket.io/socket.io.js';\n\t\t\tdocument.getElementsByTagName('head')[0].appendChild(_script);\n\t\t} else if (!_scriptOnLoad.hasFired()) {\n\t\t\t_scriptOnLoad.fire(io);\n\t\t}\n\n\t\t_scriptOnLoad.run(bind(this, '_connect'));\n\t}\n\n\tthis._connect = function (io) {\n\t\tlogger.debug('opening the connection');\n\t\tvar socket = io(window.location.origin + this._opts.namespace, {multiplex: false});\n\t\tvar transport = new Transport(socket);\n\t\tvar onConnect = bind(this, 'onConnect', transport);\n\n\t\tsocket.on('disconnect', bind(this, 'onDisconnect'));\n\t\tif (socket.connected) {\n\t\t\tonConnect();\n\t\t} else {\n\t\t\tsocket.on('connect', onConnect);\n\t\t}\n\t}\n});\n\nvar Transport = Class(net.interfaces.Transport, function() {\n\tthis.init = function(socket) {\n\t\tthis._socket = socket;\n\t}\n\n\tthis.makeConnection = function(protocol) {\n\t\tthis._socket.on('message', bind(protocol, 'dataReceived'));\n\t}\n\n\tthis.write = function(data) {\n\t\tthis._socket.send(data);\n\t}\n\n\tthis.loseConnection = function(protocol) {\n\t\tthis._socket.close();\n\t}\n});\n","pre":true},"net/env/browser/websocket.js":{"path":"net/env/browser/websocket.js","friendlyPath":"jsio.net.env.browser.websocket","directory":"net/env/browser/","filename":"websocket.js","src":"jsio('import net.interfaces');\njsio('import std.utf8 as utf8');\njsio('import net.errors as Errors');\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector = Class(net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._state = net.interfaces.STATE.CONNECTING;\n\t\t\n\t\tvar url = this._opts.url,\n\t\t \tctor = this._opts.wsConstructor || window.WebSocket;\n\t\n\t\tlogger.info('this._opts', this._opts);\n\t\t\n\t\tvar ws = new ctor(url);\n\t\tws.onopen = bind(this, 'webSocketOnOpen', ws);\n\t\tws.onclose = bind(this, 'webSocketOnClose', ws);\n\t}\n\t\n\tthis.webSocketOnOpen = function(ws) {\n\t\tthis.onConnect(new Transport(ws));\n\t}\n\t\n\tthis.webSocketOnClose = function(ws, e) {\n\t\tvar err,\n\t\t\tdata = {rawError: e, webSocket: ws};\n\t\tif (e.wasClean) {\n\t\t\terr = new Errors.ServerClosedConnection('WebSocket Connection Closed', data);\n\t\t} else {\n\t\t\tif (this._state == net.interfaces.STATE.CONNECTED) {\n\t\t\t\terr = new Errors.ConnectionTimeout('WebSocket Connection Timed Out', data);\n\t\t\t} else {\n\t\t\t\terr = new Errors.ServerUnreachable('WebSocket Connection Failed', data);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlogger.debug('conn closed', err);\n\t\tthis.onDisconnect(err);\n\t}\n});\n\nvar Transport = Class(net.interfaces.Transport, function() {\n\t\n\tthis.init = function(ws) {\n\t\tthis._ws = ws;\n\t}\n\t\n\tthis.makeConnection = function(protocol) {\n\t\tthis._ws.onmessage = function(data) {\n\t\t\tvar payload = utf8.encode(data.data);\n\t\t\tprotocol.dataReceived(payload);\n\t\t}\n\t}\n\t\n\tthis.write = function(data, encoding) {\n\t\tif (this._encoding == 'plain') {\n\t\t\tresult = utf8.decode(data);\n\t\t\tdata = result[0];\n\t\t}\n\t\tthis._ws.send(data);\n\t}\n\t\n\tthis.loseConnection = function(protocol) {\n\t\tthis._ws.close();\n\t}\n});\n","pre":true},"net/env/node/csp/index.js":{"path":"net/env/node/csp/index.js","friendlyPath":"jsio.net.env.node.csp.index","directory":"net/env/node/csp/","filename":"index.js","src":"jsio('import ....interfaces');\njsio('import .server');\n\nvar Transport = Class(interfaces.Transport, function() {\n  this.init = function(socket) {\n    this._socket = socket;\n    logger.debug('init', socket);\n  }\n\n  this.makeConnection = function(protocol) {\n    logger.debug('makeConnection:', protocol);\n    this._socket.addListener(\"receive\", bind(protocol, 'dataReceived'));\n\n    this._socket.addListener(\"close\", bind(protocol, '_connectionLost')); // TODO: map error codes\n  }\n\n  this.write = function(data) {\n    this._socket.send(data);\n  }\n\n  this.loseConnection = function() {\n    this._socket.forceClose();\n  }\n});\n\n/**\n * @extends net.interfaces.Listener\n */\nexports.Listener = Class(interfaces.Listener, function(supr) {\n  this.listen = function () {\n    var s = server.createServer(bind(this, '_onConnect'));\n    this._cspServer = s;\n    var listenString = (this._opts['interface'] || \"\" ) + \":\" + this._opts.port;\n\n    if (this._opts.app) {\n      var app = this._opts.app;\n      var middleware = this.createMiddleware();\n      if (this._opts.url) {\n        app.use(this._opts.url, middleware);\n      } else {\n        app.use(middleware);\n      }\n    } else if (!this._opts.skipListen) {\n      logger.info(\"Listening csp@\" + listenString);\n      s.listen(this._opts.port, this._opts['interface'] || \"\");\n    }\n  }\n\n  this._onConnect = function (socket) {\n    logger.info(\"Incoming connection\");\n    socket.setEncoding(\"utf8\");\n    socket.addListener(\"connect\", bind(this, function() {\n      this.onConnect(new Transport(socket));\n    }));\n  }\n\n  // for express middleware\n  this.createMiddleware = function () {\n    return bind(this._cspServer, '_handleRequest');\n  }\n});\n","pre":true},"net/interfaces.js":{"path":"net/interfaces.js","friendlyPath":"....interfaces","directory":"net/","filename":"interfaces.js","src":"// Sort of like a twisted protocol\njsio('import .index as net');\njsio('import ..lib.Enum as Enum');\njsio('import ..lib.PubSub as PubSub');\n\nvar ctx = jsio.__env.global;\n\nexports.Protocol = Class(function() {\n\tthis.connectionMade = function(isReconnect) {}\n\tthis.dataReceived = function(data) {}\n\tthis.connectionLost = function(reason) {}\n\n\tthis._connectionMade = function() {\n\t\tthis._isConnected = true;\n\t\tthis.connectionMade.apply(this, arguments);\n\t}\n\n\tthis._connectionLost = function() {\n\t\tthis._isConnected = false;\n\t\tthis.connectionLost.apply(this, arguments);\n\t}\n\n\tthis._isConnected = false;\n\tthis.isConnected = function() {\n\t\treturn !!this._isConnected;\n\t}\n\n\tthis.end = function () {\n\t\tif (this.transport) {\n\t\t\tthis.transport.loseConnection();\n\t\t}\n\t}\n});\n\nexports.Client = Class(function() {\n\tthis.init = function(protocol) {\n\t\tthis._protocol = protocol;\n\t}\n\n\tthis.connect = function(transportName, opts) {\n\t\tthis._remote = new this._protocol();\n\t\tthis._remote._client = this;\n\t\tnet.connect(this._remote, transportName, opts);\n\t}\n});\n\n// Sort of like a twisted factory\nexports.Server = Class(function() {\n\tthis.init = function(protocolClass) {\n\t\tthis._protocolClass = protocolClass;\n\t}\n\n\tthis.buildProtocol = function() {\n\t\treturn new this._protocolClass();\n\t}\n\n\tthis.listen = function(transportName, opts) {\n\t\treturn net.listen(this, transportName, opts);\n\t}\n});\n\nexports.Transport = Class(function() {\n\tthis._encoding = 'plain'\n\tthis.write = function(data, encoding) {\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\tthis.getPeer = function() {\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\tthis.setEncoding = function(encoding) {\n\t\tthis._encoding = encoding;\n\t}\n\tthis.getEncoding = function() {\n\t\treturn this._encoding;\n\t}\n});\n\n// emits 'error' event if listen fails\nexports.Listener = Class(PubSub, function() {\n\tthis.init = function(server, opts) {\n\t\tthis._server = server;\n\t\tthis._opts = opts || {};\n\t}\n\n\tthis.onConnect = function(transport) {\n\t\t//try {\n\t\t\tvar p = this._server.buildProtocol();\n\t\t\tp.transport = transport;\n\t\t\tp.server = this._server;\n\t\t\ttransport.protocol = p;\n\t\t\ttransport.makeConnection(p);\n\t\t\tp._connectionMade();\n\t\t//} catch(e) {\n\t\t//\tlogger.error(e);\n\t\t//}\n\t}\n\n\tthis.listen = function() { throw new Error('Abstract class'); }\n\tthis.stop = function() {}\n});\n\nexports.STATE = Enum('INITIAL', 'DISCONNECTED', 'CONNECTING', 'CONNECTED');\nexports.Connector = Class(function() {\n\tthis.init = function(protocol, opts) {\n\t\tthis._protocol = protocol;\n\t\tthis._opts = opts;\n\t\tthis._state = exports.STATE.INITIAL;\n\t}\n\n\tthis.getState = function() { return this._state; }\n\n\tthis.onConnect = function(transport) {\n\t\tthis._state = exports.STATE.CONNECTED;\n\n\t\ttransport.makeConnection(this._protocol);\n\t\tthis._protocol.transport = transport;\n\t\ttry {\n\t\t\tthis._protocol._connectionMade();\n\t\t} catch(e) {\n\t\t\tthrow logger.error(e);\n\t\t}\n\t}\n\n\tthis.onDisconnect = function(err) {\n\t\tvar wasConnected = this._state == exports.STATE.CONNECTED;\n\t\tthis._state = exports.STATE.DISCONNECTED;\n\n\t\ttry {\n\t\t\tthis._protocol._connectionLost(err, wasConnected);\n\t\t} catch(e) {\n\t\t\tthrow logger.error(e);\n\t\t}\n\t}\n\n\tthis.getProtocol = function() { return this._protocol; }\n});\n","pre":true},"net/index.js":{"path":"net/index.js","friendlyPath":".index","directory":"net/","filename":"index.js","src":"jsio('import .env');\njsio('import ..std.JSON as JSON');\njsio('import .interfaces');\n\nJSON.createGlobal(); // create the global JSON object if it doesn't already exist\n\n/**\n * @namespace\n */\n\nexports.listen = function(server, transportName, opts) {\n  if (!transportName) {\n    throw logger.error('No transport provided for net.listen');\n  }\n\n  var ctor = typeof transportName == 'string'\n        ? env.getListener(transportName)\n        : transportName;\n\n  var listener = new ctor(server, opts);\n\n  listener.listen();\n  return listener;\n}\n\nexports.connect = function(protocolInstance, transportName, opts) {\n  var ctor = typeof transportName == 'string' ? env.getConnector(transportName) : transportName,\n    connector = new ctor(protocolInstance, opts);\n  connector.connect();\n  return connector;\n}\n\nexports.quickServer = function(protocolClass) {\n  return new interfaces.Server(protocolClass);\n}\n","pre":true},"net/env/index.js":{"path":"net/env/index.js","friendlyPath":".env","directory":"net/env/","filename":"index.js","src":"function getObj(objectName, transportName, envName) {\n\n  try {\n    var DYNAMIC_IMPORT_ENV = 'from .' + (envName || jsio.__env.name) + '.' + transportName + ' import ' + objectName + ' as result';\n    jsio(DYNAMIC_IMPORT_ENV);\n  } catch(e) {\n    throw logger.error('Invalid transport (', transportName, ') or environment (', envName, ')', e);\n  }\n  return result;\n}\n\nexports.getListener = bind(this, getObj, 'Listener');\nexports.getConnector = bind(this, getObj, 'Connector');\n","pre":true},"std/JSON.js":{"path":"std/JSON.js","friendlyPath":"..std.JSON","directory":"std/","filename":"JSON.js","src":"// Based on json2.js (version 2009-09-29) http://www.JSON.org/json2.js\n// exports createGlobal, stringify, parse, stringifyDate\n\n/**\n * if a global JSON object doesn't exist, create one\n */\nexports.createGlobal = function() {\n\tif(typeof JSON == 'undefined') { JSON = {}; }\n\tif(typeof JSON.stringify !== 'function') {\n\t\tJSON.stringify = exports.stringify;\n\t}\n\tif(typeof JSON.parse !== 'function') {\n\t\tJSON.parse = exports.parse;\n\t}\n};\n\n;(function() {\n\tvar cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t\tescapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t\tgap,\n\t\tindent,\n\t\tmeta = {\t// table of character substitutions\n\t\t\t'\\b': '\\\\b',\n\t\t\t'\\t': '\\\\t',\n\t\t\t'\\n': '\\\\n',\n\t\t\t'\\f': '\\\\f',\n\t\t\t'\\r': '\\\\r',\n\t\t\t'\"' : '\\\\\"',\n\t\t\t'\\\\': '\\\\\\\\'\n\t\t},\n\t\trep;\n\t\n\tfunction quote(string) {\n\t\t// quote the string if it doesn't contain control characters, quote characters, and backslash characters\n\t\t// otherwise, replace those characters with safe escape sequences\n\t\tescapable.lastIndex = 0;\n\t\treturn escapable.test(string)\n\t\t\t? '\"' + string.replace(escapable, function (a) {\n\t\t\t\t\tvar c = meta[a];\n\t\t\t\t\treturn typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t\t\t\t}) + '\"'\n\t\t\t: '\"' + string + '\"';\n\t}\n\t\n\t// Produce a string from holder[key].\n\tfunction str(key, holder) {\n\t\tvar mind = gap, value = holder[key];\n\t\t\n\t\t// If the value has a toJSON method, call it to obtain a replacement value.\n\t\tif (value && typeof value === 'object' && typeof value.toJSON === 'function') {\n\t\t\tvalue = value.toJSON(key);\n\t\t}\n\t\t\n\t\t// If we were called with a replacer function, then call the replacer to\n\t\t// obtain a replacement value.\n\t\tif (typeof rep === 'function') { value = rep.call(holder, key, value); }\n\t\t\n\t\tswitch (typeof value) {\n\t\t\tcase 'string':\n\t\t\t\treturn quote(value);\n\t\t\tcase 'number':\n\t\t\t\t// JSON numbers must be finite\n\t\t\t\treturn isFinite(value) ? String(value) : 'null';\n\t\t\tcase 'boolean':\n\t\t\t\treturn String(value);\n\t\t\tcase 'object': // object, array, date, null\n\t\t\t\tif (value === null) { return 'null'; } // typeof null == 'object'\n\t\t\t\tif (value.constructor === Date) { return exports.stringifyDate(value); }\n\t\t\t\n\t\t\t\tgap += indent;\n\t\t\t\tvar partial = [];\n\t\t\t\t\n\t\t\t\t// Is the value an array?\n\t\t\t\tif (value.constructor === Array) {\n\t\t\t\t\tvar length = value.length;\n\t\t\t\t\tfor (var i = 0; i < length; i += 1) {\n\t\t\t\t\t\tpartial[i] = str(i, value) || 'null';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Join all of the elements together, separated with commas, and wrap them in brackets.\n\t\t\t\t\tvar v = partial.length === 0 ? '[]' :\n\t\t\t\t\t\tgap ? '[\\n' + gap +\n\t\t\t\t\t\t\t\tpartial.join(',\\n' + gap) + '\\n' +\n\t\t\t\t\t\t\t\t\tmind + ']' :\n\t\t\t\t\t\t\t  '[' + partial.join(',') + ']';\n\t\t\t\t\tgap = mind;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (rep && typeof rep === 'object') { // rep is an array\n\t\t\t\t\tvar length = rep.length;\n\t\t\t\t\tfor (var i = 0; i < length; i += 1) {\n\t\t\t\t\t\tvar k = rep[i];\n\t\t\t\t\t\tif (typeof k === 'string') {\n\t\t\t\t\t\t\tvar v = str(k, value);\n\t\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { // iterate through all of the keys in the object.\n\t\t\t\t\tfor (var k in value) {\n\t\t\t\t\t\tif (Object.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\tvar v = str(k, value);\n\t\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Join all of the member texts together, separated with commas,\n\t\t\t\t// and wrap them in braces.\n\t\t\t\tvar v = partial.length === 0 ? '{}' :\n\t\t\t\t\tgap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' +\n\t\t\t\t\t\t\tmind + '}' : '{' + partial.join(',') + '}';\n\t\t\t\tgap = mind;\n\t\t\t\treturn v;\n\t\t}\n\t}\n\n\n\t/**\n\t * The stringify method takes a value and an optional replacer, and an optional\n\t * space parameter, and returns a JSON text. The replacer can be a function\n\t * that can replace values, or an array of strings that will select the keys.\n \t * A default replacer method can be provided. Use of the space parameter can\n\t * produce text that is more easily readable.\n\t */\n\texports.stringify = function (value, replacer, space) {\n\t\tgap = '';\n\t\tindent = '';\n\t\t\n\t\t// If the space parameter is a number, make an indent string containing that many spaces.\n\t\tif (typeof space === 'number') {\n\t\t\tfor (var i = 0; i < space; i += 1) {\n\t\t\t\tindent += ' ';\n\t\t\t}\n\t\t} else if (typeof space === 'string') {\n\t\t\tindent = space;\n\t\t}\n\t\t\n\t\t// If there is a replacer, it must be a function or an array.\n\t\trep = replacer;\n\t\tif (replacer && typeof replacer !== 'function' &&\n\t\t\t\t(typeof replacer !== 'object' ||\n\t\t\t\t typeof replacer.length !== 'number')) {\n\t\t\tthrow new Error('JSON stringify: invalid replacer');\n\t\t}\n\t\t\n\t\t// Make a fake root object containing our value under the key of ''.\n\t\t// Return the result of stringifying the value.\n\t\treturn str('', {'': value});\n\t};\n\t\n\texports.stringifyDate = function(d) {\n\t\tvar year = d.getUTCFullYear(),\n\t\t\tmonth = d.getUTCMonth() + 1,\n\t\t\tday = d.getUTCDate(),\n\t\t\thours = d.getUTCHours(),\n\t\t\tminutes = d.getUTCMinutes(),\n\t\t\tseconds = d.getUTCSeconds(),\n\t\t\tms = d.getUTCMilliseconds();\n\t\t\n\t\tif (month < 10) { month = '0' + month; }\n\t\tif (day < 10) { day = '0' + day; }\n\t\tif (hours < 10) { hours = '0' + hours; }\n\t\tif (minutes < 10) { minutes = '0' + minutes; }\n\t\tif (seconds < 10) { seconds = '0' + seconds; }\n\t\tif (ms < 10) { ms = '00' + ms; }\n\t\telse if (ms < 100) { ms = '0' + ms; }\n\n\t\treturn '\"' + year\n\t\t\t+ '-' + month\n\t\t\t+ '-' + day\n\t\t\t+ 'T' + hours\n\t\t\t+ ':' + minutes\n\t\t\t+ ':' + seconds\n\t\t\t+ '.' + ms\n\t\t\t+ 'Z\"';\n\t}\n\t\n\t/**\n\t * The parse method takes a text and an optional reviver function, and returns\n\t * a JavaScript value if the text is a valid JSON text.\n\t */\n\texports.parse = function (text, reviver) {\n\t\t// Parsing happens in four stages. In the first stage, we replace certain\n\t\t// Unicode characters with escape sequences. JavaScript handles many characters\n\t\t// incorrectly, either silently deleting them, or treating them as line endings.\n\t\tcx.lastIndex = 0;\n\t\tif (cx.test(text)) {\n\t\t\ttext = text.replace(cx, function (a) {\n\t\t\t\treturn '\\\\u' +\n\t\t\t\t\t('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t\t\t});\n\t\t}\n\t\t\n\t\t// In the second stage, we run the text against regular expressions that look\n\t\t// for non-JSON patterns. We are especially concerned with '()' and 'new'\n\t\t// because they can cause invocation, and '=' because it can cause mutation.\n\t\t// But just to be safe, we want to reject all unexpected forms.\n\n\t\t// We split the second stage into 4 regexp operations in order to work around\n\t\t// crippling inefficiencies in IE's and Safari's regexp engines. First we\n\t\t// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n\t\t// replace all simple value tokens with ']' characters. Third, we delete all\n\t\t// open brackets that follow a colon or comma or that begin the text. Finally,\n\t\t// we look to see that the remaining characters are only whitespace or ']' or\n\t\t// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n\t\tif (/^[\\],:{}\\s]*$/\n\t\t\t\t.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n\t\t\t\t.replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n\t\t\t\t.replace(/(?:^|:|,)(?:\\s*\\[)+/g, '')))\n\t\t{\n\t\t\tvar j = eval('(' + text + ')');\n\t\t\tif(!reviver) {\n\t\t\t\treturn j;\n\t\t\t} else {\n\t\t\t\t// In the optional fourth stage, we recursively walk the new structure, passing\n\t\t\t\t// each name/value pair to a reviver function for possible transformation.\n\t\t\t\tvar walk = function(holder, key) {\n\t\t\t\t\t// The walk method is used to recursively walk the resulting structure so\n\t\t\t\t\t// that modifications can be made.\n\t\t\t\t\tvar k, v, value = holder[key];\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tfor (k in value) {\n\t\t\t\t\t\t\tif (Object.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\t\tv = walk(value, k);\n\t\t\t\t\t\t\t\tif (v !== undefined) {\n\t\t\t\t\t\t\t\t\tvalue[k] = v;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdelete value[k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn reviver.call(holder, key, value);\n\t\t\t\t}\n\t\t\t\treturn walk({'': j}, '');\n\t\t\t}\n\t\t}\n\n\t\t// If the text is not JSON parseable, then a SyntaxError is thrown.\n\t\tthrow new SyntaxError('JSON.parse');\n\t};\n}());","pre":true},"net/env/node/csp/server.js":{"path":"net/env/node/csp/server.js","friendlyPath":".server","directory":"net/env/node/csp/","filename":"server.js","src":"/*\nCSP server implemented against Node JS, by Jacob Rus.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// Make the dependancies work rather or not this file was used as a\n// node module or a jsio module.\n\njsio('import .....std.uuid as uuid');\njsio('import .....std.utf8 as utf8');\njsio('import .....std.base64 as base64');\njsio('import .....lib.Hash as Hash');\njsio('from .util import *');\n\nvar http = require('http');\nvar nodeUrl = require('url');\n\nvar sessionDict = {},\n\tvarNames = {\n\t\t// per session\n\t\t'ct' : 'contentType',\n\t\t'ps' : 'prebufferSize',\n\t\t'p'\t : 'preamble',\n\t\t'rp' : 'requestPrefix',\n\t\t'rs' : 'requestSuffix',\n\t\t'bp' : 'batchPrefix',\n\t\t'bs' : 'batchSuffix',\n\t\t'i'\t : 'interval',\n\t\t'du' : 'duration',\n\t\t'is' : 'isStreaming',\n\t\t'g'\t : 'gzipOk',\n\t\t'se' : 'sse'\n\t\t// 's'\t: 'sessionKey', // per request, handled at the csp.Server level\n\t\t// 'a'\t: 'ackId',\t\t\t// left here to instruct other implementors.\n\t\t// 'd'\t: 'data',\n\t\t// 'n'\t: 'noCache',\n\t};\n\nexports.Session = Class(function() {\n\tthis.init = function () {\n\t\t// this.lastAck = 0; // 'a' variable\n\t\tthis.key = uuid.uuid(8);\t\t\t // generate 8-character base-62 UUID\n\t\tsessionDict[this.key] = this;\t // Add session to sessions dictionary\n\t\tthis.connection = null;\t\t\t\t // this.connection set from outside.\n\t\tthis.outgoingPacketBuffer = [];\n\t\tthis.incomingPacketBuffer = [];\n\t\tthis.lastSequentialIncomingId = 0\n\t\tthis.cometResponse = null;\n\t\tthis.durationTimer = null;\n\t\tthis.intervalTimer = null;\n\t\tthis.timeoutTimer = null;\n\t\tthis.outgoingPacketId = 1;\n\t\tthis.variables = { // set variables to defaults\n\t\t\t'contentType'   : 'text/html',\n\t\t\t// 'prebufferSize' : '0', // result stored in 'prebuffer' variable.\n\t\t\t'prebuffer'\t : '',\n\t\t\t'preamble'\t  : '',\n\t\t\t'requestPrefix' : '',\n\t\t\t'requestSuffix' : '',\n\t\t\t'batchPrefix'   : '',\n\t\t\t'batchSuffix'   : '',\n\t\t\t'interval'\t  : '0',\n\t\t\t'duration'\t  : '30',\n\t\t\t'isStreaming'   : '0',\n\t\t\t'gzipOk'\t\t: '',\n\t\t\t'sse'\t\t   : ''\n\t\t};\n\t\tthis.resetTimeoutTimer();\n\t};\n\tthis.teardownSession = function () {\n\t\tclearTimeout(this.durationTimer);\n\t\tthis.connection.readyState = (this.connection.readyState === 'open' ? 'writeOnly' : 'closed');\n\t\tthis.connection.emit('eof');\n\t\t// XXX when the client calls close, do we want to allow the server to\n\t\t// keep sending them stuff, write only? And what about when they time out?\n\t\tdelete sessionDict[this.key];\n\t};\n\t// send data to the client\n\tthis.send = function (data) {\n\t\t// base64-encode any string data with control characters or non-ASCII\n\t\tvar packet = (typeof data === 'string' && (/[^\\r\\n\\t\\x32-\\x7E]/).test(data)) ?\n\t\t\t[this.outgoingPacketId, 1, base64.encode(data)] :\n\t\t\t[this.outgoingPacketId, 0, data];\n\t\tthis.outgoingPacketId += 1;\n\t\tthis.outgoingPacketBuffer.push(packet);\n\t\tif (this.cometResponse) {\n\t\t\tthis.sendBatch([packet]);\n\t\t}; // else if no comet connection, just keep buffering packets\n\t};\n\tthis.close = function () {\n\t\t// call this to close a comet connection, and stop writing to it.\n\t\t// any remaining incoming packets will still fire 'receive' events.\n\t\tthis.send(null);\n\t\tthis.connection.readyState = (this.connection.readyState === 'open' ? 'readOnly' : 'closed');\n\t\tthis.connection.emit('close');\n\t};\n\n\tvar updatedHeaders = new Hash('gzipOk', 'contentType');\n\tthis.updateVars = function (params) {\n\t\tfor (var param in params) {\n\t\t\tvar key = varNames[param];\n\t\t\tif (!key) continue;\n\t\t\tvar value = params[param];\n\t\t\t// if gzipOk or contentType changes value, finish up any comet response with the previous values\n\t\t\tif (updatedHeaders.contains(key) && value != this.variables[key] && this.cometResponse) {\n\t\t\t\tthis.completeResponse();\n\t\t\t};\n\t\t\tif (key in this.variables) {\n\t\t\t\tthis.variables[key] = value;\n\t\t\t}\n\t\t\telse if (key == 'prebufferSize') {\n\t\t\t\tvar prebufferSize = parseInt(value);\n\t\t\t\tif (prebufferSize > 0) {\n\t\t\t\t\t// string of spaces of length prebufferSize\n\t\t\t\t\tthis.variables.prebuffer = (new Array(prebufferSize+1)).join(' ');\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\tthis.isStreaming = function () {\n\t\treturn (this.variables.isStreaming === '1') && (parseInt(this.variables.duration) > 0);\n\t};\n\tthis.resetDurationTimer = function () {\n\t\tvar duration = 1000 * parseInt(this.variables.duration);\n\t\tthis.durationTimer = setTimeout(bind(this, this.completeResponse), duration);\n\t};\n\tthis.resetIntervalTimer = function () {\n\t\tclearTimeout(this.intervalTimer);\n\t\tif (this.variables.interval === '0') {\n\t\t\treturn;\n\t\t};\n\t\tvar interval = 1000 * parseInt(this.variables.interval);\n\t\tthis.intervalTimer = setTimeout(bind(this, this.sendBatch), interval);\n\t};\n\tthis.resetTimeoutTimer = function () {\n\t\tclearTimeout(this.timeoutTimer);\n\t\t// Give the client 50% longer than the duration of a comet request before\n\t\t// we time them out.\n\t\tvar timeout = 1000 * parseInt(this.variables.duration) * 1.5;\n\t\tthis.timeoutTimer = setTimeout(bind(this, this.teardownSession), timeout);\n\t};\n\tthis.sendHeaders = function (response, contentLength) {\n\t\tvar allowOrigin = '*'; // XXX: Make Access-Control configurable\n\t\tif (contentLength === 'stream') {\n\t\t\tresponse.writeHead(200, {\n\t\t\t\t'Content-Type'\t\t\t\t: this.variables.contentType,\n\t\t\t\t'Cache-Control'\t\t\t   : 'no-cache, must-revalidate',\n\t\t\t\t'Transfer-Encoding'\t\t   : 'chunked',\n\t\t\t\t'Access-Control-Allow-Origin' : allowOrigin\n\t\t\t});\n\t\t}\n\t\telse if (contentLength >= 0) {\n\t\t\tresponse.writeHead(200, {\n\t\t\t\t'Content-Type'\t\t\t\t: this.variables.contentType,\n\t\t\t\t'Cache-Control'\t\t\t   : 'no-cache, must-revalidate',\n\t\t\t\t'Content-Length'\t\t\t  : contentLength,\n\t\t\t\t'Access-Control-Allow-Origin' : allowOrigin\n\t\t\t});\n\t\t};\n\t};\n\tthis.startStream = function () {\n\t\tthis.sendHeaders(this.cometResponse, 'stream');\n\t\tvar preamble = this.variables.prebuffer + this.variables.preamble;\n\t\tif (preamble) {\n\t\t\tthis.cometResponse.write(preamble);\n\t\t};\n\t\tthis.resetIntervalTimer();\n\t};\n\tthis.sendBatch = function (packetArray) {\n\t\tif (!packetArray) { packetArray = []; }; // default value\n\t\tvar prefix = this.variables.batchPrefix + '(';\n\t\tvar suffix = ')' + this.variables.batchSuffix;\n\t\tif (this.variables.sse === '1' && packetArray) {\n\t\t\t// ID of last packet in the batch is the \"SSE ID\"\n\t\t\tsuffix += 'id: ' + packetArray[packetArray.length - 1][0] + '\\r\\n';\n\t\t};\n\t\tvar batch = prefix + JSON.stringify(packetArray) + suffix;\n\t\tif (this.isStreaming()) {\n\t\t\tthis.cometResponse.write(batch);\n\t\t\tthis.resetIntervalTimer();\n\t\t} else {\n\t\t\tvar body = (this.variables.prebuffer + this.variables.preamble + batch);\n\t\t\tthis.sendHeaders(this.cometResponse, body.length)\n\t\t\tthis.cometResponse.write(body);\n\t\t\tthis.cometResponse.end();\n\t\t\tthis.cometResponse = null;\n\t\t\tclearTimeout(this.durationTimer);\n\t\t};\n\t};\n\tthis.completeResponse = function() {\n\t\tif (this.isStreaming()) {\n\t\t\tthis.cometResponse.end(); // close a stream\n\t\t\tthis.cometResponse = null;\n\t\t\tclearTimeout(this.durationTimer);\n\t\t\tclearTimeout(this.intervalTimer);\n\t\t} else {\n\t\t\tthis.sendBatch() // send empty batch to poll/longpoll\n\t\t};\n\t};\n\tthis.receiveAck = function (ackId) {\n\t\tthis.resetTimeoutTimer();\n\t\twhile (this.outgoingPacketBuffer.length && ackId >= this.outgoingPacketBuffer[0][0]) {\n\t\t\tthis.outgoingPacketBuffer.shift(); // remove first element\n\t\t};\n\t};\n\t// used for handshake, send, and close (not comet or reflect)\n\tthis.renderResponse = function (response, body) {\n\t\tvar prefix = this.variables.requestPrefix + '(';\n\t\tvar suffix = ')' + this.variables.requestSuffix;\n\t\tbody = prefix + body + suffix;\n\t\tthis.sendHeaders(response, body.length);\n\t\tresponse.write(body);\n\t\tresponse.end();\n\t};\n\t// a Server instance dispatches resources to this object's functions\n\tthis.dispatch = {\n\t\thandshake: function (request, response) {\n\t\t\tthis.renderResponse(response, JSON.stringify( {'session': this.key}));\n\t\t},\n\t\tcomet: function (request, response) {\n\t\t\tthis.cometResponse = response;\n\t\t\tif (this.isStreaming()) {\n\t\t\t\tthis.startStream();\n\t\t\t};\n\t\t\t// we have buffered packets, so send them.\n\t\t\tif (this.outgoingPacketBuffer.length) {\n\t\t\t\tthis.sendBatch(this.outgoingPacketBuffer);\n\t\t\t};\n\t\t\t// if we have no events to deliver, or if this is a stream, start a\n\t\t\t// duration timer, after which the response will always complete\n\t\t\tif (!this.outgoingPacketBuffer.length || this.isStreaming()) {\n\t\t\t\tthis.resetDurationTimer();\n\t\t\t};\n\t\t},\n\t\tsend: function (request, response) {\n\t\t\tvar batch = JSON.parse(request.data);\n\t\t\tlogger.debug('received packet batch:', batch);\n\t\t\twhile (batch[0] != undefined) {\n\t\t\t\t// packetId, encoding, content = batch.shift()\n\t\t\t\tvar packetContent,\n\t\t\t\t\tpacket = batch.shift(),\n\t\t\t\t\tpacketId = packet[0], encoding = packet[1], content = packet[2];\n\n\t\t\t\tif (content === null) {\n\t\t\t\t\tthis.close();\n\t\t\t\t} else if (encoding === 0) {\n\t\t\t\t\tpacketContent = content;\n\t\t\t\t} else if (encoding === 1) {\n\t\t\t\t\tpacketContent = base64.decode(content);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug('BAD PACKET ENCODING,', encoding, '... dropping packet');\n\t\t\t\t\tbreak; // XXX probably should end connection here.\n\t\t\t\t};\n\t\t\t\tthis.incomingPacketBuffer[packetId - 1 - this.lastSequentialIncomingId] = packetContent;\n\t\t\t};\n\t\t\tlogger.debug('incomingPacketBuffer', this.incomingPacketBuffer);\n\t\t\twhile (this.incomingPacketBuffer[0] !== undefined) {\n\t\t\t\tvar nextPacketPayload = this.incomingPacketBuffer.shift();\n\t\t\t\tthis.lastSequentialIncomingId += 1;\n\t\t\t\tthis.connection._receive(nextPacketPayload);\n\t\t\t}; // this can leave packets in the buffer, to handled later, in order\n\t\t\tthis.renderResponse(response, '\"OK\"');\n\t\t},\n\t\tclose: function (request, response) {\n\t\t\tthis.teardownSession();\n\t\t\tthis.renderResponse(response, '\"OK\"');\n\t\t},\n\t\treflect: function (request, response) {\n\t\t\tvar body = request.data;\n\t\t\tthis.sendHeaders(response, body.length);\n\t\t\tresponse.write(body);\n\t\t\tresponse.end();\n\t\t},\n\t\tstreamtest: function (request, response) {\n\t\t\tlogger.debug('streamtest'); // XXX who knows what this does...?\n\t\t}\n\t};\n});\n\nexports.Connection = Class(process.EventEmitter, function() {\n\tthis.init = function (session) {\n\t\tthis.remoteAddress = null; // XXX get remote address from requests\n\t\tthis.readyState = 'open';\n\t\tthis._session = session;\n\t\tthis._encoding = 'binary';\n\t\tthis._utf8buffer = '';\n\t};\n\tthis._receive = function (data) {\n\t\tif (this._encoding === 'utf8') {\n\t\t\tthis._utf8buffer += data;\n\t\t\t// data, len_parsed = utf8.decode(this._utf8buffer)\n\t\t\tvar x = utf8.decode(this._utf8buffer), data = x[0], len_parsed = x[1];\n\t\t\tthis._utf8buffer = this._utf8buffer.slice(len_parsed) // buffer unparsed bytes\n\t\t};\n\t\tthis.emit('receive', data);\n\t};\n\n\tvar validEncodings = new Hash('utf8', 'plain', 'binary');\n\tthis.setEncoding = function (encoding) {\n\t\tassert(validEncodings.contains(encoding), 'unrecognized encoding: ' + encoding);\n\t\tif (encoding !== 'utf8') {\n\t\t\tassert(!(this._utf8buffer), 'cannot switch encodings with dirty utf8 buffer');\n\t\t};\n\t\tthis._encoding = encoding;\n\t};\n\n\tvar validReadyStates = new Hash('writeOnly', 'open');\n\tthis.send = function (data, encoding) {\n\t\tif (!validReadyStates.contains(this.readyState)) {\n\t\t\t// XXX make error type for this\n\t\t\tthrow new Error(\"Socket is not writable in readyState: \" + this.readyState);\n\t\t};\n\t\tencoding = encoding || this._encoding || 'binary'; // default to 'binary'\n\t\tassert(validEncodings.contains(encoding), 'unrecognized encoding: ' + encoding);\n\t\tdata = (encoding === 'utf8') ? utf8.encode(data) : data;\n\t\tthis._session.send(data);\n\t};\n\tthis.close = function () {\n\t\tthis._session.close();\n\t};\n});\n\nexports.createServer = function (connection_listener) {\n\treturn new exports.Server().addListener('connection', connection_listener);\n};\n\nexports.Server = Class(process.EventEmitter, function () {\n\tthis.init = function (sessionURL) {\n\t\tprocess.EventEmitter.call(this);\n\t\tthis._sessionUrl = sessionURL || '';\n\t\tlog('starting server, session url is <' + this._sessionUrl + '>');\n\t};\n\tvar CSPError = Class(AssertionError, function (supr) {\n\t\tthis.name = 'CSPError'\n\t\tthis.init = function (code/*, other args */) {\n\t\t\tsupr(this, 'init', args);\n\t\t\tthis.code = code;\n\t\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\t};\n\t});\n\tvar assertOrRenderError = function (exp, code, message) {\n\t\tif (!exp) { throw new CSPError(code, message) };\n\t};\n\tvar renderError = function (response, code, message) {\n\t\tresponse.writeHead(code, {'Content-Type'   : 'text/plain',\n\t\t\t\t\t\t\t\t   'Content-Length' : message.length});\n\t\tresponse.write(message);\n\t\tresponse.end();\n\t};\n\tvar sendStatic = function (path, response) {\n\t\tlogger.debug('SEND STATIC', path, response)\n\t\tstaticFile('./' + path.join('/'), function(err, content){\n\t\t\tif (err) {\n\t\t\t\trenderError(response, 404, 'No such file, ' + path);\n\t\t\t} else {\n\t\t\t\tresponse.writeHead(200, {'Content-Type'   : 'text/plain',\n\t\t\t\t\t\t\t\t\t\t  'Content-Length' : content.length});\n\t\t\t\tresponse.write(content);\n\t\t\t\tresponse.end();\n\t\t\t}\n\t\t})\n\t};\n\t// returns a request which fires with the whole post body as bytes, or\n\t// immediately with null for GET requests\n\tvar getRequestBody = function (request, callback) {\n\t\tif (request.method === 'GET') {\n\t\t\treschedule(function () {\n\t\t\t\tcallback('')\n\t\t\t});\n\t\t} else {\n\t\t\tvar body = [];\n\t\t\trequest.setEncoding('binary');\n\t\t\trequest\n\t\t\t\t.addListener('data', function (chunk) {\n\t\t\t\t\tbody.push(chunk); // body += chunk\n\t\t\t\t})\n\t\t\t\t.addListener('end', function () {\n\t\t\t\t\tcallback(body.join(''));\n\t\t\t\t});\n\t\t};\n\t};\n\t// The logic of the server goes in the 'handleRequest' function, which is\n\t// called every time a new request comes in.\n\tvar validResources = new Hash('static', 'handshake', 'comet', 'send', 'close', 'reflect', 'streamtest'),\n\t\tvalidMethods = new Hash('GET', 'POST');\n\tthis._handleRequest = function (request, response) {\n\t\tgetRequestBody(request, bind(this, function(body) {\n\t\t\tlogger.debug('received request', request.url);\n\t\t\ttry {\n\t\t\t\tvar uri = nodeUrl.parse(request.url, true),\n\t\t\t\t\tpath = uri.pathname,\n\t\t\t\t\tsessionUrl = this._sessionUrl;\n\n\t\t\t\tassertOrRenderError(startswith(path, sessionUrl + '/'),\n\t\t\t\t\t\t\t\t\t404, 'Request to invalid session URL');\n\t\t\t\tlogger.debug(request.method);\n\t\t\t\tassertOrRenderError(validMethods.contains(request.method),\n\t\t\t\t\t\t\t\t\t405, 'Invalid HTTP method, ' + request.method);\n\n\t\t\t\tvar resource = path.split('/').pop();\n\t\t\t\tif (resource === 'static') {\n\t\t\t\t\tassertOrRenderError(startswith(path, sessionUrl + '/'),\n\t\t\t\t\t\t\t\t\t\t404, 'sendStatic Not Implemented');\n\t\t\t\t\t// TODO: sendStatic(relativePath, response);\n\t\t\t\t\treturn;\n\t\t\t\t};\n\n\t\t\t\tassertOrRenderError(validResources.contains(resource),\n\t\t\t\t\t\t\t\t\t404, 'Invalid resource, ' + path);\n\n\t\t\t\tvar params = uri.query;\n\n\t\t\t\t// 'data' is either the POST body if it exists, or the 'd' variable\n\t\t\t\trequest.data = body || params.d || null;\n\t\t\t\tif (resource === 'handshake') {\n\t\t\t\t\tassertOrRenderError(!params.s, 400, 'Handshake cannot have session');\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar dict = JSON.parse(request.data);\n\t\t\t\t\t\t// make sure our json dict is an object literal\n\t\t\t\t\t\tassert((dict instanceof Object) && !(dict instanceof Array));\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tlogger.debug('INVALID HANDSHAKE, ', request, err);\n\t\t\t\t\t\tthrow new CSPError(400, 'Invalid data parameter for handshake');\n\t\t\t\t\t};\n\t\t\t\t\tvar session = new exports.Session();\n\t\t\t\t\tvar connection = new exports.Connection(session);\n\t\t\t\t\tsession.connection = connection;\n\t\t\t\t\tthis.emit('connection', connection);\n\t\t\t\t\tconnection.emit('connect');\n\t\t\t\t} else {\n\t\t\t\t\tvar session = sessionDict[params.s];\n\t\t\t\t\tassertOrRenderError(session, 400, 'Invalid or missing session');\n\t\t\t\t\t// 'ackId' is either the 'Last-Event-Id' header, or the 'a' variable\n\t\t\t\t\tvar ackId = parseInt(request.headers['Last-Event-Id']) || parseInt(params.a) || -1;\n\t\t\t\t\tsession.receiveAck(ackId);\n\t\t\t\t};\n\t\t\t\tsession.updateVars(params);\n\t\t\t\tsession.dispatch[resource].call(session, request, response); // logic is in session\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tif (err instanceof CSPError) {\n\t\t\t\t\trenderError(response, err.code, err.message);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn('Unexpected Error: ', err.message, err.stack);\n\t\t\t\t\trenderError(response, 500, 'Unknown Server error');\n\t\t\t\t};\n\t\t\t};\n\t\t}));\n\t};\n\tthis.listen = function (port, host) {\n\t\tvar server = http.createServer(bind(this, this._handleRequest));\n\t\tif (!port) { throw logger.error('No port specified'); }\n\t\tserver.listen(port, host);\n\t};\n});\n\n/* // un-comment to run echo server when this file runs\n\njsio.__env.include('/utils.js');\nfunction start_echo_server () {\n\tvar server = csp.createServer(function(connection) {\n\t\tconnection.addListener('receive', function (data) {\n\t\t\tconnection.send(data);\n\t\t});\n\t});\n\tserver.listen(8000);\n\tputs('CSP-based echo server running.');\n};\n\nstart_echo_server();\n*/\n","pre":true},"std/base64.js":{"path":"std/base64.js","friendlyPath":".....std.base64","directory":"std/","filename":"base64.js","src":"/*\n\"URL-safe\" Base64 Codec, by Jacob Rus\n\nThis library happily strips off as many trailing '=' as are included in the\ninput to 'decode', and doesn't worry whether its length is an even multiple\nof 4. It does not include trailing '=' in its own output. It uses the\n'URL safe' base64 alphabet, where the last two characters are '-' and '_'.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n\ttrailingPad = '=',\n\tpadChar = alphabet.charAt(alphabet.length - 1);\n\nvar decodeMap = {};\nfor (var i = 0, len = alphabet.length; i < len; i++) {\n\tdecodeMap[alphabet.charAt(i)] = i;\n}\n\n// use this regexp in the decode function to sniff out invalid characters.\nvar alphabet_inverse = new RegExp('[^' + alphabet.replace('-', '\\\\-') + ']');\n\nexports.Base64CodecError = Class(Error, function(supr) {\n\tthis.name = 'Base64CodecError';\n\t\n\tthis.init = function(message) {\n\t\tthis.message = message;\n\t}\n});\n\nvar assertOrBadInput = function (exp, message) {\n\tif (!exp) { throw new exports.Base64CodecError(message) };\n};\n\nexports.encode = function (bytes, skipPadding) {\n\tassertOrBadInput(!(/[^\\x00-\\xFF]/.test(bytes)), // disallow two-byte chars\n\t\t'Input contains out-of-range characters.');\n\tvar paddingSize = bytes.length % 3;\n\tvar padding = '\\x00\\x00\\x00'.slice(paddingSize || 3);\n\tbytes += padding; // pad with null bytes\n\tvar out_array = [];\n\tfor (var i=0, n=bytes.length; i < n; i+=3) {\n\t\tvar newchars = (\n\t\t\t(bytes.charCodeAt(i)   << 020) +\n\t\t\t(bytes.charCodeAt(i+1) << 010) +\n\t\t\t(bytes.charCodeAt(i+2)));\n\t\tout_array.push(\n\t\t\talphabet.charAt((newchars >> 18) & 077),\n\t\t\talphabet.charAt((newchars >> 12) & 077),\n\t\t\talphabet.charAt((newchars >> 6)  & 077),\n\t\t\talphabet.charAt((newchars)       & 077));\n\t};\n\t\n\tout_array.length -= padding.length;\n\tvar ret = out_array.join('');\n\tif (!skipPadding) {\n\t\tif (paddingSize == 1) {\n\t\t\tret += '==';\n\t\t} else if (paddingSize == 2) {\n\t\t\tret += '=';\n\t\t}\n\t}\n\t\n\treturn ret;\n};\n\nexports.decode = function (b64text) {\n\tlogger.debug('decode', b64text);\n\tb64text = b64text.replace(/\\s/g, ''); // kill whitespace\n\t\n\t// strip trailing pad characters from input; // XXX maybe some better way?\n\tvar i = b64text.length;\n\twhile (b64text.charAt(--i) === trailingPad) {};\n\tb64text = b64text.slice(0, i + 1);\n\t\n\tassertOrBadInput(!alphabet_inverse.test(b64text), 'Input contains out-of-range characters.');\n\t\n\tvar padLength = 4 - ((b64text.length % 4) || 4),\n\t\tpadding = Array(padLength + 1).join(padChar);\n\t\n\tb64text += padding; // pad with last letter of alphabet\n\t\n\tvar out_array = [],\n\t\tlength = i + padLength + 1; // length of b64text\n\t\n\tfor (var i = 0; i < length; i += 4) {\n\t\tnewchars = (\n\t\t\t(decodeMap[b64text.charAt(i)]   << 18) +\n\t\t\t(decodeMap[b64text.charAt(i+1)] << 12) +\n\t\t\t(decodeMap[b64text.charAt(i+2)] << 6)  +\n\t\t\t(decodeMap[b64text.charAt(i+3)]));\n\t\tout_array.push(\n\t\t\t(newchars >> 020) & 0xFF,\n\t\t\t(newchars >> 010) & 0xFF, \n\t\t\t(newchars)\t\t& 0xFF);\n\t};\n\t\n\tlength = (out_array.length -= padLength);\n\t\n\t// Safari fromCharCode can't be passed more than 65536 arguments at once\n\tvar result,\n\t\tMAX_CHUNK = 65536;\n\t\n\tif (length > MAX_CHUNK) {\n\t\tresult = [];\n\t\tvar i = 0, j = 0;\n\t\twhile (i < length) {\n\t\t\tresult[j++] = String.fromCharCode.apply(String, out_array.slice(i, i + MAX_CHUNK));\n\t\t\ti += MAX_CHUNK;\n\t\t}\n\t\tresult = result.join('');\n\t} else {\n\t\tresult = String.fromCharCode.apply(String, out_array);\n\t}\n\tlogger.debug('decoded', result);\n\treturn result;\n};\n","pre":true},"net/env/node/csp/util.js":{"path":"net/env/node/csp/util.js","friendlyPath":".util","directory":"net/env/node/csp/","filename":"util.js","src":"/*\nHelper functions, &c., for a comet server by Jacob Rus.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// helper to test if string 2 is at the beginning of string 1\nexports.startswith = function (str1, str2) {\n\treturn str1.substring(0, str2.length) == str2;\n};\n\nexports.JSIOError = Class(Error, function () {\n\tthis.name = 'JSIOError';\n\tthis.toString = Error.prototype.toString;\n\tthis.init = function (message, fileName, lineNumber) {\n\t\tthis.name = this.name; // promote class property to instance\n\t\tthis.message = message || '';\n\t\tthis.fileName = fileName || '«filename»'; // location.href; // XXX what should go here?\n\t\tthis.lineNumber = isNaN(+lineNumber) ? 0 : +lineNumber\n\t};\n});\n\nexports.AssertionError = Class(exports.JSIOError, function (supr) {\n\tthis.name = 'AssertionError'\n\tthis.init = function () {supr(this, 'init', arguments)}\n});\n\nexports.assert = function (exp, message) {\n\tif (!exp) {\n\t\tthrow new exports.AssertionError(message)\n\t};\n};\n\n// schedule a callback to run at the next available moment,\n// equivalent to setTimeout(callback, 0)\nexports.reschedule = function (callback) {\n\treturn setTimeout(callback, 0);\n};\n\n// cached static files\nexports.staticFile = (function(){\n\tvar cache = {} // static file content indexed by filename\n\tvar getfile = function(path, callback) {\n\t\tcacheContent = cache[path];\n\t\tif (cacheContent !== undefined) {\n\t\t\t// the file is in the cache, return it\n\t\t\texports.reschedule(function(){\n\t\t\t\tcallback(null, [cacheContent]);\n\t\t\t});\n\t\t} else {\n\t\t\t// load file from disk, save it in the cache, and return it\n\t\t\tprocess.fs.readFile(path, 'utf8', function(err, fileContent){\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback('staticFile readFile error ' + err)\n\t\t\t\t} else {\n\t\t\t\t\tcache[path] = fileContent;\n\t\t\t\t\tcallback(null, [fileContent]);\n\t\t\t\t}\n\t\t\t})\n\t\t};\n\t\treturn promise;\n\t};\n\treturn getfile;\n})();\n","pre":true},"net/env/node/csp/proxy.js":{"path":"net/env/node/csp/proxy.js","friendlyPath":"jsio.net.env.node.csp.proxy","directory":"net/env/node/csp/","filename":"proxy.js","src":"/*\nMultiplexing socket proxy implemented against Node JS and my\nNode CSP server, by Jacob Rus.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\njsio('from .util import *');\njsio('from .server import csp')\n\n// msp = \"Multiplexing Socket Proxy\"\nvar msp = this.msp = exports;\n\n;(function () {\n\nvar frameTypes = ['open', 'close', 'data'];\nvar FRAME_OPENED = 0, FRAME_CLOSED = 1, FRAME_DATA = 2;\nvar errorCodes = {\n\tInvalidHandshake: 102,\n\tUserConnectionReset: 103,\n\tRemoteConnectionTimeout: 104,\n\tUnauthorized: 106,\n\tRemoteConnectionFailed: 108,\n\tRemoteConnectionClosed: 109,\n\tProtocolError: 110\n};\nmsp.ProxyConnection = Class(function() {\n\tthis.init = function (inConnection) {\n\t\tthis.inConnection = inConnection;\n\t\tthis.inBuffer = '';\n\t\tthis.outConnections = {};\n\t\tthis.inConnection\n\t\t\t.addListener('receive', bind(this, this.receiveData))\n\t\t\t.addListener('eof', bind(this, this.shutdown))\n\t\t\t.addListener('disconnect', bind(this, this.shutdown))\n\t\t\t.setEncoding('bytes');\t\n\t};\n\tthis.receiveData = function (data) {\n\t\tvar frameBegin;\n\t\tthis.inBuffer += data;\n\t\ttry {\n\t\t\twhile ((frameBegin = this.inBuffer.indexOf('[')) != -1) {\n\t\t\t\tvar frameEnd = parseInt(this.inBuffer.slice(0, frameBegin)) + frameBegin;\n\t\t\t\tassert (!isNaN(frameEnd), 'Invalid frame size prefix');\n\t\t\t\tif (this.inBuffer.length < frameEnd) {\n\t\t\t\t\tbreak; // whole frame hasn't arrived yet\n\t\t\t\t}\n\t\t\t\tvar frame = JSON.parse(this.inBuffer.slice(frameBegin, frameEnd));\n\t\t\t\tthis.inBuffer = this.inBuffer.slice(frameEnd) // remove frame from buffer\n\t\t\t\t// frame consists of connection id, frame type, arbitrary other arguments\n\t\t\t\tassert(frame instanceof Array && frame.length >= 2, 'Invalid frame');\n\t\t\t\tvar connectionId = frame.shift();\n\t\t\t\tvar frameType = frameTypes[frame.shift()];\n\t\t\t\tassert(frameType, 'Unrecognized frame type');\n\t\t\t\tvar args = frame; args.unshift(connectionId); // put back connection ID\n\t\t\t\tdispatchFrame[frameType].apply(this, args);\n\t\t\t};\n\t\t} catch (e) {\n\t\t\tdebug('PROTOCOL ERROR: ', (e.message || 'unknown error'));\n\t\t\tthis.shutdown(true);\n\t\t};\n\t};\n\tthis.shutdown = function (had_error) {\n\t\t// close all outgoing TCP connections\t\t\t \n\t\tfor (var connectionId in this.outConnections) {\n\t\t\tif (had_error) {\n\t\t\t\tthis.closeOutgoing(connectionId, 'ProtocolError');\n\t\t\t} else {\n\t\t\t\tthis.closeOutgoing(connectionId, 'UserConnectionReset');\n\t\t\t}\n\t\t\t// ???? this is not valid JS\n\t\t\t// var outConn = this.outConnections[connectionId];\n\t\t\t// outConn.listeners('connect') = [];\n\t\t\t// outConn.listeners('receive') = [];\n\t\t\t// outConn.listeners('eof') = [];\n\t\t\t// outConn.listeners('disconnect') = [];\n\t\t};\n\t};\n\tthis.send = function (frame) {\n\t\tpayload = JSON.stringify(frame);\n\t\tthis.inConnection.send(payload.length + ',' + payload, 'bytes');\n\t};\n\tthis.closeOutgoing = function (connectionId, errorType) {\n\t\tif (connectionId in this.outConnections) {\n\t\t\tvar code = errorCodes[errorType];\n\t\t\tthis.send([connectionId, FRAME_CLOSED, code]);\n\t\t\tthis.outConnections[connectionId].close();\n\t\t\tdelete this.outConnections[connectionId];\n\t\t};\n\t};\n\tthis.dispatchFrame = {\n\t\topen: function (connectionId, host, port) {\n\t\t\tassert(!(connectionId in this.outConnections), 'OPEN frame for existing connection');\n\t\t\tassert(host && port, 'Invalid host or port');\n\t\t\tvar outConn = this.outConnections[connectionId] = node.tcp.createConnection(port, host);\n\t\t\toutConn.setEncoding('bytes');\n\t\t\toutConn\n\t\t\t\t.addListener('connect', function () {\n\t\t\t\t\tthis.send([connectionId, FRAME_OPENED]);\n\t\t\t\t})\n\t\t\t\t.addListener('receive', function (data) {\n\t\t\t\t\tthis.send([connectionId, FRAME_DATA, data]);\n\t\t\t\t})\n\t\t\t\t.addListener('eof', function () {\n\t\t\t\t\tthis.closeOutgoing(connectionId, 'RemoteConnectionClosed');\n\t\t\t\t})\n\t\t\t\t.addListener('disconnect', function (had_error) {\n\t\t\t\t\tthis.closeOutgoing(connectionId, 'RemoteConnectionClosed');\n\t\t\t\t});\n\t\t},\n\t\tclose: function (connectionId) {\n\t\t\tthis.closeOutgoing(connectionId, 'UserConnectionReset');\n\t\t},\n\t\tdata: function (connectionId, data) {\n\t\t\tdata = unescape(data);\n\t\t\tthis.outConnections[connectionId].send(data, 'bytes');\n\t\t}\n\t};\t\n});\n\nmsp.Proxy = Class(function () {\n\tthis.init = function () {\n\t\tthis.cspserver = csp.createServer(function(connection) {\n\t\t\tproxyConnection = new msp.ProxyConnection(connection);\n\t\t});\n\t};\n\tthis.listen = function (port, host) {\n\t\tthis.cspserver.listen(port, host);\n\t};\n});\n\n})(); // end closure w/ code for msp\n\nfunction start_server () {\n\tvar server = new msp.Proxy();\n\tserver.listen(8050);\n\tlog(\"Proxying from http://:8050\");\n};\nstart_server();","pre":true},"net/env/node/socketio.js":{"path":"net/env/node/socketio.js","friendlyPath":"jsio.net.env.node.socketio","directory":"net/env/node/","filename":"socketio.js","src":"jsio('import ...interfaces');\n\nvar Transport = Class(interfaces.Transport, function() {\n\tthis.init = function(socket) {\n\t\tthis._socket = socket;\n\t\tlogger.debug('init', socket);\n\t}\n\n\tthis.makeConnection = function(protocol) {\n\t\tlogger.debug('makeConnection:', protocol);\n\t\tthis._socket.on(\"message\", bind(protocol, 'dataReceived'));\n\t\tthis._socket.on(\"disconnect\", bind(protocol, '_connectionLost'));\n\t}\n\n\tthis.write = function(data) {\n\t\tthis._socket.send(data);\n\t}\n\n\tthis.loseConnection = function() {\n\t\tthis._socket.close();\n\t}\n});\n\n/**\n * @extends net.interfaces.Listener\n */\nexports.Listener = Class(interfaces.Listener, function(supr) {\n\tthis.listen = function () {\n\t\tif (this._opts.port) {\n\t\t\t// if a port is provided, create an http server and host socket.io\n\t\t\t// at the specified port\n\t\t\tvar server = require('http').Server();\n\t\t\tserver.listen(this._opts.port);\n\t\t\tthis._ioServer = this._opts.io(server);\n\t\t} else if (this._opts.io) {\n\t\t\t// if an io server is already setup\n\t\t\tif (this._opts.namespace) {\n\t\t\t\t// use the url as a namespace\n\t\t\t\tthis._ioServer = this._opts.io.of(this._opts.namespace);\n\t\t\t} else {\n\t\t\t\tthis._ioServer = this._opts.io;\n\t\t\t}\n\t\t}\n\n\t\tif (this._ioServer) {\n\t\t\tthis._ioServer.on('connection', bind(this, '_onConnect'));\n\t\t} else {\n\t\t\tlogger.warn('socket.io not setup properly: please provide an io instance or an http port to the net.listen opts');\n\t\t}\n\t}\n\n\tthis._onConnect = function (socket) {\n\t\tlogger.info(\"Incoming connection\");\n\t\tthis.onConnect(new Transport(socket));\n\t}\n});\n","pre":true},"net/env/node/stdio.js":{"path":"net/env/node/stdio.js","friendlyPath":"jsio.net.env.node.stdio","directory":"net/env/node/","filename":"stdio.js","src":"jsio('import ...interfaces');\n\nvar Transport = Class(interfaces.Transport, function(supr) {\n    this.init = function(inStream, outStream) {\n        this._inStream = inStream;\n        this._outStream = outStream;\n        this.setEncoding('plain')\n    }\n\n    this.setEncoding = function(encoding) {\n        supr(this, 'setEncoding', arguments);\n        if (encoding == 'plain') {\n            encoding = 'binary';\n        }\n        this._inStream.setEncoding(encoding);\n        this._outStream.setEncoding(encoding);\n    }\n\n    this.makeConnection = function(protocol) {\n        this._inStream.on('data', bind(protocol, 'dataReceived'));\n\t\tthis._inStream.on('end', bind(protocol, 'connectionLost'));\n    }\n\n    this.write = function(data) {\n        this._outStream.write(data);\n        this._outStream.flush();\n    }\n\n    this.loseConnection = function() {\n    }\n});\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector = Class(interfaces.Connector, function() {\n    this.connect = function() {\n        var stdin = process.openStdin();\n        var stdout = process.stdout\n        var transport = new Transport(stdin, stdout)\n        this.onConnect(transport);\n    }\n});\n","pre":true},"net/env/node/tcp.js":{"path":"net/env/node/tcp.js","friendlyPath":"jsio.net.env.node.tcp","directory":"net/env/node/","filename":"tcp.js","src":"jsio('import ...interfaces');\nvar net = require('net');\n\nvar Transport = Class(interfaces.Transport, function() {\n\tthis.init = function(socket) {\n\t\tthis._socket = socket;\n\t}\n\n\tthis.makeConnection = function(protocol) {\n\t\tthis._socket.addListener(\"data\", bind(protocol, 'dataReceived'));\n\t\tthis._socket.addListener(\"close\", bind(protocol, 'connectionLost')); // TODO: map error codes\n\t}\n\n\tthis.write = function(data) {\n\t\tthis._socket.write(data);\n\t}\n\n\tthis.loseConnection = function() {\n\t\tthis._socket.end();\n\t}\n});\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector = Class(interfaces.Connector, function() {\n\tthis.connect = function() {\n\n\t\tvar conn = net.createConnection(this._opts.port, this._opts.host);\n\t\tconn.addListener(\"connect\", bind(this, function() {\n\t\t\tthis.onConnect(new Transport(conn));\n\t\t}))\n//\t\tconn.addListener(\"close\", bind(this, function() {\n//\t\t\tthis.onDisconnect();\n//\t\t}))\n//\t\tconn.addListener(\"receive\", bind(this._protocol, 'dataReceived'));\n\t\tthis._opts.encoding = 'plain';\n\t\tconn.setEncoding(\"binary\");\n\t\tif (typeof this._opts.timeout == 'number') { conn.setTimeout(this._opts.timeout); }\n\t}\n});\n\n/**\n * @extends net.interfaces.Listener\n */\nexports.Listener = Class(interfaces.Listener, function(supr) {\n\tthis.listen = function() {\n\t\tvar s = net.createServer(bind(this, function(socket) {\n\t\t\tif (typeof this._opts.timeout == 'number') {\n\t\t\t\tsocket.setTimeout(this._opts.timeout)\n\t\t\t}\n\n\t\t\tsocket.setEncoding(\"utf8\");\n\t\t\tthis.onConnect(new Transport(socket));\n\t\t}));\n\n\t\tvar listenString = (this._opts['interface'] || \"\") + \":\" + this._opts.port;\n\t\t// TODO: Show class name\n\t\tlogger.info(\"Listening tcp@\" + listenString);\n\t\ts.listen(this._opts.port, this._opts['interface'] || \"\")\n\t\t\t.on('error', bind(this, function (err) {\n\t\t\t\tlogger.error(err);\n\t\t\t\tthis.emit('error', err);\n\t\t\t}));\n\t}\n});\n","pre":true},"net/protocols/Cuppa.js":{"path":"net/protocols/Cuppa.js","friendlyPath":"jsio.net.protocols.Cuppa","directory":"net/protocols/","filename":"Cuppa.js","src":"jsio('import jsio.lib.Callback');\njsio('import jsio.lib.PubSub');\n\njsio('from .rtjp import RTJPProtocol');\n\nvar Error = Class(function() {\n\tthis.init = function(protocol, id, msg, details, requestId) {\n\t\tthis.id = id;\n\t\tthis.msg = msg;\n\t\tthis.details = details;\n\t\tthis.requestId = requestId;\n\t}\n});\n\nvar RPCRequest = Class(function() {\n\tthis.init = function(protocol, id) {\n\t\tthis.protocol = protocol;\n\t\tthis.id = id;\n\t\tthis._onError = new lib.Callback();\n\t\tthis._onSuccess = new lib.Callback();\n\t}\n\n\tthis.onError = function() { this._onError.forward(arguments); }\n\tthis.onSuccess = function() { this._onSuccess.forward(arguments); }\n\n\tthis.bindLater = function(l) {\n\t\tvar args = [].slice(arguments, 1);\n\t\tthis._onError.forward([l, l.fail].concat(args));\n\t\tthis._onSuccess.forward([l, l.succed].concat(args));\n\t\treturn l;\n\t}\n\n\n});\n\nvar ReceivedRequest = Class(function() {\n\tthis.type = \"request\"\n\n\tthis.init = function(protocol, id, name, args, target) {\n\t\tthis.protocol = protocol\n\t\tthis.id = id;\n\t\tthis.name = name\n\t\tthis.responded = false;\n\t\tthis.args = args;\n\t\tthis.target = target;\n\t}\n\n\tthis.error = function(msg, details) {\n\t\tif (this.responded) { throw new Error(\"already responded\"); }\n\t\tif (this._timer) {\n\t\t\tclearTimeout(this._timer);\n\t\t\tthis._timer = null;\n\t\t}\n\t\targs = {\n\t\t\tid: this.id,\n\t\t\tmsg: msg + \"\"\n\t\t}\n\t\tif (details !== undefined) { args.details = details }\n\t\tthis.responded = true;\n\t\tthis.protocol.sendFrame('ERROR', args);\n\t}\n\n\tthis.respond = function(args) {\n\t\tif (this.responded) { throw new Error(\"already responded\"); }\n\t\tif (this._timer) {\n\t\t\tclearTimeout(this._timer);\n\t\t\tthis._timer = null;\n\t\t}\n\t\tthis.responded = true;\n\t\tthis.protocol.sendFrame('RESPONSE', {\n\t\t\tid: this.id,\n\t\t\targs: args == undefined ? {} : args // python cuppa ignores responses with undefined args\n\t\t});\n\t}\n\n\tthis.timeoutAfter = function(duration, msg) {\n\t\tif (this.responded) { return; }\n\t\tif (this._timer) { clearTimeout(this._timer); }\n\t\tthis._timer = setTimeout(bind(this, '_timeout', msg), duration);\n\t}\n\n\tthis._timeout = function(msg) {\n\t\tif (!this.responded) {\n\t\t\tthis.error(msg);\n\t\t}\n\t}\n\n});\n\nvar ReceivedEvent = Class(function() {\n\tthis.init = function(protocol, id, name, args, target) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tthis.target = target;\n\t}\n});\n\n/**\n * @extends net.protocols.rtjp.RTJPProtocol;\n */\nexports = Class(RTJPProtocol, function(supr) {\n\tthis.init = function() {\n\t\tsupr(this, 'init', arguments);\n\n\t\tthis._onConnect = new lib.Callback();\n\t\tthis._onDisconnect = new lib.Callback();\n\n\t\tthis._requests = {};\n\n\t\tthis.onEvent = new lib.PubSub();\n\t\tthis.onRequest = new lib.PubSub();\n\t}\n\n\tthis.disconnect = function() { this.transport.loseConnection(); }\n\n\t// pass something to call (ctx, method, args...) when connected\n\tthis.onConnect = function() { this._onConnect.forward(arguments); }\n\tthis.onDisconnect = function() { this._onDisconnect.forward(arguments); }\n\n\tthis.reset = function() {\n\t\tthis._onConnect.reset();\n\t\tthis._onDisconnect.reset();\n\t}\n\n\t// called when we're connected\n\tthis.connectionMade = function() {\n\t\tthis._isConnected = true;\n\t\tthis._onConnect.fire();\n\t}\n\n\tthis.connectionLost = function(err) {\n\t\tfor (var i in this._requests) {\n\t\t\tvar req = this._requests[i];\n\t\t\tdelete this._requests[i];\n\t\t\treq._onError.fire(err);\n\t\t}\n\n\t\tthis._isConnected = false;\n\t\tthis._onDisconnect.fire(err);\n\t}\n\n\tthis.sendRequest = function(name, args, target, cb) {\n\t\tif (arguments.length > 4) { // allow bound functions (e.g. [this, 'onResponse', 123])\n\t\t\tcb = bind.apply(GLOBAL, Array.prototype.slice.call(arguments, 3));\n\t\t}\n\n\t\tvar frameArgs = {\n\t\t\tname: name,\n\t\t\targs: args\n\t\t};\n\n\t\tif (target) { frameArgs.target = target; }\n\n\t\tvar id = this.sendFrame('RPC', frameArgs),\n\t\t\treq = this._requests[id] = new RPCRequest(this, id);\n\n\t\tif (cb) {\n\t\t\treq.onSuccess(GLOBAL, cb, false); // will call cb(false, args...)\n\t\t\treq.onError(GLOBAL, cb); // will call cb(err)\n\t\t}\n\n\t\treturn req;\n\t}\n\n\tthis.sendEvent = function(name, args, target) {\n\t\tthis.sendFrame('EVENT', {name: name, args: args, target: target || null});\n\t}\n\n\tthis.frameReceived = function(id, name, args) {\n\t\tlogger.debug('RECEIVED', id, name, args);\n\t\tswitch(name.toUpperCase()) {\n\t\t\tcase 'RESPONSE':\n\t\t\t\tvar req = this._requests[args.id];\n\t\t\t\tif (!req) { return; }\n\t\t\t\tdelete this._requests[args.id];\n\t\t\t\treq._onSuccess.fire(args.args);\n\t\t\t\tbreak;\n\t\t\tcase 'ERROR':\n\t\t\t\tvar msg = args.msg || 'unknown',\n\t\t\t\t\trequestId = args.id,\n\t\t\t\t\treq = this._requests[requestId],\n\t\t\t\t\terr = new Error(this, id, msg, args.details, requestId);\n\n\t\t\t\tif (!req) {\n\t\t\t\t\treturn this.errorReceived && this.errorReceived(err);\n\t\t\t\t} else {\n\t\t\t\t\tdelete this._requests[requestId];\n\t\t\t\t\treq._onError.fire(err);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'RPC':\n\t\t\tcase 'EVENT':\n\t\t\t\tif (!args.name) {\n\t\t\t\t\treturn self.sendFrame('ERROR', { 'id': args.id || id, 'msg': 'missing \"name\"' });\n\t\t\t\t}\n\t\t\t\tvar frameArgs = args.args || {},\n\t\t\t\t\ttarget = args.target || null,\n\t\t\t\t\tisRPC = name.toUpperCase() == 'RPC',\n\t\t\t\t\treqCtor = isRPC ? ReceivedRequest : ReceivedEvent,\n\t\t\t\t\tpubTarget = isRPC ? this.onRequest : this.onEvent,\n\t\t\t\t\treq = new reqCtor(this, args.id || id, args.name, frameArgs, target);\n\n\t\t\t\tpubTarget.publish(req.name, req);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n","pre":true},"net/protocols/rtjp.js":{"path":"net/protocols/rtjp.js","friendlyPath":".rtjp","directory":"net/protocols/","filename":"rtjp.js","src":"jsio('from .delimited import DelimitedProtocol');\n\n/**\n * @extends net.protocols.delimited.DelimitedProtocol\n */\nexports.RTJPProtocol = Class(DelimitedProtocol, function(supr) {\n\tthis.init = function() {\n\t\tvar delimiter = '\\r\\n';\n\t\tsupr(this, 'init', [delimiter]);\n\t\tthis.frameId = 0;\n\t}\n\n\tthis.connectionMade = function() {\n\t\tif (this._client && this._client.connectionMade) { this._client.connectionMade(); }\n\t\tlogger.debug(\"connectionMade\");\n\t}\n\n\tvar error = function(e) {\n\t\tlogger.error(e);\n\t}\n\n\t// Inherit and overwrite\n\tthis.frameReceived = function(id, name, args) {\n\t}\n\n\t// Public\n\tthis.sendFrame = function(name, args) {\n\t\tif (!args) {\n\t\t\targs = {}\n\t\t}\n\t\tlogger.debug('sendFrame', name, JSON.stringify(args));\n\t\tthis.sendLine(JSON.stringify([++this.frameId, name, args]));\n\t\treturn this.frameId;\n\t}\n\n\tthis.lineReceived = function(line) {\n\t\ttry {\n\t\t\tvar frame = JSON.parse(line);\n\t\t\tif (frame.length != 3) {\n\t\t\t\treturn error.call(this, \"Invalid frame length\");\n\t\t\t}\n\t\t\tif (typeof(frame[0]) != \"number\") {\n\t\t\t\treturn error.call(this, \"Invalid frame id\");\n\t\t\t}\n\t\t\tif (typeof(frame[1]) != \"string\") {\n\t\t\t\treturn error.call(this, \"Invalid frame name\");\n\t\t\t}\n\t\t\tlogger.debug(\"frameReceived:\", frame[0], frame[1], JSON.stringify(frame[2]));\n\t\t} catch(e) {\n\t\t\terror.call(this, e);\n\t\t}\n\n\t\tif (frame) {\n\t\t\tthis.frameReceived(frame[0], frame[1], frame[2]);\n\t\t}\n\t}\n\n\tthis.connectionLost = function() {\n\t\tlogger.debug('conn lost');\n\t}\n});\n\n\n\n","pre":true},"net/protocols/delimited.js":{"path":"net/protocols/delimited.js","friendlyPath":".delimited","directory":"net/protocols/","filename":"delimited.js","src":"jsio('import ..interfaces');\n\n/**\n * @extends net.interfaces.Protocol\n */\nexports.DelimitedProtocol = Class(interfaces.Protocol, function(supr) {\n\n\tthis.init = function(delimiter) {\n\t\tif (!delimiter) {\n\t\t\tdelimiter = '\\r\\n'\n\t\t}\n\t\tthis.delimiter = delimiter;\n\t\tthis.buffer = \"\"\n\t}\n\n\tthis.connectionMade = function() {\n\t\tlogger.debug('connectionMade');\n\t}\n\n\tthis.dataReceived = function(data) {\n\t\tif (!data) { return; }\n\t\tlogger.debug('dataReceived:', data.length, data);\n\t\tthis.buffer += data;\n\t\tvar i;\n\t\twhile ((i = this.buffer.indexOf(this.delimiter)) != -1) {\n\t\t\tvar line = this.buffer.slice(0, i);\n\t\t\tthis.buffer = this.buffer.slice(i + this.delimiter.length);\n\t\t\tthis.lineReceived(line);\n\t\t}\n\t}\n\n\tthis.lineReceived = function(line) {\n\t\tlogger.debug('Not implemented, lineReceived:', line);\n\t}\n\tthis.sendLine = function(line) {\n\t\tvar data = line + this.delimiter;\n\t\tlogger.debug('WRITE:', data);\n\t\tthis.transport && this.transport.write(data);\n\t}\n\tthis.connectionLost = function() {\n\t\tlogger.debug('connectionLost');\n\t}\n});\n\n","pre":true},"net/protocols/buffered.js":{"path":"net/protocols/buffered.js","friendlyPath":"jsio.net.protocols.buffered","directory":"net/protocols/","filename":"buffered.js","src":"jsio('from net.interfaces import Protocol');\njsio('from net.buffer import Buffer');\n\n/**\n * @extends net.interfaces.Protocol\n */\nexports.BufferedProtocol = Class(Protocol, function(supr) {\n\n\tthis.init = function() {\n\t\tthis.buffer = new Buffer();\n\t}\n\n\t// Overwrite this instead of dataReceived in base classes\n\tthis.bufferUpdated = function() {}\n\n\tthis.dataReceived = function(data) {\n\t\tthis.buffer.append(data);\n\t\tthis.bufferUpdated();\n\t}\n\n})","pre":true},"net/protocols/echo.js":{"path":"net/protocols/echo.js","friendlyPath":"jsio.net.protocols.echo","directory":"net/protocols/","filename":"echo.js","src":"jsio('import net.interfaces');\n\n/**\n * @extends net.interfaces.Protocol\n */\nexports.Protocol = Class(net.interfaces.Protocol, function() {\n\tthis.connectionMade = function() {\n\t\tlogger.debug('in connectionMade');\n\t\tthis.transport.write('Welcome')\n\t}\n\t\n\tthis.dataReceived = function(data) {\n\t\tlogger.debug('dataReceived:', data);\n\t\tthis.transport.write('Echo: ' + data);\n\t}\n\tthis.connectionLost = function() {\n\t\tlogger.debug('conn lost');\n\t}\n});\n\nexports.Server = Class(net.interfaces.Server, function(supr) {\n\tthis.init = function() {\n\t\tsupr(this, 'init', [exports.Protocol]);\n\t}\n});\n\n","pre":true},"net/protocols/mspp.js":{"path":"net/protocols/mspp.js","friendlyPath":"jsio.net.protocols.mspp","directory":"net/protocols/","filename":"mspp.js","src":"jsio('import net');\njsio('from net.protocols.buffered import BufferedProtocol');\njsio('import std.utf8 as utf8');\n\n/*\nworks like this:\nOPEN\nupstream:\nlength_after_colon:id,0host,port\n\ndownstream:\nlength_after_colon:id,0\n-----\nCLOSE\nupstream:\nlength_after_colon:id,1\n\ndownstream:\nlength_after_colon:id,1errcode\n-----\nDATA\nupstream/downstream:\nlength_after_colon:id,2datadatadata\n*/\n\nvar loggers = {};\nloggers.stream = logging.get('MSPPStream');\nloggers.protocol = logging.get('MSPPProtocol');\n\nvar frames = {\n\t'OPEN':  0,\n\t'CLOSE': 1,\n\t'DATA':  2\n};\n\nexports.MSPPStream = Class(function() {\n\tthis.setMultiplexer = function(multiplexer) {\n\t\tloggers.stream.debug('setMultiplexer: '+multiplexer);\n\t\tthis.multiplexer = multiplexer;\n\t}\n\n\tthis.setEncoding = function(encoding) {\n\t\tloggers.stream.debug('setEncoding: '+encoding);\n\t\tthis.encoding = encoding;\n\t}\n\n\tthis.open = function(host, port, isBinary) {\n\t\tif (isBinary)\n\t\t\tthis.encoding = 'utf8';\n\t\tthis.id = this.multiplexer.openStream(this, host, port);\n\t\tloggers.stream.debug('open '+this.id+\": \"+host+\" \"+port+\" \"+isBinary);\n\t}\n\n\tthis.close = function() {\n\t\tloggers.stream.debug('close '+this.id);\n\t\tthis.multiplexer.close(this.id);\n\t}\n\n\tthis.send = function(data, encoding) {\n\t\tloggers.stream.debug('send '+this.id+\": \"+data+\" \"+encoding);\n\t\tif ((encoding || this.encoding) == 'utf8')\n\t\t\tdata = utf8.encode(data);\n\t\tthis.multiplexer.writeToStream(this.id, data);\n\t}\n\n\tthis._onreadraw = function(data) {\n\t\tif (this.encoding == 'utf8') {\n\t\t\tvar raw = utf8.decode(data);\n\t\t\tvar length = raw[1];\n\t\t\t// TODO: actually buffer this stuff properly\n\t\t\tif (length != data.length) {\n\t\t\t\tthrow new Error(\"Incomplete utf8 codepoint\");\n\t\t\t}\n\t\t\tdata = raw[0]\n\t\t}\n\t\tloggers.stream.debug('_onreadraw '+data);\n\t\tthis.onread(data);\n\t}\n\n\tthis.onopen = function() {}\n\tthis.onclose = function(err) {}\n\tthis.onread = function(data) {}\n});\n\nvar state = {};\nstate.closed = 0;\nstate.connecting = 1;\nstate.consuming = 2;\n\n/**\n * @extends net.protocols.buffered.BufferedProtocol\n */\nexports.MSPPProtocol = Class(BufferedProtocol, function(supr) {\n\tthis.init = function() {\n\t\tloggers.protocol.debug('new MSPPProtocol');\n\t\tsupr(this, 'init', []);\n\t\tthis.state = state.closed;\n\t\tthis.transportType = null;\n\t\tthis.transportOptions = null;\n\t\tthis.currentId = 0;\n\t\tthis.streams = {};\n\t\tthis.writeBuffer = [];\n\t}\n\n\tthis.setTransport = function(transportType, transportOptions) {\n\t\tthis.transportType = transportType;\n\t\tthis.transportOptions = transportOptions;\n\t}\n\n\tthis.connectionMade = function(isReconnect) {\n\t\tloggers.protocol.debug('connectionMade');\n\t\tthis.state = state.consuming;\n\t\tfor (var i = 0; i < this.writeBuffer.length; i++)\n\t\t\tthis._write(this.writeBuffer[i]);\n\t\twriteBuffer = [];\n\t}\n\n\tthis.connectionLost = function(reason) {\n\t\tloggers.protocol.debug('closed: '+reason);\n\t\tthis.state = state.closed;\n\t\tfor (var stream in this.streams)\n\t\t\tthis.streams[stream].onclose(reason);\n\t}\n\n\tthis.openStream = function(stream, host, port) {\n\t\tif (this.state == state.closed) {\n\t\t\tthis.state = state.connecting;\n\t\t\tnet.connect(this, this.transportType, this.transportOptions);\n\t\t}\n\t\tvar id = ++this.currentId;\n\t\tthis.streams[id] = stream;\n\t\tthis._write([id, frames.OPEN, host+\",\"+port]);\n\t\treturn id;\n\t}\n\n\tthis.closeStream = function(id) {\n\t\tthis._write([id, frames.CLOSE, \"\"]);\n\t}\n\n\tthis.writeToStream = function(id, data) {\n\t\tthis._write([id, frames.DATA, data]);\n\t}\n\n\tthis.bufferUpdated = function() {\n\t\tloggers.protocol.debug(\"bufferUpdated. state: \"+this.state+\". buffer: \"+this.buffer._rawBuffer);\n\t\tif (this.state != state.consuming)\n\t\t\tthrow new Error(\"buffer update in invalid MSPP state: \"+this.state);\n\t\tif (! this.buffer.hasDelimiter(':'))\n\t\t\treturn;\n\t\tvar lStr = this.buffer.peekToDelimiter(':');\n\t\tvar len = parseInt(lStr);\n\t\tif (! this.buffer.hasBytes(len + lStr.length + 1))\n\t\t\treturn;\n\t\tthis.buffer.consumeThroughDelimiter(':');\n\t\tvar streamId = this.buffer.consumeToDelimiter(',');\n\t\tthis.buffer.consumeBytes(1);\n\t\tvar frameType = parseInt(this.buffer.consumeBytes(1));\n\t\tlen -= (streamId.length + 2);\n\t\tstreamId = parseInt(streamId);\n\t\tvar data = this.buffer.consumeBytes(len);\n\t\tswitch(frameType) {\n\t\t\tcase frames.OPEN:\n\t\t\t\tthis.streams[streamId].onopen();\n\t\t\t\tbreak;\n\t\t\tcase frames.CLOSE:\n\t\t\t\tthis.streams[streamId].onclose(data);\n\t\t\t\tbreak;\n\t\t\tcase frames.DATA:\n\t\t\t\tthis.streams[streamId]._onreadraw(data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('invalid MSPP data type!');\n\t\t}\n\t}\n\n\tthis._write = function(data) {\n\t\tif (this.state != state.consuming) {\n\t\t\tloggers.protocol.debug(\"buffering write: \"+data);\n\t\t\tthis.writeBuffer.push(data);\n\t\t\treturn;\n\t\t}\n\t\tvar s = data[0] + \",\" + data[1] + data[2];\n\t\ts = s.length + \":\" + s;\n\t\tloggers.protocol.debug('write: '+s);\n\t\tthis.transport.write(s);\n\t}\n});\n","pre":true},"net/protocols/stomp.js":{"path":"net/protocols/stomp.js","friendlyPath":"jsio.net.protocols.stomp","directory":"net/protocols/","filename":"stomp.js","src":"jsio('from net.protocols.buffered import BufferedProtocol');\njsio('from util.sprintf import sprintf');\n\n/**\n * @extends net.protocols.buffered.BufferedProtocol\n */\nexports.StompProtocol = Class(BufferedProtocol, function(supr) {\n\n\tthis.init = function() {\n\t\tsupr(this, 'init', []);\n\t\tthis.state = 'peek';\n\t}\n\n\tthis.connect = function(username, password) {\n\t\tvar frame = new StompFrame('CONNECT')\n\t\tif (!!username)\n\t\t\tframe.setHeader('login', username);\n\t\tif (!!password)\n\t\t\tframe.setHeader('passcode', password);\n\t\tthis.sendFrame(frame);\n\t}\n\n\tthis.send = function(destination, body, headers) {\n\t\tvar frame = new StompFrame('SEND', body, headers)\n\t\tframe.setHeader('destination', destination);\n\t\tthis.sendFrame(frame);\n\t}\n\n\tthis.subscribe = function(destination, headers) {\n\t\tvar frame = new StompFrame('SUBSCRIBE', null, headers)\n\t\tframe.setHeader('destination', destination);\n\t\tthis.sendFrame(frame);\n\t}\n\tthis.unsubscribe = function(destination, headers) {\n\t\tvar frame = new StompFrame('UNSUBSCRIBE', null, headers)\n\t\tframe.setHeader('destination', destination);\n\t\tthis.sendFrame(frame);\n\t}\n\n\tthis.sendFrame = function(frame) {\n\t\tthis.transport.write(frame.serialize());\n\t}\n\n\tthis.frameReceived = function(frame) {\n\t\tlogger.info('frame received', frame);\n\t}\n\t\n\tthis.bufferUpdated = function() {\n\t\tlogger.debug('bufferUpdated');\n\t\tvar counter = 0;\n\t\twhile (++counter < 10) {\n\t\t\tswitch(this.state) {\n\t\t\t\tcase 'peek':\n\t\t\t\t\tif (this.buffer.peekBytes(1) == '\\n') {\n\t\t\t\t\t\tlogger.debug('consuming a single \\n byte')\n\t\t\t\t\t\tthis.buffer.consumeBytes(1)\n\t\t\t\t\t}\n\t\t\t\t\tthis.state = 'method';\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tcase 'method':\n\t\t\t\t\tlogger.debug('case method');\n\t\t\t\t\t// Fix for stomp servers that send extra \\n byte\n\t\t\t\t\tif (!this.buffer.hasLine())\n\t\t\t\t\t\treturn;\n\t\t\t\t\tthis._frame = new StompFrame();\n\t\t\t\t\tvar method = this.buffer.consumeThroughDelimiter();\n\t\t\t\t\tlogger.debug('method is', JSON.stringify(method));\n\t\t\t\t\tthis._frame.setMethod(method);\n\t\t\t\t\tthis.state = 'headers';\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tcase 'headers':\n\t\t\t\t\tlogger.debug('case headers');\n\t\t\t\t\tvar M = 0;\n\t\t\t\t\twhile (this.buffer.hasLine() && ++M < 10) {\n\t\t\t\t\t\tvar line = this.buffer.consumeThroughDelimiter();\n\t\t\t\t\t\tif (line.length == 0) {\n\t\t\t\t\t\t\tthis.state = 'body';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar segments = line.split(':')\n\t\t\t\t\t\tvar key = segments[0];\n\t\t\t\t\t\t// I guess we allow \": \" in the header value.\n\t\t\t\t\t\tvar value = segments.slice(1).join(':')\n\t\t\t\t\t\twhile (value[0] == ' ') value = value.slice(1);\n\t\t\t\t\t\twhile (value[1] == ' ') value = value.slice(0, value.length-1);\n\t\t\t\t\t\tlogger.debug('add header', key, value);\n\t\t\t\t\t\tthis._frame.setHeader(key, value);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.state == 'headers')\n\t\t\t\t\t\treturn;\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tcase 'body':\n\t\t\t\t\tif (this._frame.getBodyMode() == 'length') {\n\t\t\t\t\t\tif (!this.buffer.hasBytes(this._frame.getContentLength()+1))\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\tthis._frame.setBody(this.buffer.consumeBytes(this._frame.getContentLength()))\n\t\t\t\t\t\t// Remove trailing \\x00\n\t\t\t\t\t\tthis.buffer.consumeBytes(1)\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.buffer.hasLine('\\x00'))\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\tthis._frame.setBody(this.buffer.consumeThroughDelimiter('\\x00'));\n\t\t\t\t\t}\n\t\t\t\t\tthis.frameReceived(this._frame);\n\t\t\t\t\tthis._frame = null;\n\t\t\t\t\tthis.state = 'peek';\n\t\t\t\t\t/* FALL THROUGH and LOOP */\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n})\n\nvar StompFrame = exports.StompFrame = Class(function() {\n\n\tthis.init = function(_method, _body, _headers) {\n\t\tthis._headers = !!_headers ? _headers : {}\n\t\tthis._method = !!_method ? _method : null\n\t\tthis._body = !!_body ? _body : \"\";\n\t}\n\tthis.setHeader = function(key, val) {\n\t\tthis._headers[key] = val;\n\t}\n\tthis.getHeader = function(key) {\n\t\treturn this._headers[key];\n\t}\n\tthis.getHeaders = function() {\n\t\treturn this._headers;\n\t}\n\tthis.setMethod = function(m) {\n\t\t// TODO: enforce method constraints here?\n\t\t//\t   -mcarter 9/18/09\n\t\tthis._method = m;\n\t}\n\tthis.getMethod = function() {\n\t\treturn this._method;\n\t}\n\tthis.setBody = function(b) {\n\t\tthis._body = b;\n\t}\n\tthis.getbody = function() {\n\t\treturn this._body;\n\t}\n\tthis.toString = function() {\n\t\tvar i = 0;\n\t\tfor (var key in this._headers) {\n\t\t\t++i;\n\t\t}\n\t\treturn sprintf(\"[StompFrame method(%s), num-headers(%d), body-length(%d)]\", \n\t\t\t\t\t   this._method, i, this._body.length);\n\t}\n\tthis.getContentLength = function() {\n\t\treturn parseInt(this._headers['content-length']);\n\t}\n\tthis.getBodyMode = function() {\n\t\tif ('content-length' in this._headers) {\n\t\t\treturn 'length';\n\t\t}\n\t\treturn 'delimited';\n\t}\n\tthis.serialize = function() {\n\t\tvar output = this._method + '\\n'\n\t\tfor (var key in this._headers) {\n\t\t\toutput += key + ': ' + this._headers[key] + '\\n';\n\t\t}\n\t\toutput += 'content-length: ' + this._body.length + '\\n';\n\t\toutput += '\\n';\n\t\toutput += this._body;\n\t\toutput += '\\x00'\n\t\treturn output;\n\t}\n});\n","pre":true},"net/__imports__.js":{"path":"net/__imports__.js","friendlyPath":"jsio.net.__imports__","directory":"net/","filename":"__imports__.js","pre":true,"src":"exports.map = {\n\t'node': [\n\t\t'net.env.node.stdio'\n\t],\n\t'browser': [\n\t\t'net.env.browser.csp',\n\t\t'net.env.browser.postmessage',\n\t\t'net.env.browser.websocket',\n\t\t'net.env.browser.socketio'\n\t],\n\t'mobile': []\n}\n\nexports.resolve = function(env, opts) {\n\treturn exports.map[env] || [];\n};\n"},"net/buffer.js":{"path":"net/buffer.js","friendlyPath":"jsio.net.buffer","directory":"net/","filename":"buffer.js","src":"jsio('from net.interfaces import Protocol');\n\nvar EmptyBufferError = exports.EmptyBufferError = Class(function () {\n\tthis.init = function(message) { this.message = message; }\n})\n\nexports.Buffer = Class(function(supr) {\n\n\tthis.init = function(rawBuffer) {\n\t\t\n\t\tthis._rawBuffer = !!rawBuffer ? rawBuffer : \"\";\n\t}\n\n\tthis.getLength = function() {\n\t\treturn this._rawBuffer.length;\n\t}\n\n\tthis.append = function(data) {\n\t\tlogger.debug('append', JSON.stringify(data));\n\t\tthis._rawBuffer += data;\n\t}\n\n\tthis.peekBytes = function(num) {\n\t\tif (!!num)\n\t\t\treturn this._rawBuffer.slice(0, num);\n\t\telse \n\t\t\treturn this._rawBuffer;\n\t}\n\n\tthis.peekToDelimiter = function(delimiter) {\n\t\tdelimiter = delimiter ? delimiter : '\\n';\n\t\tvar i = this._rawBuffer.indexOf(delimiter);\n\t\tif (i == -1)\n\t\t\tthrow new EmptyBufferError(\"delimiter \" + delimiter + \"not present in buffer\");\n\t\telse\n\t\t\treturn this._rawBuffer.slice(0, i);\n\t}\n\n\tthis.consumeBytes = function(num) {\n\t\tvar output = this.peekBytes(num);\n\t\tthis._rawBuffer = this._rawBuffer.slice(output.length);\n\t\treturn output;\n\t}\n\tthis.consumeMaxBytes = function(num) {\n\t\tvar output = this._rawBuffer.slice(0, num);\n\t\tthis._rawBuffer = this._rawBuffer(num);\n\t\treturn output;\n\t}\n\tthis.consumeAllBytes = function() {\n\t\tvar temp = this._rawBuffer;\n\t\tthis._rawBuffer = \"\";\n\t\treturn temp;\n\t}\n\t\n\tthis.consumeThroughDelimiter = function(delimiter) {\n\t\treturn this.consumeToDelimiter(delimiter) + this.consumeBytes(delimiter.length);\n\t}\n\n\tthis.consumeToDelimiter = function(delimiter) {\n\t\tdelimiter = !!delimiter ? delimiter : \"\\n\"\n\t\tvar output = this.peekToDelimiter(delimiter);\n\t\tthis._rawBuffer = this._rawBuffer.slice(output.length);\n\t\treturn output;\n\t}\n\n\tthis.hasBytes = function(num) {\n\t\tnum = num ? num : 0;\n\t\treturn this._rawBuffer.length >= num;\n\t}\n\n\tthis.hasDelimiter = function(delimiter) {\n\t\tdelimiter = !!delimiter ? delimiter : '\\n';\n\t\treturn (this._rawBuffer.indexOf(delimiter) != -1);\n\t}\n\n})\n","pre":true},"net/errors.js":{"path":"net/errors.js","friendlyPath":"jsio.net.errors","directory":"net/","filename":"errors.js","src":"var makeErrorClass = function(name, _code) {\n\tvar toString = function() {\n\t\treturn name + (this.message ? ': ' + this.message : '');\n\t}\n\n\tvar ctor = function(data) {\n\t\tif (typeof data == 'string') {\n\t\t\tthis.message = data;\n\t\t} else {\n\t\t\tthis.data = data;\n\t\t}\n\t}\n\t\n\tctor.prototype = {\n\t\ttype: name,\n\t\ttoString: toString\n\t};\n\t\n\treturn ctor;\n}\n\nexports.ReadyStateError = makeErrorClass(\"ReadyStateError\");\nexports.InvalidEncodingError = makeErrorClass(\"InvalidEncodingError\");\nexports.ExpiredSession = makeErrorClass(\"ExpiredSession\");\n\nexports.ServerUnreachable = makeErrorClass(\"ServerUnreachable\", 100);\nexports.ConnectionTimeout = makeErrorClass(\"ConnectionTimeout\", 101);\n\nexports.ServerProtocolError = makeErrorClass(\"ServerProtocolError\", 200);\n\nexports.ServerClosedConnection = makeErrorClass(\"ServerClosedConnection\", 301);\nexports.ConnectionClosedCleanly = makeErrorClass(\"ConnectionClosedCleanly\", 300);","pre":true},"net/later.js":{"path":"net/later.js","friendlyPath":"jsio.net.later","directory":"net/","filename":"later.js","src":"exports.Later = Class(function() {\n\tthis.init = function() {\n\t\tthis.cb = null\n\t\tthis.eb = null\n\t\tthis.values = []\n\t\tthis.errors = []\n\t\tthis.cancelback = null;\n\t}\n\t\n\tthis.succeed = this.callback = function() {\n\t\tlogger.debug('callback', [].slice.call(arguments, 0));\n\t\tif (this.cb) {\n\t\t\tvar result = this.cb.apply(this, arguments);\n\t\t\tif (result == false) {\n\t\t\t\tthis.cancel();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.values.push(arguments);\n\t\t}\n\t}\n\n\tthis.fail = this.errback = function() {\n\t\tlogger.debug('eb', [].slice.call(arguments, 0));\n\t\tif (this.eb) {\n\t\t\tthis.eb.apply(this, arguments);\n\t\t}\n\t\telse {\n\t\t\tthis.errors.push(arguments);\n\t\t}\n\t}\n\n   this.cancel = function() {\n\t\tif (this.cancelback) {\n\t\t\tvar cb = this.cancelback;\n\t\t\tthis.cancelback = null;\n\t\t\tcb.call(this);\n\t\t}\n\t}\n\tthis.setCallback = function(cb) {\n\t\tthis.cb = cb;\n\t\tfor (var i = 0, v; v=this.values[i]; ++i) {\n\t\t\tthis.cb.apply(this, v);\n\t\t}\n\t\tthis.values = [];\n\t\treturn this;\n\t}\n\tthis.setErrback = function(eb) {\n\t\tthis.eb = eb;\n\t\tfor (var i = 0, v; e=this.errors[i]; ++i) {\n\t\t\tthis.eb.apply(this, e);\n\t\t}\n\t\tthis.errors = [];\n\t\treturn this;\n\t}\n\tthis.setCancelback = function(cancelback) {\n\t\tthis.cancelback = cancelback;\n\t\treturn this;\n\t}\n})\n\nexports.Later.fail = function() { var l = new Later(); return l.fail.apply(l, arguments); }\nexports.Later.succeed = function() { var l = new Later(); return l.succeed.apply(l, arguments); }\n\n","pre":true},"preprocessors/cls.js":{"path":"preprocessors/cls.js","friendlyPath":"jsio.preprocessors.cls","directory":"preprocessors/","filename":"cls.js","src":"\n// var F = exports = Class\n// exports = Class\nvar classExport = /^(.*?)exports\\s*=\\s*Class\\s*\\(/gm;\n\n// var F = Class\n// exports.F = Class\n// var F = exports.F = Class\nvar class2Export = /^(\\s*)(.*?[ \\t]+)?([a-zA-Z0-9\\.$]+)\\s*=\\s*Class\\s*\\(/gm;\n\nfunction replacer (base, whitespace, prefix, name) {\n\tif (/\\/\\//.test(base)) {\n\t\treturn base;\n\t}\n\n\treturn whitespace + name + '=__class__;' + (prefix || '') + name + '=' + name + '(function ' + name.replace(/[\\.]/g, '_') + '(){return this.init&&this.init.apply(this,arguments)},';\n}\n\nexports = function (path, moduleDef, opts) {\n\tvar moduleCtor = moduleDef.path.replace(/(^[.\\/]+|\\.([^.]+?)$)/g, '').replace(/[\\:\\\\\\/\\-\\. ]/g, '_');\n\tmoduleDef.src = moduleDef.src\n\t\t.replace(classExport, 'var ' + moduleCtor + '=__class__;$1exports=' + moduleCtor + '(function ' + moduleCtor + '(){return this.init&&this.init.apply(this,arguments)},')\n\t\t.replace(class2Export, replacer);\n}\n","pre":true},"preprocessors/import.js":{"path":"preprocessors/import.js","friendlyPath":"jsio.preprocessors.import","directory":"preprocessors/","filename":"import.js","src":"var importExpr = /^(\\s*)(import\\s+[^=+*\"'\\r\\n;\\/]+|from\\s+[^=+\"'\\r\\n;\\/ ]+\\s+import\\s+[^=+\"'\\r\\n;\\/]+)(;|\\/|$)/gm;\n\nfunction replace(raw, p1, p2, p3) {\n\tif (!/\\/\\//.test(p1)) {\n\t\treturn p1 + 'jsio(\\'' + p2 + '\\')' + p3;\n\t}\n\treturn raw;\n}\n\nexports = function (path, moduleDef, opts) {\n\tmoduleDef.src = moduleDef.src.replace(importExpr, replace);\n}\n","pre":true},"preprocessors/inlineSlice.js":{"path":"preprocessors/inlineSlice.js","friendlyPath":"jsio.preprocessors.inlineSlice","directory":"preprocessors/","filename":"inlineSlice.js","src":"var sliceExpr = /INLINE_SLICE\\s*\\((.+),\\s*(.+)\\s*\\);/g;\n\nfunction replace (raw, p1, p2) {\n  return '' +\n    'var ' + p1 + ' = new Array(' + p2 + '.length); ' +\n    'var $_len = ' + p2 + '.length; ' +\n    'for (var $_i = 0; $_i !== ' + p2 + '.length; $_i++) { ' +\n    p1 + '[$_i] = ' + p2 + '[$_i]; }';\n}\n\nexports = function (path, moduleDef, opts) {\n  moduleDef.src = moduleDef.src.replace(sliceExpr, replace);\n};\n","pre":true},"preprocessors/logger.js":{"path":"preprocessors/logger.js","friendlyPath":"jsio.preprocessors.logger","directory":"preprocessors/","filename":"logger.js","src":"// var logger = require('./logger');\n// logger.replaceLogger(\"var foo = logger.log('123');\")\n\nvar loggerRegex = /logger\\.(log|warn|info|error|debug)\\(/g;\nvar delimiterRegex = /^(\\\\.|[\\(\\)\"'\\\\])/;\n\nexports = function (path, moduleDef, opts) {\n  moduleDef.src = exports.replaceLogger(moduleDef.src, moduleDef.friendlyPath);\n}\n\nexports.replaceLogger = function (src, prefix) {\n\n  loggerRegex.lastIndex = 0;\n\n  while (true) {\n    var match = loggerRegex.exec(src);\n    if (!match) { break; }\n\n    var i = match.index + match[0].length;\n    var tokens = [];\n    function nextToken() {\n      // we have a token in the queue\n      if (tokens.length) { return tokens.shift(); }\n\n      // we have a delimiter token next, max length of 2\n      var match = (src[i] + src[i + 1]).match(delimiterRegex);\n      if (match) {\n        i += match[0].length;\n        return match[0];\n      }\n\n      // advance to next delimiter\n      var token = '';\n      do {\n        token += src[i++];\n      } while (src[i] && !delimiterRegex.test(src[i]));\n      return token;\n    }\n\n    function consumeString(startQuote) {\n      var token;\n      do {\n        token = nextToken();\n      } while (token && token != startQuote);\n    }\n\n    function consumeParens() {\n      var token;\n      do {\n        token = nextToken();\n\n        // start a quoted string\n        if (token == '\"' || token == \"'\") {\n          consumeString(token);\n        }\n\n        // start a nested parenthesis\n        if (token == '(') {\n          consumeParens();\n        }\n      } while (token && token != ')');\n    }\n\n    // consume string up until close parenthesis for logger.log(...)\n    consumeParens();\n\n    var start = match.index + match[0].length;\n    var type = match[1];\n    var str = src.substring(start, i - 1);\n\n    // var replacement = 'console.log(' + str + ')';\n    var replacement = 'logger.' + type.toUpperCase() + '&&console.' + type + '(\"' + type.toUpperCase() + '\",\"' + prefix + '\",' + str + ')';\n    // var replacement = 'logger._' + type + '(' + str + ')(function(){console., console.' + type + ')'\n    src = src.substring(0, match.index)\n      + replacement\n      + src.substring(i);\n\n    loggerRegex.lastIndex = match.index + replacement.length;\n  }\n\n  return src;\n}\n","pre":true},"preprocessors/typescript.js":{"path":"preprocessors/typescript.js","friendlyPath":"jsio.preprocessors.typescript","directory":"preprocessors/","filename":"typescript.js","src":"var ts = require('typestring');\nvar fs = require('fs');\n\nvar defCache = {};\n\nvar readDefs = function(path) {\n  var results = fs.readdirSync(path);\n  results.filter(function(result) {\n    return !(result in defCache) && /\\.d\\.ts$/.test(result);\n  }).forEach(function(result) {\n    defCache[result] = fs.readFileSync(path + result, 'utf-8');\n  });\n};\n\nexports = function (path, moduleDef) {\n  if (/\\.ts$/.test(moduleDef.filename)) {\n    //it is a typescript file\n    readDefs(moduleDef.directory);\n    try {\n      moduleDef.src = ts.compile(moduleDef.src, defCache);\n    } catch (errors) {\n      console.error('Error compiling Typescript module:');\n      errors.forEach(function(error) {\n        var file = error.file;\n        var lineInfo = file.getLineAndCharacterFromPosition(error.start);\n        console.error(JSON.stringify(lineInfo));\n        console.error(moduleDef.filename + '('\n                      + lineInfo.line + ',' + lineInfo.character  + '): '\n                      + 'error TS' + error.code +  ': ' +  error.messageText);\n      });\n      throw new Error('Typescript compile failed.');\n    }\n  }\n};\n","pre":true},"std/XML.js":{"path":"std/XML.js","friendlyPath":"jsio.std.XML","directory":"std/","filename":"XML.js","src":"\n\nexports.parseString = function(str){\n\tif (jsio.__env.name == 'browser'){\n\t\t// Is it IE? XXX TODO: test this on a Windows computer\n\t\tif (window.ActiveXObject){ \n\t\t\tvar parser = new ActiveXObject('Microsoft.XMLDOM');\n\t\t\treturn parser.loadXML(str);\n\t\t} else {\n\t\t\tvar parser = new DOMParser();\n\t\t\treturn parser.parseFromString(str, 'text/xml');\n\t\t}\n\t}else if(jsio.__env.name == 'node'){\n\t};\n\n};\n","pre":true},"std/uri.js":{"path":"std/uri.js","friendlyPath":"jsio.std.uri","directory":"std/","filename":"uri.js","src":"var attrs = [ \n\t\"source\",\n\t\"protocol\",\n\t\"authority\",\n\t\"userInfo\",\n\t\"user\",\n\t\"password\",\n\t\"host\",\n\t\"port\",\n\t\"relative\",\n\t\"path\",\n\t\"directory\",\n\t\"file\",\n\t\"query\",\n\t\"anchor\"\n];\n\nvar URI = exports = Class(function(supr) {\n\tthis.init = function(url, isStrict) {\n\t\tif (url instanceof URI) {\n\t\t\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t\t\tthis['_' + attr] = url['_' + attr];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis._isStrict = isStrict;\n\t\t\n\t\tvar uriData = exports.parse(url, isStrict);\n\t\tfor (var attr in uriData) {\n\t\t\tthis['_' + attr] = uriData[attr];\n\t\t};\n\t}\n  \n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t(function(attr) {\n\t\t\tvar fNameSuffix = attr.charAt(0).toUpperCase() + attr.slice(1);\n\t\t\tthis['get' + fNameSuffix] = function() {\n\t\t\t\treturn this['_' + attr];\n\t\t\t};\n\t\t\tthis['set' + fNameSuffix] = function(val) {\n\t\t\t\tthis['_' + attr] = val;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t}).call(this, attr);\n\t};\n\t\n\tthis.query = function(key) { return exports.parseQuery(this._query)[key]; }\n\tthis.hash = function(key) { return exports.parseQuery(this._anchor)[key]; }\n\t\n\tthis.addHash = function(kvp) {\n\t\tvar hash = exports.parseQuery(this._anchor);\n\t\tfor (var i in kvp) { hash[i] = kvp[i]; }\n\t\tthis._anchor = exports.buildQuery(hash);\n\t\treturn this;\n\t}\n\t\n\tthis.push = function(path) {\n\t\tif (path) {\n\t\t\tthis._path = (this._path + '/' + path).replace(/\\/\\/+/g, '/');\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tthis.addQuery = function(kvp) {\n\t\tvar query = exports.parseQuery(this._query);\n\t\tfor (var i in kvp) { query[i] = kvp[i]; }\n\t\tthis._query = exports.buildQuery(query);\n\t\treturn this;\n\t}\n\t\n\tthis.removeQuery = function(keys) {\n\t\tvar query = exports.parseQuery(this._query);\n\t\tif (isArray(keys)) {\n\t\t\tfor (var i = 0, n = keys.length; i < n; ++i) {\n\t\t\t\tdelete query[keys[i]];\n\t\t\t}\n\t\t} else {\n\t\t\tdelete query[keys];\n\t\t}\n\t\tthis._query = exports.buildQuery(query);\n\t\treturn this;\n\t}\n\n\tthis.toJSON = function() { return this.toString(false); }\n\n\tthis.toString = function(onlyBase) {\n\t\t// XXX TODO: This is vaguely reasonable, but not complete. fix it...\n\t\tvar a = this._protocol ? this._protocol + \"://\" : \"\"\n\t\tvar b = this._host ? this._host + ((this._port || 80) == 80 ? \"\" : \":\" + this._port) : \"\";\n\t\t\n\t\tif (onlyBase) {\n\t\t\treturn a + b;\n\t\t}\n\t\t\n\t\tvar c = this._path;\n\t\tvar d = this._query ? '?' + this._query : '';\n\t\tvar e = this._anchor ? '#' + this._anchor : '';\n\t\treturn a + b + c + d + e;\n\t};\n});\n\nexports.relativeTo = function(url, base) {\n\tvar url = String(url);\n\tif (base && !/^http(s?):\\/\\//.test(url)) {\n\t\tvar baseURI = new exports(base)\n\t\t\t.setAnchor('')\n\t\t\t.setQuery('')\n\t\t\t.setFile('')\n\t\t\t.toString(url.charAt(0) == '/');\n\n\t\turl = exports.resolveRelative(baseURI + url);\n\t}\n\n\treturn new URI(url);\n}\n\nexports.resolveRelative = function(url) {\n\tvar prevUrl;\n\t\n\t// remove ../ with preceeding folder\n\twhile((prevUrl = url) != (url = url.replace(/(^|\\/)([^\\/]+)\\/\\.\\.\\//g, '/'))) {};\n\t\n\t// remove ./ if it isn't preceeded by a .\n\treturn url.replace(/[^.]\\.\\//g, '');\n}\n\nexports.buildQuery = function(kvp) {\n\tvar pairs = [];\n\tfor (var key in kvp) {\n\t\tpairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(kvp[key]));\n\t}\n\treturn pairs.join('&');\n}\n\nexports.parseQuery = function(str) {\n\tvar pairs = str.split('&'),\n\t\tn = pairs.length,\n\t\tdata = {};\n\tfor (var i = 0; i < n; ++i) {\n\t\tvar pair = pairs[i].split('='),\n\t\t\tkey = decodeURIComponent(pair[0]);\n\t\tif (key) { data[key] = decodeURIComponent(pair[1]); }\n\t}\n\treturn data;\n}\n\n// Regexs are based on parseUri 1.2.2\n// Original: (c) Steven Levithan <stevenlevithan.com>\n// Original: MIT License\n\nvar strictRegex = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar looseRegex = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar queryStringRegex = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\nexports.parse = function(str, isStrict) {\n\tvar regex = isStrict ? strictRegex : looseRegex;\n\tvar result = {};\n\tvar match = regex.exec(str);\n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\tresult[attr] = match[i] || \"\";\n\t}\n\t\n\tvar qs = result['queryKey'] = {};\n\tresult['query'].replace(queryStringRegex, function(check, key, val) {\n\t\tif (check) {\n\t\t\tqs[key] = val;\n\t\t}\n\t});\n\t\n\treturn result;\n}\n\nexports.isSameDomain = function(urlA, urlB) {\n\tvar a = exports.parse(urlA);\n\tvar b = exports.parse(urlB);\n\treturn ((a.port == b.port ) && (a.host == b.host) && (a.protocol == b.protocol));\n};\n","pre":true},"string/pad.js":{"path":"string/pad.js","friendlyPath":"jsio.string.pad","directory":"string/","filename":"pad.js","src":"// TODO: Support left vs right vs both padding?\nexports = function (input, length, padString) {\n\tinput = String(input);\n\tpadString = padString || \" \";\n\twhile (input.length < length) {\n\t\tinput = padString + input;\n\t}\n\treturn input;\n};\n","pre":true},"string/timeAgo.js":{"path":"string/timeAgo.js","friendlyPath":"jsio.string.timeAgo","directory":"string/","filename":"timeAgo.js","src":"var FORMATS = [\n\t[60, 'just now', 1], // 60\n\t[120, '1 minute ago', 'just now'], // 60*2\n\t[3600, 'minutes', 60], // 60*60, 60\n\t[7200, '1 hour ago', '1 hour from now'], // 60*60*2\n\t[86400, 'hours', 3600], // 60*60*24, 60*60\n\t[172800, 'yesterday', 'tomorrow'], // 60*60*24*2\n\t[604800, 'days', 86400], // 60*60*24*7, 60*60*24\n\t[1209600, 'last week', 'next week'], // 60*60*24*7*4*2\n\t[2419200, 'weeks', 604800], // 60*60*24*7*4, 60*60*24*7\n\t[4838400, 'last month', 'next month'], // 60*60*24*7*4*2\n\t[29030400, 'months', 2419200], // 60*60*24*7*4*12, 60*60*24*7*4\n\t[58060800, 'last year', 'next year'], // 60*60*24*7*4*12*2\n\t[2903040000, 'years', 29030400], // 60*60*24*7*4*12*100, 60*60*24*7*4*12\n\t[5806080000, 'last century', 'next century'], // 60*60*24*7*4*12*100*2\n\t[58060800000, 'centuries', 2903040000] // 60*60*24*7*4*12*100*20, 60*60*24*7*4*12*100\n];\n\n// based on http://webdesign.onyou.ch/2010/08/04/javascript-time-ago-pretty-date/\nexports = function(dateString, formats, isLocal, offset) {\n\tformats = formats || FORMATS;\n\toffset = offset || 0;\n\t\n\tvar date;\n\tif (dateString instanceof Date) {\n\t\tisLocal = false;\n\t\tdate = dateString;\n\t} else if (typeof dateString == 'string') {\n\t\tvar time = ('' + dateString).replace(/-/g, '/').replace(/[TZ]/g, ' ').replace(/^\\s+|\\s+$/g, '');\n\t\tif (time.charAt(time.length - 4) == '.') {\n\t\t\ttime = time.substr(0, time.length - 4);\n\t\t}\n\t\tdate = new Date(time);\n\t} else {\n\t\tisLocal = false;\n\t\tdate = new Date(dateString);\n\t}\n\n\tvar seconds = (new Date() - date - offset) / 1000 + (isLocal ? new Date().getTimezoneOffset() * 60 : 0);\n\tvar postfix = 'ago', listChoice = 1;\n\tif (seconds < 0) {\n\t\tseconds = -seconds;\n\t\tpostfix = 'from now';\n\t\tlistChoice = 2;\n\t}\n\t\n\tif (seconds < 60) { return 'just now'; }\n\t\n\tfor (var i = 0, format; format = FORMATS[i]; ++i) {\n\t\tif (seconds < format[0]) {\n\t\t\treturn typeof format[2] == 'string'\n\t\t\t\t? format[listChoice]\n\t\t\t\t: (seconds / format[2] | 0) + ' ' + format[1] + ' ' + postfix;\n\t\t}\n\t}\n\t\n\treturn date;\n};\n","pre":true},"util/Animation.js":{"path":"util/Animation.js","friendlyPath":"jsio.util.Animation","directory":"util/","filename":"Animation.js","src":"var SyncTimer = Class(function() {\n\tthis.init = function() {\n\t\tthis._items = [];\n\t\tthis._tick = bind(this, 'tick');\n\t\tthis._length = 0;\n\t}\n\t\n\tthis.tick = function() {\n\t\tvar now = +new Date();\n\t\tvar dt = now - this._last;\n\t\tthis._last = now;\n\t\t\n\t\t// items might get removed as we iterate, so this._length can change\n\t\tfor (var i = 0; i < this._length; ++i) {\n\t\t\tthis._items[i](dt);\n\t\t}\n\t}\n\t\n\tthis.add = function(cb) { \n\t\tif (cb) {\n\t\t\tthis._items.push(cb);\n\t\t\t++this._length;\n\t\t\tcb(0);\n\t\t\tthis.start();\n\t\t}\n\t}\n\t\n\tthis.remove = function(cb) {\n\t\tfor (var i = 0, n = this._items.length; i < n; ++i) {\n\t\t\tif (this._items[i] == cb) {\n\t\t\t\tthis._items.splice(i, 1);\n\t\t\t\tif (!--this._length) { this.stop(); }\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.start = function() {\n\t\tif (!this._isRunning) {\n\t\t\tthis._isRunning = true;\n\t\t\tthis._last = +new Date();\n\t\t\tthis._timer = setInterval(this._tick, 15);\n\t\t}\n\t}\n\t\n\tthis.stop = function() {\n\t\tif (this._isRunning) {\n\t\t\tthis._isRunning = false;\n\t\t\tclearInterval(this._timer);\n\t\t}\n\t}\n});\n\nvar timer = new SyncTimer();\n\nexports = Class(function() {\n\tthis.init = function(params) {\n\t\tthis._start = 'start' in params ? params.start : 0;\n\t\tthis._end = 'end' in params ? params.end : 1;\n\t\tthis._transition = params.transition || null;\n\t\tthis._easing = params.easing || false;\n\t\tthis._subject = params.subject;\n\t\tthis._duration = params.duration || 1000;\n\t\tthis._s = params.current || this._start;\n\t\tthis._onFinish = params.onFinish || null;\n\n\t\tthis._range = this._end - this._start;\n\t\tthis._isAnimating = false;\n\t\tthis._animate = bind(this, 'animate');\n\t\tthis._timer = null;\n\t}\n\t\n\tthis.stop = function() { this.jumpTo(this._s); }\n\tthis.play = function() { this.seekTo(this._end); }\n\t\n\tthis.seekTo = function(s, dur) {\n\t\tif (s == this._s) { return; }\n\t\t\n\t\tthis._t0 = 0;\n\t\tthis._s0 = this._s;\n\t\tthis._s1 = s;\n\t\tif(dur) this._duration = dur;\n\t\t\n\t\tthis._ds = s - this._s;\n\t\tvar dt = this._ds / this._range * this._duration;\n\t\tthis._dt = dt < 0 ? -dt : dt;\n\t\t\n\t\tif(!this._isAnimating) {\n\t\t\tthis._isAnimating = true;\n\t\t\ttimer.add(this._animate);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\tthis.onFinish = function(onFinish) { this._onFinish = onFinish; return this; }\n\t\n\tthis.jumpTo = function(s) {\n\t\tthis._s1 = this._s0 = s;\n\t\tthis._t0 = 0;\n\t\tthis._dt = 1;\n\t\tthis._ds = 0;\n\t\tthis.animate(0);\n\t\treturn this; \n\t}\n\t\n\tthis.animate = function(dt) {\n\t\tvar elapsed = (this._t0 += dt);\n\t\tvar dt = elapsed / this._dt;\n\t\tif(dt > 1) { dt = 1; }\n\t\tthis._s = this._s0 + dt * this._ds;\n\t\t\n\t\tvar x = this._transition ? this._transition(this._s) : this._s;\n\t\ttry {\n\t\t\tthis._subject(x, this._s);\n\t\t} finally {\n\t\t\tif(dt == 1) {\n\t\t\t\ttimer.remove(this._animate);\n\t\t\t\tthis._isAnimating = false;\n\t\t\t\tif(this._onFinish) {\n\t\t\t\t\tthis._onFinish();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\nexports.linear = function (n) { return n; }\nexports.easeIn = function (n) { return n * n; }\nexports.easeInOut = function (n) { return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2); }\nexports.easeOut = function(n) { return n * (2 - n); }","pre":true},"util/ajax.js":{"path":"util/ajax.js","friendlyPath":"jsio.util.ajax","directory":"util/","filename":"ajax.js","src":"jsio('import std.uri as URI');\n\nexports.MAX_SIMULTANEOUS = 4;\n\nvar _inflight = 0;\n\nvar doc;\nexports.getDoc = function() {\n\tif (doc) { return doc; }\n\ttry {\n\t\tdoc = window.ActiveXObject && new ActiveXObject('htmlfile');\n\t\tif (doc) {\n\t\t\tdoc.open().write('<html></html>');\n\t\t\tdoc.close();\n\t\t\twindow.attachEvent('onunload', function() {\n\t\t\t\ttry { doc.body.innerHTML = ''; } catch(e) {}\n\t\t\t\tdoc = null;\n\t\t\t});\n\t\t}\n\t} catch(e) {}\n\n\tif (!doc) { doc = document; }\n\treturn doc;\n};\n\nvar ctor = function() {\n\tvar win = window,\n\t\tdoc = exports.getDoc();\n\t//if (doc.parentWindow) { win = doc.parentWindow; }\n\n\treturn new (ctor = win.XMLHttpRequest ? win.XMLHttpRequest\n\t\t: function() { return win.ActiveXObject && new win.ActiveXObject('Msxml2.XMLHTTP') || null; });\n};\n\nexports.createXHR = function() { return new ctor(); }\n\nexports.post = function(opts, cb) {\n\treturn exports.get(merge({method: 'POST'}, opts), cb);\n}\n\nvar Request = Class(function() {\n\tvar _UID = 0;\n\n\tthis.init = function(opts, cb) {\n\t\tif (typeof opts == 'string') { opts = {url: opts}; }\n\t\tif (!opts || !opts.url) { logger.error('no url provided'); return; }\n\n\t\tthis.method = (opts.method || 'GET').toUpperCase();\n\t\tthis.url = opts.url;\n\t\tthis.type = opts.type;\n\t\tthis.async = opts.async;\n\t\tthis.timeout = opts.timeout;\n\t\tthis.withCredentials = !!opts.withCredentials;\n\t\tthis.id = ++_UID;\n\t\tthis.headers = {};\n\t\tthis.cb = cb;\n\n\t\tif (opts.headers) {\n\t\t\tfor (var key in opts.headers) if (opts.headers.hasOwnProperty(key)) {\n\t\t\t\tvar value = opts.headers[key];\n\t\t\t\tthis.headers[key] = value;\n\t\t\t}\n\t\t}\n\n\t\tvar isObject = opts.data && typeof opts.data == 'object';\n\n\t\tif (this.method == 'GET' && opts.data) {\n\t\t\tthis.url = new URI(this.url)\n\t\t\t\t\t\t\t.addQuery(isObject ? opts.data : URI.parseQuery(opts.data))\n\t\t\t\t\t\t\t.toString();\n\t\t}\n\n\t\tif (opts.query) {\n\t\t\tthis.url = new URI(this.url)\n\t\t\t\t\t\t\t.addQuery(typeof opts.query == 'object' ? opts.query : URI.parseQuery(opts.query))\n\t\t\t\t\t\t\t.toString();\n\t\t}\n\n\t\ttry {\n\t\t\tthis.data = (this.method != 'GET' ? (isObject ? JSON.stringify(opts.data) : opts.data) : null);\n\t\t\tif (isObject && !this.headers['Content-Type']) {\n\t\t\t\tthis.headers['Content-Type'] = 'application/json';\n\t\t\t}\n\t\t} catch(e) {\n\t\t\tcb && cb({invalidData: true}, null, '');\n\t\t\treturn;\n\t\t}\n\t}\n});\n\nvar _pending = [];\n\nexports.get = function(opts, cb) {\n\tvar request = new Request(opts, cb);\n\n\tif (_inflight >= exports.MAX_SIMULTANEOUS) {\n\t\t_pending.push(request);\n\t} else {\n\t\t_send(request);\n\t}\n}\n\nfunction _sendNext() {\n\t//logger.log('====INFLIGHT', _inflight, exports.MAX_SIMULTANEOUS, 'might send next?');\n\tif (_inflight < exports.MAX_SIMULTANEOUS) {\n\t\tvar request = _pending.shift();\n\t\tif (request) {\n\t\t\t_send(request);\n\t\t}\n\t}\n}\n\nfunction _send(request) {\n\t++_inflight;\n\t//logger.log('====INFLIGHT', _inflight, 'sending request', request.id);\n\n\tvar xhr = exports.createXHR();\n\txhr.open(request.method, request.url, !(request.async == false));\n\tvar setContentType = false;\n\tfor (var key in request.headers) {\n\t\tif (key.toLowerCase() == 'content-type') { setContentType = true; }\n\t\txhr.setRequestHeader(key, request.headers[key]);\n\t}\n\n\txhr.withCredentials = request.withCredentials;\n\n\tif (!setContentType) {\n\t\txhr.setRequestHeader('Content-Type', 'text/plain');\n\t}\n\n\txhr.onreadystatechange = bind(this, onReadyStateChange, request, xhr);\n\tif (request.timeout) {\n\t\trequest.timeoutRef = setTimeout(bind(this, cancel, xhr, request), request.timeout);\n\t\t//logger.log('==== setting timeout for', request.timeout, request.timeoutRef, '<<');\n\t}\n\n\trequest.ts = +new Date();\n\txhr.send(request.data || null);\n}\n\nfunction cancel(xhr, request) {\n\t--_inflight;\n\t// logger.log('====INFLIGHT', _inflight, 'timeout (cancelled)', request.id);\n\tif (request.timedOut) {\n\t\tlogger.log('already timed out?!');\n\t}\n\n\txhr.onreadystatechange = null;\n\trequest.timedOut = true;\n\tif (xhr.readyState >= xhr.HEADERS_RECEIVED) {\n\t\ttry {\n\t\t\tvar headers = xhr.getAllResponseHeaders();\n\t\t} catch (e) {}\n\t}\n\n\trequest.cb && request.cb({timeout: true}, null, headers);\n}\n\nfunction onReadyStateChange(request, xhr) {\n\tif (xhr.readyState != 4) { return; }\n\n\tif (request.timedOut) { throw 'Unexpected?!'; }\n\n\t--_inflight;\n\n\t// logger.log('====INFLIGHT', _inflight, 'received response', request.ts, request.id, (+new Date() - request.ts) / 1000);\n\tsetTimeout(_sendNext, 0);\n\n\tvar cb = request.cb;\n\tif ('timeoutRef' in request) {\n\t\t// logger.log('==== AJAX CLEARING TIMEOUT', request.id);\n\t\tclearTimeout(request.timeoutRef);\n\t\trequest.timeoutRef = null;\n\t}\n\n\t// only fire callback once\n\tif (!cb || request.handled) { return; }\n\trequest.handled = true;\n\n\tvar isJSON = /^application\\/json(;|$)/.test(xhr.getResponseHeader('Content-Type')) || request.type == 'json';\n\tvar response = xhr.response || xhr.responseText;\n\tvar data = response;\n\tvar parseError = false;\n\tif (isJSON && response && typeof response == 'string') {\n\t\ttry {\n\t\t\tdata = JSON.parse(response);\n\t\t} catch(e) {\n\t\t\tparseError = true;\n\t\t}\n\t}\n\n\t// .status will be 0 when requests are filled via app cache on at least iOS 4.x\n\tif (xhr.status != 200 && xhr.status != 0 || parseError) {\n\t\tcb({status: xhr.status, response: data, parseError: parseError}, null, xhr.getAllResponseHeaders());\n\t} else {\n\t\tcb(null, data, xhr.getAllResponseHeaders());\n\t}\n}\n","pre":true},"util/browser.js":{"path":"util/browser.js","friendlyPath":"jsio.util.browser","directory":"util/","filename":"browser.js","src":"jsio('external .sizzle import Sizzle');\n\njsio('import math.geom.Rect');\n\nfunction isWindow(el) {\n\treturn el && !$.isElement(el) && $.isElement(el.document);\n}\n\nvar singleId = /^#([\\w-]+)$/;\n\nvar $ = exports.$ = function(selector, win) {\n\tswitch(typeof selector) {\n\t\tcase 'object':\n\t\t\tif ($.isElement(selector)) {\n\t\t\t\treturn $.remove(selector);\n\t\t\t} else if ($.isElement(selector.document && selector.document.body)) {\n\t\t\t\treturn $.size(selector);\n\t\t\t}\n\t\t\treturn $.create(selector);\n\t\tcase 'string':\n\t\t\tif (singleId.test(selector)) { return $.id(selector.substring(1), win); }\n\t\t\treturn Sizzle.apply(GLOBAL, arguments);\n\t}\n}\n\nvar DOM2 = typeof HTMLElement === \"object\";\n$.isElement = DOM2\n\t? function(el) { return el && el instanceof HTMLElement; }\n\t: function(el) { return el && typeof el.nodeType == 'number' && typeof el.nodeName == 'string' };\n\n$.id = function(id, win) { return typeof id == 'string' ? (win || window).document.getElementById(id) : id; }\n\n$.apply = function(el, params) {\n\tif (params.attrs) {\n\t\tfor(attr in params.attrs) {\n\t\t\tel.setAttribute(attr, params.attrs[attr]);\n\t\t}\n\t}\n\n\tif (params.id) { el.id = params.id; }\n\tif (params.style) { $.style(el, params.style); }\n\tif (params.src) { el.src = params.src; }\n\tif (params['class'] || params['className']) {\n\t\tel.className = params['class'] || params['className'];\n\t}\n\n\tvar parent = params.parent || params.parentNode;\n\tif (parent && params.first) {\n\t\t$.insertBefore(parent, el, parent.firstChild);\n\t} else if (params.before) {\n\t\t$.insertBefore(params.before.parentNode || parent, el, params.before);\n\t} else if (params.after) {\n\t\t$.insertAfter(params.after.parentNode || parent, el, params.after);\n\t} else if (parent) {\n\t\tparent.appendChild(el);\n\t}\n\n\tif ('html' in params) { el.innerHTML = params.html; }\n\tif ('text' in params) { $.setText(el, params.text); }\n\n\tif (params.children) {\n\t\tvar c = params.children;\n\t\tfor (var i = 0, n = c.length; i < n; ++i) {\n\t\t\tel.appendChild($.isElement(c[i]) ? c[i] : $(c[i]));\n\t\t}\n\t}\n\n\treturn el;\n}\n\n$.insertBefore = function(parentNode, el, beforeNode) {\n\tif (!parentNode || !el) { return; }\n\tif (beforeNode && beforeNode.parentNode == parentNode) {\n\t\tparentNode.insertBefore(el, beforeNode);\n\t} else {\n\t\tparentNode.appendChild(el);\n\t}\n}\n\n$.insertAfter = function(parentNode, el, afterNode) {\n\tif (!parentNode || !el) { return; }\n\tif (!afterNode || afterNode.parentNode != parentNode) {\n\t\t$.insertBefore(parentNode, el, parentNode.firstChild);\n\t} else if (!afterNode.nextSibling) {\n\t\tparentNode.appendChild(el);\n\t} else {\n\t\tparentNode.insertBefore(el, afterNode.nextSibling);\n\t}\n}\n\n$.create = function(params) {\n\tvar doc = ((params && params.win) || window).document;\n\tif (!params || typeof params == 'string') {\n\t\treturn doc.createElement(params || 'div');\n\t};\n\n\treturn $.apply(params.el || doc.createElement(params.tag || params.tagName || 'div'), params);\n}\n\n$.show = function(el, how) { $.id(el).style.display = how || 'block'; }\n$.hide = function(el) { $.id(el).style.display = 'none'; }\n\n// accepts an array or a space-delimited string of classNames\n$.addClass = function(el, classNames) {\n\tif (!el) { return; }\n\tvar el = $.id(el);\n\tif (typeof classNames == \"string\") {\n\t\tclassNames = classNames.split(' ');\n\t}\n\n\tvar current = ' ' + el.className + ' ';\n\tfor (var i = 0, len = classNames.length; i < len; ++i) {\n\t\tvar c = classNames[i];\n\t\tif (current.indexOf(' ' + c + ' ') == -1) {\n\t\t\tcurrent += c + ' ';\n\t\t}\n\t}\n\n\tel.className = current.replace(/^\\s+|\\s+$/g, '');\n\treturn $;\n}\n\n/* returns true if the given className is found in the list of\n * classes on the given element.\n */\n$.hasClass = function(el, className) {\n\tif (!el) { return false; }\n\n\tvar el = $.id(el);\n\tvar classNames = el.className.split(' ');\n\n\tfor (var i = 0, len = classNames.length; i < len; ++i) {\n\t\tif (classNames[i].trim() === className) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\n$.getTag = function(from, tag) { return from.getElementsByTagName(tag); }\n\n$.removeClass = function(el, classNames) {\n\tif (!el) { return; }\n\tvar el = $.id(el);\n\tel.className = (' ' + el.className + ' ')\n\t\t.replace(' ', '  ')\n\t\t.replace(new RegExp('( ' + classNames.replace('\\s+', ' | ').replace('-','\\-') + ' )', 'g'), ' ')\n\t\t.replace(/\\s+/, ' ')\n\t\t.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction ieGetAlpha(el) {\n\ttry {\n\t\treturn el.filters.item(\"alpha\");\n\t} catch(e) {}\n\n\ttry {\n\t\treturn el.filters.item(\"progid:DXImageTransform.Microsoft.Alpha\");\n\t} catch(e) {}\n\n\treturn null;\n}\n\n$.style = function(el, style) {\n\tif(el instanceof Array) {\n\t\tfor(var i = 0, o; o = el[i]; ++i) { $.style(o, style); }\n\t\treturn;\n\t}\n\n\tel = $.id(el);\n\tvar s = el.style;\n\tfor(prop in style) {\n\t\tswitch(prop) {\n\t\t\tcase 'styleFloat':\n\t\t\tcase 'cssFloat':\n\t\t\tcase 'float':\n\t\t\t\ts.styleFloat = s.cssFloat = style[prop];\n\t\t\t\tbreak;\n\t\t\tcase 'opacity':\n\t\t\t\ts.opacity = style[prop];\n\t\t\t\tif(el.filters) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar alpha = ieGetAlpha();\n\t\t\t\t\t\tvar opacity = style[prop] == 1 ? 99.99 : style[prop] * 100;\n\t\t\t\t\t\tif(!alpha) {\n\t\t\t\t\t\t\t// TODO: this might destroy any existing filters?\n\t\t\t\t\t\t\ts.filter = \"alpha(opacity=\" + opacity + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\talpha.Opacity = opacity;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'borderRadius':\n\t\t\t\ts.borderRadius = s.MozBorderRadius = style[prop];\n\t\t\t\tbreak;\n\t\t\tcase 'boxSizing':\n\t\t\t\ts.MsBoxSizing = s.MozBoxSizing = s.WebkitBoxSizing = style[prop];\n\t\t\tdefault:\n\t\t\t\ts[prop] = style[prop];\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\n$.onEvent = function(el, name, f) {\n\tif (typeof f != 'function') {\n\t\tf = bind.apply(GLOBAL, Array.prototype.slice.call(arguments, 2));\n\t}\n\n\tvar handler = f;\n\n\tel = $.id(el);\n\tif(el.addEventListener) {\n\t\tel.addEventListener(name, handler, false);\n\t} else {\n\t\thandler = function(e) {\n\t\t\tvar evt = e || window.event;\n\t\t\t// TODO: normalize the event object\n\t\t\tf(evt);\n\t\t};\n\n\t\tel.attachEvent('on' + name, handler);\n\t}\n\n\treturn bind($, 'removeEvent', el, name, handler);\n};\n\n$.removeEvent = function(el, name, f) {\n\tel = $.id(el);\n\tif (el.addEventListener) {\n\t\tel.removeEventListener(name, f, false);\n\t} else {\n\t\tel.detachEvent('on' + name, f);\n\t}\n}\n\n$.stopEvent = function(e) {\n\tif (e) {\n\t\te.cancelBubble = true;\n\t\tif(e.stopPropagation) e.stopPropagation();\n\t\tif(e.preventDefault) e.preventDefault();\n\t}\n}\n\n$.setText = function(el, text) {\n\tel = $.id(el);\n\ttext = String(text);\n\tif ('textContent' in el) {\n\t\tel.textContent = text;\n\t} else if ('innerText' in el) {\n\t\tel.innerText = text.replace(/\\n/g, ' ');\n\t} else {\n\t\tel.innerHTML = '';\n\t\tel.appendChild(document.createTextNode(text));\n\t}\n}\n\n$.setValue = function(el, value) {\n\tel = $.id(el);\n\tif ('value' in el) {\n\t\tel.value = value;\n\t} else if ('value' in el.firstChild) {\n\t\tel.firstChild.value = value;\n\t}\n};\n\n$.remove = function(el) {\n\tel = $.id(el);\n\tif(el && el.parentNode) {\n\t\tel.parentNode.removeChild(el);\n\t}\n}\n\n$.cursorPos = function(ev, el) {\n\tvar offset = $.pos(el);\n\toffset.top = ev.clientY - offset.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n\toffset.left = ev.clientX - offset.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft);\n\treturn offset;\n}\n\n$.pos = function(el) {\n\tvar parent = el;\n\tvar offset = {top: 0, left: 0};\n\twhile(parent && parent != document.body) {\n\t\toffset.left += parent.offsetLeft;\n\t\toffset.top += parent.offsetTop;\n\t\twhile(parent.offsetParent != parent.parentNode) {\n\t\t\toffset.top -= parent.scrollTop; offset.left -= parent.scrollLeft;\n\t\t\tparent = parent.parentNode;\n\t\t}\n\t\tparent = parent.offsetParent;\n\t}\n\treturn offset;\n}\n\n$.size = function(el) {\n\tif ($.isElement(el)) {\n\t\treturn {width: el.offsetWidth, height: el.offsetHeight};\n\t} else if (el.document) {\n\t\tvar doc = el.document.documentElement || el.document.body;\n\t\treturn new math.geom.Rect(\n\t\t\tdoc.offsetTop,\n\t\t\tdoc.offsetLeft,\n\t\t\tel.innerWidth || (doc.clientWidth || doc.clientWidth),\n\t\t\tel.innerHeight || (doc.clientHeight || doc.clientHeight)\n\t\t);\n\t}\n}\n\n$.insertCSSFile = function(filename) {\n\tdocument.getElementsByTagName('head')[0].appendChild($({\n\t\ttag: 'link',\n\t\tattrs: {\n\t\t\trel: 'stylesheet',\n\t\t\ttype: 'text/css',\n\t\t\thref: filename\n\t\t}\n\t}));\n}\n","pre":true},"util/sizzle.js":{"path":"util/sizzle.js","friendlyPath":".sizzle","directory":"util/","filename":"sizzle.js","src":"/*!\n * Sizzle CSS Selector Engine - v1.0\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n\nSizzle = (function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['\"][^'\"]*['\"]|[^[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString,\n\thasDuplicate = false;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tvar origContext = context = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true, contextXML = isXML(context);\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && origPOS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tset = posProcess( parts[0] + parts[1], context );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tselector = parts.shift();\n\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tset = posProcess( selector, set );\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t// (but not if it'll be faster if the inner selector is an ID)\n\t\tif ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\n\t\t\t\tExpr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\n\t\t\tvar ret = Sizzle.find( parts.shift(), context, contextXML );\n\t\t\tcontext = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];\n\t\t}\n\n\t\tif ( context ) {\n\t\t\tvar ret = seed ?\n\t\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\t\tSizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML );\n\t\t\tset = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;\n\n\t\t\tif ( parts.length > 0 ) {\n\t\t\t\tcheckSet = makeArray(set);\n\t\t\t} else {\n\t\t\t\tprune = false;\n\t\t\t}\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\t\tcur = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tpop = parts.pop();\n\t\t\t\t}\n\n\t\t\t\tif ( pop == null ) {\n\t\t\t\t\tpop = context;\n\t\t\t\t}\n\n\t\t\t\tExpr.relative[ cur ]( checkSet, pop, contextXML );\n\t\t\t}\n\t\t} else {\n\t\t\tcheckSet = parts = [];\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n\n\tif ( !checkSet ) {\n\t\tthrow \"Syntax error, unrecognized expression: \" + (cur || selector);\n\t}\n\n\tif ( toString.call(checkSet) === \"[object Array]\" ) {\n\t\tif ( !prune ) {\n\t\t\tresults.push.apply( results, checkSet );\n\t\t} else if ( context && context.nodeType === 1 ) {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmakeArray( checkSet, results );\n\t}\n\n\tif ( extra ) {\n\t\tSizzle( extra, origContext, results, seed );\n\t\tSizzle.uniqueSort( results );\n\t}\n\n\treturn results;\n};\n\nSizzle.uniqueSort = function(results){\n\tif ( sortOrder ) {\n\t\thasDuplicate = false;\n\t\tresults.sort(sortOrder);\n\n\t\tif ( hasDuplicate ) {\n\t\t\tfor ( var i = 1; i < results.length; i++ ) {\n\t\t\t\tif ( results[i] === results[i-1] ) {\n\t\t\t\t\tresults.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nSizzle.matches = function(expr, set){\n\treturn Sizzle(expr, null, null, set);\n};\n\nSizzle.find = function(expr, context, isXML){\n\tvar set, match;\n\n\tif ( !expr ) {\n\t\treturn [];\n\t}\n\n\tfor ( var i = 0, l = Expr.order.length; i < l; i++ ) {\n\t\tvar type = Expr.order[i], match;\n\t\t\n\t\tif ( (match = Expr.match[ type ].exec( expr )) ) {\n\t\t\tvar left = RegExp.leftContext;\n\n\t\t\tif ( left.substr( left.length - 1 ) !== \"\\\\\" ) {\n\t\t\t\tmatch[1] = (match[1] || \"\").replace(/\\\\/g, \"\");\n\t\t\t\tset = Expr.find[ type ]( match, context, isXML );\n\t\t\t\tif ( set != null ) {\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !set ) {\n\t\tset = context.getElementsByTagName(\"*\");\n\t}\n\n\treturn {set: set, expr: expr};\n};\n\nSizzle.filter = function(expr, set, inplace, not){\n\tvar old = expr, result = [], curLoop = set, match, anyFound,\n\t\tisXMLFilter = set && set[0] && isXML(set[0]);\n\n\twhile ( expr && set.length ) {\n\t\tfor ( var type in Expr.filter ) {\n\t\t\tif ( (match = Expr.match[ type ].exec( expr )) != null ) {\n\t\t\t\tvar filter = Expr.filter[ type ], found, item;\n\t\t\t\tanyFound = false;\n\n\t\t\t\tif ( curLoop == result ) {\n\t\t\t\t\tresult = [];\n\t\t\t\t}\n\n\t\t\t\tif ( Expr.preFilter[ type ] ) {\n\t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\n\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\tanyFound = found = true;\n\t\t\t\t\t} else if ( match === true ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tfor ( var i = 0; (item = curLoop[i]) != null; i++ ) {\n\t\t\t\t\t\tif ( item ) {\n\t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\n\t\t\t\t\t\t\tvar pass = not ^ !!found;\n\n\t\t\t\t\t\t\tif ( inplace && found != null ) {\n\t\t\t\t\t\t\t\tif ( pass ) {\n\t\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( pass ) {\n\t\t\t\t\t\t\t\tresult.push( item );\n\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( found !== undefined ) {\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tcurLoop = result;\n\t\t\t\t\t}\n\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\n\t\t\t\t\tif ( !anyFound ) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Improper expression\n\t\tif ( expr == old ) {\n\t\t\tif ( anyFound == null ) {\n\t\t\t\tthrow \"Syntax error, unrecognized expression: \" + expr;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\told = expr;\n\t}\n\n\treturn curLoop;\n};\n\nvar Expr = Sizzle.selectors = {\n\torder: [ \"ID\", \"NAME\", \"TAG\" ],\n\tmatch: {\n\t\tID: /#((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tNAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)['\"]*\\]/,\n\t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/,\n\t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*_-]|\\\\.)+)/,\n\t\tCHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,\n\t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,\n\t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)(?:\\((['\"]*)((?:\\([^\\)]+\\)|[^\\2\\(\\)]*)+)\\2\\))?/\n\t},\n\tattrMap: {\n\t\t\"class\": \"className\",\n\t\t\"for\": \"htmlFor\"\n\t},\n\tattrHandle: {\n\t\thref: function(elem){\n\t\t\treturn elem.getAttribute(\"href\");\n\t\t}\n\t},\n\trelative: {\n\t\t\"+\": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === \"string\",\n\t\t\t\tisTag = isPartStr && !/\\W/.test(part),\n\t\t\t\tisPartStrNotTag = isPartStr && !isTag;\n\n\t\t\tif ( isTag && !isXML ) {\n\t\t\t\tpart = part.toUpperCase();\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\n\t\t\t\tif ( (elem = checkSet[i]) ) {\n\t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\n\n\t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName === part ?\n\t\t\t\t\t\telem || false :\n\t\t\t\t\t\telem === part;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( isPartStrNotTag ) {\n\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t}\n\t\t},\n\t\t\">\": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === \"string\";\n\n\t\t\tif ( isPartStr && !/\\W/.test(part) ) {\n\t\t\t\tpart = isXML ? part : part.toUpperCase();\n\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName === part ? parent : false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tcheckSet[i] = isPartStr ?\n\t\t\t\t\t\t\telem.parentNode :\n\t\t\t\t\t\t\telem.parentNode === part;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( isPartStr ) {\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"\": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t},\n\t\t\"~\": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t}\n\t},\n\tfind: {\n\t\tID: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? [m] : [];\n\t\t\t}\n\t\t},\n\t\tNAME: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementsByName !== \"undefined\" ) {\n\t\t\t\tvar ret = [], results = context.getElementsByName(match[1]);\n\n\t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\n\t\t\t\t\tif ( results[i].getAttribute(\"name\") === match[1] ) {\n\t\t\t\t\t\tret.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ret.length === 0 ? null : ret;\n\t\t\t}\n\t\t},\n\t\tTAG: function(match, context){\n\t\t\treturn context.getElementsByTagName(match[1]);\n\t\t}\n\t},\n\tpreFilter: {\n\t\tCLASS: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tmatch = \" \" + match[1].replace(/\\\\/g, \"\") + \" \";\n\n\t\t\tif ( isXML ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tif ( not ^ (elem.className && (\" \" + elem.className + \" \").indexOf(match) >= 0) ) {\n\t\t\t\t\t\tif ( !inplace )\n\t\t\t\t\t\t\tresult.push( elem );\n\t\t\t\t\t} else if ( inplace ) {\n\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\t\tID: function(match){\n\t\t\treturn match[1].replace(/\\\\/g, \"\");\n\t\t},\n\t\tTAG: function(match, curLoop){\n\t\t\tfor ( var i = 0; curLoop[i] === false; i++ ){}\n\t\t\treturn curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();\n\t\t},\n\t\tCHILD: function(match){\n\t\t\tif ( match[1] == \"nth\" ) {\n\t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n\t\t\t\tvar test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\n\t\t\t\t\tmatch[2] == \"even\" && \"2n\" || match[2] == \"odd\" && \"2n+1\" ||\n\t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\n\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\n\t\t\t\tmatch[3] = test[3] - 0;\n\t\t\t}\n\n\t\t\t// TODO: Move to normal caching system\n\t\t\tmatch[0] = done++;\n\n\t\t\treturn match;\n\t\t},\n\t\tATTR: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tvar name = match[1].replace(/\\\\/g, \"\");\n\t\t\t\n\t\t\tif ( !isXML && Expr.attrMap[name] ) {\n\t\t\t\tmatch[1] = Expr.attrMap[name];\n\t\t\t}\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[4] = \" \" + match[4] + \" \";\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\t\tPSEUDO: function(match, curLoop, inplace, result, not){\n\t\t\tif ( match[1] === \"not\" ) {\n\t\t\t\t// If we're dealing with a complex expression, or a simple one\n\t\t\t\tif ( chunker.exec(match[3]).length > 1 || /^\\w/.test(match[3]) ) {\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\n\t\t\t\t} else {\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tresult.push.apply( result, ret );\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn match;\n\t\t},\n\t\tPOS: function(match){\n\t\t\tmatch.unshift( true );\n\t\t\treturn match;\n\t\t}\n\t},\n\tfilters: {\n\t\tenabled: function(elem){\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\n\t\t},\n\t\tdisabled: function(elem){\n\t\t\treturn elem.disabled === true;\n\t\t},\n\t\tchecked: function(elem){\n\t\t\treturn elem.checked === true;\n\t\t},\n\t\tselected: function(elem){\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\telem.parentNode.selectedIndex;\n\t\t\treturn elem.selected === true;\n\t\t},\n\t\tparent: function(elem){\n\t\t\treturn !!elem.firstChild;\n\t\t},\n\t\tempty: function(elem){\n\t\t\treturn !elem.firstChild;\n\t\t},\n\t\thas: function(elem, i, match){\n\t\t\treturn !!Sizzle( match[3], elem ).length;\n\t\t},\n\t\theader: function(elem){\n\t\t\treturn /h\\d/i.test( elem.nodeName );\n\t\t},\n\t\ttext: function(elem){\n\t\t\treturn \"text\" === elem.type;\n\t\t},\n\t\tradio: function(elem){\n\t\t\treturn \"radio\" === elem.type;\n\t\t},\n\t\tcheckbox: function(elem){\n\t\t\treturn \"checkbox\" === elem.type;\n\t\t},\n\t\tfile: function(elem){\n\t\t\treturn \"file\" === elem.type;\n\t\t},\n\t\tpassword: function(elem){\n\t\t\treturn \"password\" === elem.type;\n\t\t},\n\t\tsubmit: function(elem){\n\t\t\treturn \"submit\" === elem.type;\n\t\t},\n\t\timage: function(elem){\n\t\t\treturn \"image\" === elem.type;\n\t\t},\n\t\treset: function(elem){\n\t\t\treturn \"reset\" === elem.type;\n\t\t},\n\t\tbutton: function(elem){\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toUpperCase() === \"BUTTON\";\n\t\t},\n\t\tinput: function(elem){\n\t\t\treturn /input|select|textarea|button/i.test(elem.nodeName);\n\t\t}\n\t},\n\tsetFilters: {\n\t\tfirst: function(elem, i){\n\t\t\treturn i === 0;\n\t\t},\n\t\tlast: function(elem, i, match, array){\n\t\t\treturn i === array.length - 1;\n\t\t},\n\t\teven: function(elem, i){\n\t\t\treturn i % 2 === 0;\n\t\t},\n\t\todd: function(elem, i){\n\t\t\treturn i % 2 === 1;\n\t\t},\n\t\tlt: function(elem, i, match){\n\t\t\treturn i < match[3] - 0;\n\t\t},\n\t\tgt: function(elem, i, match){\n\t\t\treturn i > match[3] - 0;\n\t\t},\n\t\tnth: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t},\n\t\teq: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t}\n\t},\n\tfilter: {\n\t\tPSEUDO: function(elem, match, i, array){\n\t\t\tvar name = match[1], filter = Expr.filters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t} else if ( name === \"contains\" ) {\n\t\t\t\treturn (elem.textContent || elem.innerText || \"\").indexOf(match[3]) >= 0;\n\t\t\t} else if ( name === \"not\" ) {\n\t\t\t\tvar not = match[3];\n\n\t\t\t\tfor ( var i = 0, l = not.length; i < l; i++ ) {\n\t\t\t\t\tif ( not[i] === elem ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tCHILD: function(elem, match){\n\t\t\tvar type = match[1], node = elem;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'only':\n\t\t\t\tcase 'first':\n\t\t\t\t\twhile ( (node = node.previousSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\tif ( type == 'first') return true;\n\t\t\t\t\tnode = elem;\n\t\t\t\tcase 'last':\n\t\t\t\t\twhile ( (node = node.nextSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'nth':\n\t\t\t\t\tvar first = match[2], last = match[3];\n\n\t\t\t\t\tif ( first == 1 && last == 0 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar doneName = match[0],\n\t\t\t\t\t\tparent = elem.parentNode;\n\t\n\t\t\t\t\tif ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\n\t\t\t\t\t\tvar count = 0;\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\tparent.sizcache = doneName;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar diff = elem.nodeIndex - last;\n\t\t\t\t\tif ( first == 0 ) {\n\t\t\t\t\t\treturn diff == 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ( diff % first == 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tID: function(elem, match){\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n\t\t},\n\t\tTAG: function(elem, match){\n\t\t\treturn (match === \"*\" && elem.nodeType === 1) || elem.nodeName === match;\n\t\t},\n\t\tCLASS: function(elem, match){\n\t\t\treturn (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \")\n\t\t\t\t.indexOf( match ) > -1;\n\t\t},\n\t\tATTR: function(elem, match){\n\t\t\tvar name = match[1],\n\t\t\t\tresult = Expr.attrHandle[ name ] ?\n\t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\n\t\t\t\t\telem[ name ] != null ?\n\t\t\t\t\t\telem[ name ] :\n\t\t\t\t\t\telem.getAttribute( name ),\n\t\t\t\tvalue = result + \"\",\n\t\t\t\ttype = match[2],\n\t\t\t\tcheck = match[4];\n\n\t\t\treturn result == null ?\n\t\t\t\ttype === \"!=\" :\n\t\t\t\ttype === \"=\" ?\n\t\t\t\tvalue === check :\n\t\t\t\ttype === \"*=\" ?\n\t\t\t\tvalue.indexOf(check) >= 0 :\n\t\t\t\ttype === \"~=\" ?\n\t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\n\t\t\t\t!check ?\n\t\t\t\tvalue && result !== false :\n\t\t\t\ttype === \"!=\" ?\n\t\t\t\tvalue != check :\n\t\t\t\ttype === \"^=\" ?\n\t\t\t\tvalue.indexOf(check) === 0 :\n\t\t\t\ttype === \"$=\" ?\n\t\t\t\tvalue.substr(value.length - check.length) === check :\n\t\t\t\ttype === \"|=\" ?\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\n\t\t\t\tfalse;\n\t\t},\n\t\tPOS: function(elem, match, i, array){\n\t\t\tvar name = match[2], filter = Expr.setFilters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar origPOS = Expr.match.POS;\n\nfor ( var type in Expr.match ) {\n\tExpr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source );\n}\n\nvar makeArray = function(array, results) {\n\tarray = Array.prototype.slice.call( array, 0 );\n\n\tif ( results ) {\n\t\tresults.push.apply( results, array );\n\t\treturn results;\n\t}\n\t\n\treturn array;\n};\n\n// Perform a simple check to determine if the browser is capable of\n// converting a NodeList to an array using builtin methods.\ntry {\n\tArray.prototype.slice.call( document.documentElement.childNodes, 0 );\n\n// Provide a fallback method if it does not work\n} catch(e){\n\tmakeArray = function(array, results) {\n\t\tvar ret = results || [];\n\n\t\tif ( toString.call(array) === \"[object Array]\" ) {\n\t\t\tArray.prototype.push.apply( ret, array );\n\t\t} else {\n\t\t\tif ( typeof array.length === \"number\" ) {\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0; array[i]; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n}\n\nvar sortOrder;\n\nif ( document.documentElement.compareDocumentPosition ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( \"sourceIndex\" in document.documentElement ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.sourceIndex - b.sourceIndex;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( document.createRange ) {\n\tsortOrder = function( a, b ) {\n\t\tvar aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();\n\t\taRange.selectNode(a);\n\t\taRange.collapse(true);\n\t\tbRange.selectNode(b);\n\t\tbRange.collapse(true);\n\t\tvar ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n}\n\n// Check to see if the browser returns elements by name when\n// querying by getElementById (and provide a workaround)\n(function(){\n\t// We're going to inject a fake input element with a specified name\n\tvar form = document.createElement(\"div\"),\n\t\tid = \"script\" + (new Date).getTime();\n\tform.innerHTML = \"<a name='\" + id + \"'/>\";\n\n\t// Inject it into the root element, check its status, and remove it quickly\n\tvar root = document.documentElement;\n\troot.insertBefore( form, root.firstChild );\n\n\t// The workaround has to do additional checks after a getElementById\n\t// Which slows things down for other browsers (hence the branching)\n\tif ( !!document.getElementById( id ) ) {\n\t\tExpr.find.ID = function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : [];\n\t\t\t}\n\t\t};\n\n\t\tExpr.filter.ID = function(elem, match){\n\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\n\t\t};\n\t}\n\n\troot.removeChild( form );\n\troot = form = null; // release memory in IE\n})();\n\n(function(){\n\t// Check to see if the browser returns only elements\n\t// when doing getElementsByTagName(\"*\")\n\n\t// Create a fake element\n\tvar div = document.createElement(\"div\");\n\tdiv.appendChild( document.createComment(\"\") );\n\n\t// Make sure no comments are found\n\tif ( div.getElementsByTagName(\"*\").length > 0 ) {\n\t\tExpr.find.TAG = function(match, context){\n\t\t\tvar results = context.getElementsByTagName(match[1]);\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( match[1] === \"*\" ) {\n\t\t\t\tvar tmp = [];\n\n\t\t\t\tfor ( var i = 0; results[i]; i++ ) {\n\t\t\t\t\tif ( results[i].nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresults = tmp;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// Check to see if an attribute returns normalized href attributes\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\tif ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" &&\n\t\t\tdiv.firstChild.getAttribute(\"href\") !== \"#\" ) {\n\t\tExpr.attrHandle.href = function(elem){\n\t\t\treturn elem.getAttribute(\"href\", 2);\n\t\t};\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.querySelectorAll ) (function(){\n\tvar oldSizzle = Sizzle, div = document.createElement(\"div\");\n\tdiv.innerHTML = \"<p class='TEST'></p>\";\n\n\t// Safari can't handle uppercase or unicode characters when\n\t// in quirks mode.\n\tif ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) {\n\t\treturn;\n\t}\n\t\n\tSizzle = function(query, context, extra, seed){\n\t\tcontext = context || document;\n\n\t\t// Only use querySelectorAll on non-XML documents\n\t\t// (ID selectors don't work in non-HTML documents)\n\t\tif ( !seed && context.nodeType === 9 && !isXML(context) ) {\n\t\t\ttry {\n\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\n\t\t\t} catch(e){}\n\t\t}\n\t\t\n\t\treturn oldSizzle(query, context, extra, seed);\n\t};\n\n\tfor ( var prop in oldSizzle ) {\n\t\tSizzle[ prop ] = oldSizzle[ prop ];\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) (function(){\n\tvar div = document.createElement(\"div\");\n\tdiv.innerHTML = \"<div class='test e'></div><div class='test'></div>\";\n\n\t// Opera can't find a second classname (in 9.6)\n\tif ( div.getElementsByClassName(\"e\").length === 0 )\n\t\treturn;\n\n\t// Safari caches class attributes, doesn't catch changes (in 3.2)\n\tdiv.lastChild.className = \"e\";\n\n\tif ( div.getElementsByClassName(\"e\").length === 1 )\n\t\treturn;\n\n\tExpr.order.splice(1, 0, \"CLASS\");\n\tExpr.find.CLASS = function(match, context, isXML) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) {\n\t\t\treturn context.getElementsByClassName(match[1]);\n\t\t}\n\t};\n\n\tdiv = null; // release memory in IE\n})();\n\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == \"previousSibling\" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ){\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 && !isXML ){\n\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\telem.sizset = i;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeName === cur ) {\n\t\t\t\t\tmatch = elem;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == \"previousSibling\" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ) {\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !isXML ) {\n\t\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\t\telem.sizset = i;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof cur !== \"string\" ) {\n\t\t\t\t\t\tif ( elem === cur ) {\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\n\t\t\t\t\t\tmatch = elem;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nvar contains = document.compareDocumentPosition ?  function(a, b){\n\treturn a.compareDocumentPosition(b) & 16;\n} : function(a, b){\n\treturn a !== b && (a.contains ? a.contains(b) : true);\n};\n\nvar isXML = function(elem){\n\treturn elem.nodeType === 9 && elem.documentElement.nodeName !== \"HTML\" ||\n\t\t!!elem.ownerDocument && elem.ownerDocument.documentElement.nodeName !== \"HTML\";\n};\n\nvar posProcess = function(selector, context){\n\tvar tmpSet = [], later = \"\", match,\n\t\troot = context.nodeType ? [context] : context;\n\n\t// Position selectors must be done after the filter\n\t// And so must :not(positional) so we move all PSEUDOs to the end\n\twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\n\t\tlater += match[0];\n\t\tselector = selector.replace( Expr.match.PSEUDO, \"\" );\n\t}\n\n\tselector = Expr.relative[selector] ? selector + \"*\" : selector;\n\n\tfor ( var i = 0, l = root.length; i < l; i++ ) {\n\t\tSizzle( selector, root[i], tmpSet );\n\t}\n\n\treturn Sizzle.filter( later, tmpSet );\n};\n\nreturn Sizzle;\n\n})();\n","pre":true},"util/browserdetect.js":{"path":"util/browserdetect.js","friendlyPath":"jsio.util.browserdetect","directory":"util/","filename":"browserdetect.js","src":"exports.BrowserDetect = new function() {\n\tvar versionSearchString;\n\tvar dataBrowser = [\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Chrome\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"OmniWeb\",\n\t\t\tversionSearch: \"OmniWeb/\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"Apple\",\n\t\t\tidentity: \"Safari\",\n\t\t\tversionSearch: \"Version\"\n\t\t},\n\t\t{\n\t\t\tprop: window.opera,\n\t\t\tidentity: \"Opera\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"iCab\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"KDE\",\n\t\t\tidentity: \"Konqueror\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Firefox\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"Camino\"\n\t\t},\n\t\t{\t\t// for newer Netscapes (6+)\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Netscape\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"MSIE\",\n\t\t\tidentity: \"IE\",\n\t\t\tversionSearch: \"MSIE\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Gecko\",\n\t\t\tidentity: \"Mozilla\",\n\t\t\tversionSearch: \"rv\"\n\t\t},\n\t\t{ \t\t// for older Netscapes (4-)\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Mozilla\",\n\t\t\tidentity: \"Netscape\",\n\t\t\tversionSearch: \"Mozilla\"\n\t\t}\n\t];\n\t\n\tvar dataOS = [\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: \"Win\",\n\t\t\tidentity: \"Windows\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: \"Mac\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"iPhone\",\n\t\t\tidentity: \"iPhone/iPod\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: \"Linux\"\n\t\t}\n\t];\n\t\n\tfunction searchString(data) {\n\t\tfor (var i=0,item;item=data[i];i++)\t{\n\t\t\tvar dataString = item.string;\n\t\t\tvar dataProp = item.prop;\n\t\t\titem.identity = item.identity || item.subString;\n\t\t\tversionSearchString = item.versionSearch || item.identity;\n\t\t\tif (dataString) {\n\t\t\t\tif (dataString.indexOf(item.subString) != -1)\n\t\t\t\t\treturn item.identity;\n\t\t\t} else if (dataProp)\n\t\t\t\treturn item.identity;\n\t\t}\n\t}\n\t\n\tfunction searchVersion(dataString) {\n        if (dataString && typeof dataString === 'string') {\n            var index = dataString.indexOf(versionSearchString);\n            if (index == -1) return;\n            return parseFloat(dataString.substring(index+versionSearchString.length+1));\n        }\n        return;\n\t}\n\t\n\tthis.browser = searchString(dataBrowser) || \"unknown\";\n\tthis.version = searchVersion(navigator.userAgent)\n\t\t|| searchVersion(navigator.appVersion)\n\t\t|| \"unknown\";\n\tthis.OS = searchString(dataOS) || \"unknown\";\n\tthis.isWebKit = RegExp(\" AppleWebKit/\").test(navigator.userAgent);\n\tthis['is'+this.browser] = this.version;\n};\n","pre":true},"util/esprima.js":{"path":"util/esprima.js","friendlyPath":"jsio.util.esprima","directory":"util/","filename":"esprima.js","src":"/*\n  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PlaceHolders,\n        Messages,\n        Regex,\n        source,\n        strict,\n        sourceType,\n        index,\n        lineNumber,\n        lineStart,\n        hasLineTerminator,\n        lastIndex,\n        lastLineNumber,\n        lastLineStart,\n        startIndex,\n        startLineNumber,\n        startLineStart,\n        scanning,\n        length,\n        lookahead,\n        state,\n        extra,\n        isBindingElement,\n        isAssignmentTarget,\n        firstCoverInitializedNameError;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n    TokenName[Token.Template] = 'Template';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForOfStatement: 'ForOfStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    PlaceHolders = {\n        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedTemplate: 'Unexpected quasi %0',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        IllegalYield: 'Unexpected token yield',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode',\n        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n        DefaultRestParameter: 'Unexpected token =',\n        ObjectPatternAsRestParameter: 'Unexpected token {',\n        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n        ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n        DuplicateConstructor: 'A class may only have one constructor',\n        StaticPrototype: 'Classes may not have static property named prototype',\n        MissingFromClause: 'Unexpected token',\n        NoAsAfterImportNamespace: 'Unexpected token',\n        InvalidModuleSpecifier: 'Unexpected token',\n        IllegalImportDeclaration: 'Unexpected token',\n        IllegalExportDeclaration: 'Unexpected token',\n        DuplicateBinding: 'Duplicate binding %0'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 0x30 && ch <= 0x39);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n    function octalToDecimal(ch) {\n        // \\0 is not octal escape sequence\n        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);\n\n        if (index < length && isOctalDigit(source[index])) {\n            octal = true;\n            code = code * 8 + '01234567'.indexOf(source[index++]);\n\n            // 3 digits are only allowed when string starts\n            // with 0, 1, 2, 3\n            if ('0123'.indexOf(ch) >= 0 &&\n                    index < length &&\n                    isOctalDigit(source[index])) {\n                code = code * 8 + '01234567'.indexOf(source[index++]);\n            }\n        }\n\n        return {\n            code: code,\n            octal: octal\n        };\n    }\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'enum':\n        case 'export':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    // 11.6.2.2 Future Reserved Words\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function skipSingleLineComment(offset) {\n        var start, loc, ch, comment;\n\n        start = index - offset;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - offset\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                if (extra.comments) {\n                    comment = source.slice(start + offset, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + offset, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                hasLineTerminator = true;\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        // Ran off the end of the file - the whole thing is a comment\n        if (extra.comments) {\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            comment = source.slice(start + 2, index);\n            addComment('Block', comment, start, index, loc);\n        }\n        tolerateUnexpectedToken();\n    }\n\n    function skipComment() {\n        var ch, start;\n        hasLineTerminator = false;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment(2);\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment(3);\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment(4);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwUnexpectedToken();\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwUnexpectedToken();\n        }\n\n        // UTF-16 Encoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        cu1 = ((code - 0x10000) >> 10) + 0xD800;\n        cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n        return String.fromCharCode(cu1, cu2);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (ch === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwUnexpectedToken();\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwUnexpectedToken();\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (ch === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwUnexpectedToken();\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwUnexpectedToken();\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var token, str;\n\n        token = {\n            type: Token.Punctuator,\n            value: '',\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: index,\n            end: index\n        };\n\n        // Check for most common single-character punctuators.\n        str = source[index];\n        switch (str) {\n\n        case '(':\n            if (extra.tokenize) {\n                extra.openParenToken = extra.tokens.length;\n            }\n            ++index;\n            break;\n\n        case '{':\n            if (extra.tokenize) {\n                extra.openCurlyToken = extra.tokens.length;\n            }\n            state.curlyStack.push('{');\n            ++index;\n            break;\n\n        case '.':\n            ++index;\n            if (source[index] === '.' && source[index + 1] === '.') {\n                // Spread operator: ...\n                index += 2;\n                str = '...';\n            }\n            break;\n\n        case '}':\n            ++index;\n            state.curlyStack.pop();\n            break;\n        case ')':\n        case ';':\n        case ',':\n        case '[':\n        case ']':\n        case ':':\n        case '?':\n        case '~':\n            ++index;\n            break;\n\n        default:\n            // 4-character punctuator.\n            str = source.substr(index, 4);\n            if (str === '>>>=') {\n                index += 4;\n            } else {\n\n                // 3-character punctuators.\n                str = str.substr(0, 3);\n                if (str === '===' || str === '!==' || str === '>>>' ||\n                    str === '<<=' || str === '>>=') {\n                    index += 3;\n                } else {\n\n                    // 2-character punctuators.\n                    str = str.substr(0, 2);\n                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||\n                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||\n                        str === '++' || str === '--' || str === '<<' || str === '>>' ||\n                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||\n                        str === '<=' || str === '>=' || str === '=>') {\n                        index += 2;\n                    } else {\n\n                        // 1-character punctuators.\n                        str = source[index];\n                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                            ++index;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (index === token.start) {\n            throwUnexpectedToken();\n        }\n\n        token.end = index;\n        token.value = str;\n        return token;\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanBinaryLiteral(start) {\n        var ch, number;\n\n        number = '';\n\n        while (index < length) {\n            ch = source[index];\n            if (ch !== '0' && ch !== '1') {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            // only 0b or 0B\n            throwUnexpectedToken();\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            /* istanbul ignore else */\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                throwUnexpectedToken();\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 2),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function isImplicitOctalLiteral() {\n        var i, ch;\n\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (i = index + 1; i < length; ++i) {\n            ch = source[i];\n            if (ch === '8' || ch === '9') {\n                return false;\n            }\n            if (!isOctalDigit(ch)) {\n                return true;\n            }\n        }\n\n        return true;\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    return scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O') {\n                    return scanOctalLiteral(ch, start);\n                }\n\n                if (isOctalDigit(ch)) {\n                    if (isImplicitOctalLiteral()) {\n                        return scanOctalLiteral(ch, start);\n                    }\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwUnexpectedToken();\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, unescaped, octToDec, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            unescaped = scanHexEscape(ch);\n                            if (!unescaped) {\n                                throw throwUnexpectedToken();\n                            }\n                            str += unescaped;\n                        }\n                        break;\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n                    case '8':\n                    case '9':\n                        throw throwUnexpectedToken();\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            octToDec = octalToDecimal(ch);\n\n                            octal = octToDec.octal || octal;\n                            str += String.fromCharCode(octToDec.code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: startLineNumber,\n            lineStart: startLineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanTemplate() {\n        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;\n\n        terminated = false;\n        tail = false;\n        start = index;\n        head = (source[index] === '`');\n        rawOffset = 2;\n\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                rawOffset = 1;\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    state.curlyStack.push('${');\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\v';\n                        break;\n\n                    default:\n                        if (ch === '0') {\n                            if (isDecimalDigit(source.charCodeAt(index))) {\n                                // Illegal: \\01 \\02 and so on\n                                throwError(Messages.TemplateOctalLiteral);\n                            }\n                            cooked += '\\0';\n                        } else if (isOctalDigit(ch)) {\n                            // Illegal: \\1 \\2\n                            throwError(Messages.TemplateOctalLiteral);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                lineStart = index;\n                cooked += '\\n';\n            } else {\n                cooked += ch;\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken();\n        }\n\n        if (!head) {\n            state.curlyStack.pop();\n        }\n\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - rawOffset)\n            },\n            head: head,\n            tail: tail,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function testRegExp(pattern, flags) {\n        // The BMP character to use as a replacement for astral symbols when\n        // translating an ES6 \"u\"-flagged pattern to an ES5-compatible\n        // approximation.\n        // Note: replacing with '\\uFFFF' enables false positives in unlikely\n        // scenarios. For example, `[\\u{1044f}-\\u{10440}]` is an invalid\n        // pattern that would not be detected by this substitution.\n        var astralSubstitute = '\\uFFFF',\n            tmp = pattern;\n\n        if (flags.indexOf('u') >= 0) {\n            tmp = tmp\n                // Replace every Unicode escape sequence with the equivalent\n                // BMP character or a constant ASCII code point in the case of\n                // astral symbols. (See the above note on `astralSubstitute`\n                // for more information.)\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {\n                    var codePoint = parseInt($1 || $2, 16);\n                    if (codePoint > 0x10FFFF) {\n                        throwUnexpectedToken(null, Messages.InvalidRegExp);\n                    }\n                    if (codePoint <= 0xFFFF) {\n                        return String.fromCharCode(codePoint);\n                    }\n                    return astralSubstitute;\n                })\n                // Replace each paired surrogate with a single ASCII symbol to\n                // avoid throwing on regular expressions that are only valid in\n                // combination with the \"u\" flag.\n                .replace(\n                    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n                    astralSubstitute\n                );\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            RegExp(tmp);\n        } catch (e) {\n            throwUnexpectedToken(null, Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        } catch (exception) {\n            return null;\n        }\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    tolerateUnexpectedToken();\n                } else {\n                    str += '\\\\';\n                    tolerateUnexpectedToken();\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        scanning = true;\n        var start, body, flags, value;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n        scanning = false;\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: body.value,\n                    flags: flags.value\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            regex: {\n                pattern: body.value,\n                flags: flags.value\n            },\n            start: start,\n            end: index\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        /* istanbul ignore next */\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ']') {\n                return scanPunctuator();\n            }\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch, token;\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: index,\n                end: index\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        if (isIdentifierStart(ch)) {\n            token = scanIdentifier();\n            if (strict && isStrictModeReservedWord(token.value)) {\n                token.type = Token.Keyword;\n            }\n            return token;\n        }\n\n        // Very common: ( and ) and ;\n        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (ch === 0x27 || ch === 0x22) {\n            return scanStringLiteral();\n        }\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && ch === 0x2F) {\n            return advanceSlash();\n        }\n\n        // Template literals start with ` (U+0060) for template head\n        // or } (U+007D) for template middle or template tail.\n        if (ch === 0x60 || (ch === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {\n            return scanTemplate();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var loc, token, value, entry;\n\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            value = source.slice(token.start, token.end);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: [token.start, token.end],\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n        scanning = true;\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        skipComment();\n\n        token = lookahead;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n        return token;\n    }\n\n    function peek() {\n        scanning = true;\n\n        skipComment();\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n    }\n\n    function Position() {\n        this.line = startLineNumber;\n        this.column = startIndex - startLineStart;\n    }\n\n    function SourceLocation() {\n        this.start = new Position();\n        this.end = null;\n    }\n\n    function WrappingSourceLocation(startToken) {\n        this.start = {\n            line: startToken.lineNumber,\n            column: startToken.start - startToken.lineStart\n        };\n        this.end = null;\n    }\n\n    function Node() {\n        if (extra.range) {\n            this.range = [startIndex, 0];\n        }\n        if (extra.loc) {\n            this.loc = new SourceLocation();\n        }\n    }\n\n    function WrappingNode(startToken) {\n        if (extra.range) {\n            this.range = [startToken.start, 0];\n        }\n        if (extra.loc) {\n            this.loc = new WrappingSourceLocation(startToken);\n        }\n    }\n\n    WrappingNode.prototype = Node.prototype = {\n\n        processComment: function () {\n            var lastChild,\n                leadingComments,\n                trailingComments,\n                bottomRight = extra.bottomRightStack,\n                i,\n                comment,\n                last = bottomRight[bottomRight.length - 1];\n\n            if (this.type === Syntax.Program) {\n                if (this.body.length > 0) {\n                    return;\n                }\n            }\n\n            if (extra.trailingComments.length > 0) {\n                trailingComments = [];\n                for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n                    comment = extra.trailingComments[i];\n                    if (comment.range[0] >= this.range[1]) {\n                        trailingComments.unshift(comment);\n                        extra.trailingComments.splice(i, 1);\n                    }\n                }\n                extra.trailingComments = [];\n            } else {\n                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n                    trailingComments = last.trailingComments;\n                    delete last.trailingComments;\n                }\n            }\n\n            // Eating the stack.\n            while (last && last.range[0] >= this.range[0]) {\n                lastChild = bottomRight.pop();\n                last = bottomRight[bottomRight.length - 1];\n            }\n\n            if (lastChild) {\n                if (lastChild.leadingComments) {\n                    leadingComments = [];\n                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {\n                        comment = lastChild.leadingComments[i];\n                        if (comment.range[1] <= this.range[0]) {\n                            leadingComments.unshift(comment);\n                            lastChild.leadingComments.splice(i, 1);\n                        }\n                    }\n\n                    if (!lastChild.leadingComments.length) {\n                        lastChild.leadingComments = undefined;\n                    }\n                }\n            } else if (extra.leadingComments.length > 0) {\n                leadingComments = [];\n                for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n                    comment = extra.leadingComments[i];\n                    if (comment.range[1] <= this.range[0]) {\n                        leadingComments.unshift(comment);\n                        extra.leadingComments.splice(i, 1);\n                    }\n                }\n            }\n\n\n            if (leadingComments && leadingComments.length > 0) {\n                this.leadingComments = leadingComments;\n            }\n            if (trailingComments && trailingComments.length > 0) {\n                this.trailingComments = trailingComments;\n            }\n\n            bottomRight.push(this);\n        },\n\n        finish: function () {\n            if (extra.range) {\n                this.range[1] = lastIndex;\n            }\n            if (extra.loc) {\n                this.loc.end = {\n                    line: lastLineNumber,\n                    column: lastIndex - lastLineStart\n                };\n                if (extra.source) {\n                    this.loc.source = extra.source;\n                }\n            }\n\n            if (extra.attachComment) {\n                this.processComment();\n            }\n        },\n\n        finishArrayExpression: function (elements) {\n            this.type = Syntax.ArrayExpression;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrayPattern: function (elements) {\n            this.type = Syntax.ArrayPattern;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrowFunctionExpression: function (params, defaults, body, expression) {\n            this.type = Syntax.ArrowFunctionExpression;\n            this.id = null;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = false;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentExpression: function (operator, left, right) {\n            this.type = Syntax.AssignmentExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentPattern: function (left, right) {\n            this.type = Syntax.AssignmentPattern;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBinaryExpression: function (operator, left, right) {\n            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBlockStatement: function (body) {\n            this.type = Syntax.BlockStatement;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishBreakStatement: function (label) {\n            this.type = Syntax.BreakStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishCallExpression: function (callee, args) {\n            this.type = Syntax.CallExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishCatchClause: function (param, body) {\n            this.type = Syntax.CatchClause;\n            this.param = param;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassBody: function (body) {\n            this.type = Syntax.ClassBody;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassDeclaration: function (id, superClass, body) {\n            this.type = Syntax.ClassDeclaration;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassExpression: function (id, superClass, body) {\n            this.type = Syntax.ClassExpression;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishConditionalExpression: function (test, consequent, alternate) {\n            this.type = Syntax.ConditionalExpression;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishContinueStatement: function (label) {\n            this.type = Syntax.ContinueStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishDebuggerStatement: function () {\n            this.type = Syntax.DebuggerStatement;\n            this.finish();\n            return this;\n        },\n\n        finishDoWhileStatement: function (body, test) {\n            this.type = Syntax.DoWhileStatement;\n            this.body = body;\n            this.test = test;\n            this.finish();\n            return this;\n        },\n\n        finishEmptyStatement: function () {\n            this.type = Syntax.EmptyStatement;\n            this.finish();\n            return this;\n        },\n\n        finishExpressionStatement: function (expression) {\n            this.type = Syntax.ExpressionStatement;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishForStatement: function (init, test, update, body) {\n            this.type = Syntax.ForStatement;\n            this.init = init;\n            this.test = test;\n            this.update = update;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForOfStatement: function (left, right, body) {\n            this.type = Syntax.ForOfStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForInStatement: function (left, right, body) {\n            this.type = Syntax.ForInStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.each = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionDeclaration: function (id, params, defaults, body, generator) {\n            this.type = Syntax.FunctionDeclaration;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = generator;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionExpression: function (id, params, defaults, body, generator) {\n            this.type = Syntax.FunctionExpression;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = generator;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishIdentifier: function (name) {\n            this.type = Syntax.Identifier;\n            this.name = name;\n            this.finish();\n            return this;\n        },\n\n        finishIfStatement: function (test, consequent, alternate) {\n            this.type = Syntax.IfStatement;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishLabeledStatement: function (label, body) {\n            this.type = Syntax.LabeledStatement;\n            this.label = label;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishLiteral: function (token) {\n            this.type = Syntax.Literal;\n            this.value = token.value;\n            this.raw = source.slice(token.start, token.end);\n            if (token.regex) {\n                this.regex = token.regex;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishMemberExpression: function (accessor, object, property) {\n            this.type = Syntax.MemberExpression;\n            this.computed = accessor === '[';\n            this.object = object;\n            this.property = property;\n            this.finish();\n            return this;\n        },\n\n        finishNewExpression: function (callee, args) {\n            this.type = Syntax.NewExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishObjectExpression: function (properties) {\n            this.type = Syntax.ObjectExpression;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishObjectPattern: function (properties) {\n            this.type = Syntax.ObjectPattern;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishPostfixExpression: function (operator, argument) {\n            this.type = Syntax.UpdateExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = false;\n            this.finish();\n            return this;\n        },\n\n        finishProgram: function (body) {\n            this.type = Syntax.Program;\n            this.body = body;\n            if (sourceType === 'module') {\n                // very restrictive for now\n                this.sourceType = sourceType;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishProperty: function (kind, key, computed, value, method, shorthand) {\n            this.type = Syntax.Property;\n            this.key = key;\n            this.computed = computed;\n            this.value = value;\n            this.kind = kind;\n            this.method = method;\n            this.shorthand = shorthand;\n            this.finish();\n            return this;\n        },\n\n        finishRestElement: function (argument) {\n            this.type = Syntax.RestElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishReturnStatement: function (argument) {\n            this.type = Syntax.ReturnStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSequenceExpression: function (expressions) {\n            this.type = Syntax.SequenceExpression;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishSpreadElement: function (argument) {\n            this.type = Syntax.SpreadElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchCase: function (test, consequent) {\n            this.type = Syntax.SwitchCase;\n            this.test = test;\n            this.consequent = consequent;\n            this.finish();\n            return this;\n        },\n\n        finishSuper: function () {\n            this.type = Syntax.Super;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchStatement: function (discriminant, cases) {\n            this.type = Syntax.SwitchStatement;\n            this.discriminant = discriminant;\n            this.cases = cases;\n            this.finish();\n            return this;\n        },\n\n        finishTaggedTemplateExpression: function (tag, quasi) {\n            this.type = Syntax.TaggedTemplateExpression;\n            this.tag = tag;\n            this.quasi = quasi;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateElement: function (value, tail) {\n            this.type = Syntax.TemplateElement;\n            this.value = value;\n            this.tail = tail;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateLiteral: function (quasis, expressions) {\n            this.type = Syntax.TemplateLiteral;\n            this.quasis = quasis;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishThisExpression: function () {\n            this.type = Syntax.ThisExpression;\n            this.finish();\n            return this;\n        },\n\n        finishThrowStatement: function (argument) {\n            this.type = Syntax.ThrowStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishTryStatement: function (block, handler, finalizer) {\n            this.type = Syntax.TryStatement;\n            this.block = block;\n            this.guardedHandlers = [];\n            this.handlers = handler ? [ handler ] : [];\n            this.handler = handler;\n            this.finalizer = finalizer;\n            this.finish();\n            return this;\n        },\n\n        finishUnaryExpression: function (operator, argument) {\n            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = true;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclaration: function (declarations) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = 'var';\n            this.finish();\n            return this;\n        },\n\n        finishLexicalDeclaration: function (declarations, kind) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = kind;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclarator: function (id, init) {\n            this.type = Syntax.VariableDeclarator;\n            this.id = id;\n            this.init = init;\n            this.finish();\n            return this;\n        },\n\n        finishWhileStatement: function (test, body) {\n            this.type = Syntax.WhileStatement;\n            this.test = test;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishWithStatement: function (object, body) {\n            this.type = Syntax.WithStatement;\n            this.object = object;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishExportSpecifier: function (local, exported) {\n            this.type = Syntax.ExportSpecifier;\n            this.exported = exported || local;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportDefaultSpecifier: function (local) {\n            this.type = Syntax.ImportDefaultSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportNamespaceSpecifier: function (local) {\n            this.type = Syntax.ImportNamespaceSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishExportNamedDeclaration: function (declaration, specifiers, src) {\n            this.type = Syntax.ExportNamedDeclaration;\n            this.declaration = declaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishExportDefaultDeclaration: function (declaration) {\n            this.type = Syntax.ExportDefaultDeclaration;\n            this.declaration = declaration;\n            this.finish();\n            return this;\n        },\n\n        finishExportAllDeclaration: function (src) {\n            this.type = Syntax.ExportAllDeclaration;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishImportSpecifier: function (local, imported) {\n            this.type = Syntax.ImportSpecifier;\n            this.local = local || imported;\n            this.imported = imported;\n            this.finish();\n            return this;\n        },\n\n        finishImportDeclaration: function (specifiers, src) {\n            this.type = Syntax.ImportDeclaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishYieldExpression: function (argument, delegate) {\n            this.type = Syntax.YieldExpression;\n            this.argument = argument;\n            this.delegate = delegate;\n            this.finish();\n            return this;\n        }\n    };\n\n\n    function recordError(error) {\n        var e, existing;\n\n        for (e = 0; e < extra.errors.length; e++) {\n            existing = extra.errors[e];\n            // Prevent duplicated error.\n            /* istanbul ignore next */\n            if (existing.index === error.index && existing.message === error.message) {\n                return;\n            }\n        }\n\n        extra.errors.push(error);\n    }\n\n    function createError(line, pos, description) {\n        var error = new Error('Line ' + line + ': ' + description);\n        error.index = pos;\n        error.lineNumber = line;\n        error.column = pos - (scanning ? lineStart : lastLineStart) + 1;\n        error.description = description;\n        return error;\n    }\n\n    // Throw an exception\n\n    function throwError(messageFormat) {\n        var args, msg;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        throw createError(lastLineNumber, lastIndex, msg);\n    }\n\n    function tolerateError(messageFormat) {\n        var args, msg, error;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        /* istanbul ignore next */\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        error = createError(lineNumber, lastIndex, msg);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Throw an exception because of the token.\n\n    function unexpectedTokenError(token, message) {\n        var value, msg = message || Messages.UnexpectedToken;\n\n        if (token) {\n            if (!message) {\n                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :\n                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :\n                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :\n                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :\n                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :\n                    Messages.UnexpectedToken;\n\n                if (token.type === Token.Keyword) {\n                    if (isFutureReservedWord(token.value)) {\n                        msg = Messages.UnexpectedReserved;\n                    } else if (strict && isStrictModeReservedWord(token.value)) {\n                        msg = Messages.StrictReservedWord;\n                    }\n                }\n            }\n\n            value = (token.type === Token.Template) ? token.value.raw : token.value;\n        } else {\n            value = 'ILLEGAL';\n        }\n\n        msg = msg.replace('%0', value);\n\n        return (token && typeof token.lineNumber === 'number') ?\n            createError(token.lineNumber, token.start, msg) :\n            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);\n    }\n\n    function throwUnexpectedToken(token, message) {\n        throw unexpectedTokenError(token, message);\n    }\n\n    function tolerateUnexpectedToken(token, message) {\n        var error = unexpectedTokenError(token, message);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    /**\n     * @name expectCommaSeparator\n     * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n     * to <code>expect(value)</code>\n     * @since 2.0\n     */\n    function expectCommaSeparator() {\n        var token;\n\n        if (extra.errors) {\n            token = lookahead;\n            if (token.type === Token.Punctuator && token.value === ',') {\n                lex();\n            } else if (token.type === Token.Punctuator && token.value === ';') {\n                lex();\n                tolerateUnexpectedToken(token);\n            } else {\n                tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n            }\n        } else {\n            expect(',');\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token matches the specified contextual keyword\n    // (where an identifier is sometimes a keyword depending on the context)\n\n    function matchContextualKeyword(keyword) {\n        return lookahead.type === Token.Identifier && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {\n            lex();\n            return;\n        }\n\n        if (hasLineTerminator) {\n            return;\n        }\n\n        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.\n        lastIndex = startIndex;\n        lastLineNumber = startLineNumber;\n        lastLineStart = startLineStart;\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpectedToken(lookahead);\n        }\n    }\n\n    // Cover grammar support.\n    //\n    // When an assignment expression position starts with an left parenthesis, the determination of the type\n    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n    //\n    // There are three productions that can be parsed in a parentheses pair that needs to be determined\n    // after the outermost pair is closed. They are:\n    //\n    //   1. AssignmentExpression\n    //   2. BindingElements\n    //   3. AssignmentTargets\n    //\n    // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n    // binding element or assignment target.\n    //\n    // The three productions have the relationship:\n    //\n    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression\n    //\n    // with a single exception that CoverInitializedName when used directly in an Expression, generates\n    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n    //\n    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n    // the CoverInitializedName check is conducted.\n    //\n    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n    // pattern. The CoverInitializedName check is deferred.\n    function isolateCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        if (firstCoverInitializedNameError !== null) {\n            throwUnexpectedToken(firstCoverInitializedNameError);\n        }\n        isBindingElement = oldIsBindingElement;\n        isAssignmentTarget = oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;\n        return result;\n    }\n\n    function inheritCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        isBindingElement = isBindingElement && oldIsBindingElement;\n        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;\n        return result;\n    }\n\n    function parseArrayPattern(params) {\n        var node = new Node(), elements = [], rest, restNode;\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                if (match('...')) {\n                    restNode = new Node();\n                    lex();\n                    params.push(lookahead);\n                    rest = parseVariableIdentifier(params);\n                    elements.push(restNode.finishRestElement(rest));\n                    break;\n                } else {\n                    elements.push(parsePatternWithDefault(params));\n                }\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n\n        }\n\n        expect(']');\n\n        return node.finishArrayPattern(elements);\n    }\n\n    function parsePropertyPattern(params) {\n        var node = new Node(), key, keyToken, computed = match('['), init;\n        if (lookahead.type === Token.Identifier) {\n            keyToken = lookahead;\n            key = parseVariableIdentifier();\n            if (match('=')) {\n                params.push(keyToken);\n                lex();\n                init = parseAssignmentExpression();\n\n                return node.finishProperty(\n                    'init', key, false,\n                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, false);\n            } else if (!match(':')) {\n                params.push(keyToken);\n                return node.finishProperty('init', key, false, key, false, true);\n            }\n        } else {\n            key = parseObjectPropertyKey(params);\n        }\n        expect(':');\n        init = parsePatternWithDefault(params);\n        return node.finishProperty('init', key, computed, init, false, false);\n    }\n\n    function parseObjectPattern(params) {\n        var node = new Node(), properties = [];\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parsePropertyPattern(params));\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        lex();\n\n        return node.finishObjectPattern(properties);\n    }\n\n    function parsePattern(params) {\n        var identifier;\n        if (lookahead.type === Token.Identifier) {\n            params.push(lookahead);\n            identifier = parseVariableIdentifier();\n            return identifier;\n        } else if (match('[')) {\n            return parseArrayPattern(params);\n        } else if (match('{')) {\n            return parseObjectPattern(params);\n        }\n        throwUnexpectedToken(lookahead);\n    }\n\n    function parsePatternWithDefault(params) {\n        var startToken = lookahead, pattern, right;\n        pattern = parsePattern(params);\n        if (match('=')) {\n            lex();\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);\n        }\n        return pattern;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], node = new Node(), restSpread;\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else if (match('...')) {\n                restSpread = new Node();\n                lex();\n                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    isAssignmentTarget = isBindingElement = false;\n                    expect(',');\n                }\n                elements.push(restSpread);\n            } else {\n                elements.push(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        lex();\n\n        return node.finishArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(node, paramInfo, isGenerator) {\n        var previousStrict, body;\n\n        isAssignmentTarget = isBindingElement = false;\n\n        previousStrict = strict;\n        body = isolateCoverGrammar(parseFunctionSourceElements);\n\n        if (strict && paramInfo.firstRestricted) {\n            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);\n        }\n        if (strict && paramInfo.stricted) {\n            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);\n        }\n\n        strict = previousStrict;\n        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);\n    }\n\n    function parsePropertyMethodFunction() {\n        var params, method, node = new Node(),\n            previousAllowYield = state.allowYield;\n\n        state.allowYield = false;\n        params = parseParams();\n        state.allowYield = previousAllowYield;\n\n        state.allowYield = false;\n        method = parsePropertyFunction(node, params, false);\n        state.allowYield = previousAllowYield;\n\n        return method;\n    }\n\n    function parseObjectPropertyKey() {\n        var token, node = new Node(), expr;\n\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        switch (token.type) {\n        case Token.StringLiteral:\n        case Token.NumericLiteral:\n            if (strict && token.octal) {\n                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n            }\n            return node.finishLiteral(token);\n        case Token.Identifier:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.Keyword:\n            return node.finishIdentifier(token.value);\n        case Token.Punctuator:\n            if (token.value === '[') {\n                expr = isolateCoverGrammar(parseAssignmentExpression);\n                expect(']');\n                return expr;\n            }\n            break;\n        }\n        throwUnexpectedToken(token);\n    }\n\n    function lookaheadPropertyName() {\n        switch (lookahead.type) {\n        case Token.Identifier:\n        case Token.StringLiteral:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.NumericLiteral:\n        case Token.Keyword:\n            return true;\n        case Token.Punctuator:\n            return lookahead.value === '[';\n        }\n        return false;\n    }\n\n    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,\n    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.\n    // This can only be determined after we consumed up to the left parentheses.\n    //\n    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller\n    // is responsible to visit other options.\n    function tryParseMethodDefinition(token, key, computed, node) {\n        var value, options, methodNode, params,\n            previousAllowYield = state.allowYield;\n\n        if (token.type === Token.Identifier) {\n            // check for `get` and `set`;\n\n            if (token.value === 'get' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n                expect(')');\n\n                state.allowYield = false;\n                value = parsePropertyFunction(methodNode, {\n                    params: [],\n                    defaults: [],\n                    stricted: null,\n                    firstRestricted: null,\n                    message: null\n                }, false);\n                state.allowYield = previousAllowYield;\n\n                return node.finishProperty('get', key, computed, value, false, false);\n            } else if (token.value === 'set' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n\n                options = {\n                    params: [],\n                    defaultCount: 0,\n                    defaults: [],\n                    firstRestricted: null,\n                    paramSet: {}\n                };\n                if (match(')')) {\n                    tolerateUnexpectedToken(lookahead);\n                } else {\n                    state.allowYield = false;\n                    parseParam(options);\n                    state.allowYield = previousAllowYield;\n                    if (options.defaultCount === 0) {\n                        options.defaults = [];\n                    }\n                }\n                expect(')');\n\n                state.allowYield = false;\n                value = parsePropertyFunction(methodNode, options, false);\n                state.allowYield = previousAllowYield;\n\n                return node.finishProperty('set', key, computed, value, false, false);\n            }\n        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {\n            computed = match('[');\n            key = parseObjectPropertyKey();\n            methodNode = new Node();\n\n            state.allowYield = false;\n            params = parseParams();\n            state.allowYield = previousAllowYield;\n\n            state.allowYield = true;\n            value = parsePropertyFunction(methodNode, params, true);\n            state.allowYield = previousAllowYield;\n\n            return node.finishProperty('init', key, computed, value, true, false);\n        }\n\n        if (key && match('(')) {\n            value = parsePropertyMethodFunction();\n            return node.finishProperty('init', key, computed, value, true, false);\n        }\n\n        // Not a MethodDefinition.\n        return null;\n    }\n\n    function checkProto(key, computed, hasProto) {\n        if (computed === false && (key.type === Syntax.Identifier && key.name === '__proto__' ||\n            key.type === Syntax.Literal && key.value === '__proto__')) {\n            if (hasProto.value) {\n                tolerateError(Messages.DuplicateProtoProperty);\n            } else {\n                hasProto.value = true;\n            }\n        }\n    }\n\n    function parseObjectProperty(hasProto) {\n        var token = lookahead, node = new Node(), computed, key, maybeMethod, value;\n\n        computed = match('[');\n        if (match('*')) {\n            lex();\n        } else {\n            key = parseObjectPropertyKey();\n        }\n        maybeMethod = tryParseMethodDefinition(token, key, computed, node);\n\n        if (maybeMethod) {\n            checkProto(maybeMethod.key, maybeMethod.computed, hasProto);\n            // finished\n            return maybeMethod;\n        }\n\n        if (!key) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        // init property or short hand property.\n        checkProto(key, computed, hasProto);\n\n        if (match(':')) {\n            lex();\n            value = inheritCoverGrammar(parseAssignmentExpression);\n            return node.finishProperty('init', key, computed, value, false, false);\n        }\n\n        if (token.type === Token.Identifier) {\n            if (match('=')) {\n                firstCoverInitializedNameError = lookahead;\n                lex();\n                value = isolateCoverGrammar(parseAssignmentExpression);\n                return node.finishProperty('init', key, computed,\n                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);\n            }\n            return node.finishProperty('init', key, computed, key, false, true);\n        }\n\n        throwUnexpectedToken(lookahead);\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], hasProto = {value: false}, node = new Node();\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parseObjectProperty(hasProto));\n\n            if (!match('}')) {\n                expectCommaSeparator();\n            }\n        }\n\n        expect('}');\n\n        return node.finishObjectExpression(properties);\n    }\n\n    function reinterpretExpressionAsPattern(expr) {\n        var i;\n        switch (expr.type) {\n        case Syntax.Identifier:\n        case Syntax.MemberExpression:\n        case Syntax.RestElement:\n        case Syntax.AssignmentPattern:\n            break;\n        case Syntax.SpreadElement:\n            expr.type = Syntax.RestElement;\n            reinterpretExpressionAsPattern(expr.argument);\n            break;\n        case Syntax.ArrayExpression:\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0; i < expr.elements.length; i++) {\n                if (expr.elements[i] !== null) {\n                    reinterpretExpressionAsPattern(expr.elements[i]);\n                }\n            }\n            break;\n        case Syntax.ObjectExpression:\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0; i < expr.properties.length; i++) {\n                reinterpretExpressionAsPattern(expr.properties[i].value);\n            }\n            break;\n        case Syntax.AssignmentExpression:\n            expr.type = Syntax.AssignmentPattern;\n            reinterpretExpressionAsPattern(expr.left);\n            break;\n        default:\n            // Allow other node type for tolerant parsing.\n            break;\n        }\n    }\n\n    function parseTemplateElement(option) {\n        var node, token;\n\n        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {\n            throwUnexpectedToken();\n        }\n\n        node = new Node();\n        token = lex();\n\n        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);\n    }\n\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions, node = new Node();\n\n        quasi = parseTemplateElement({ head: true });\n        quasis = [ quasi ];\n        expressions = [];\n\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n\n        return node.finishTemplateLiteral(quasis, expressions);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr, expressions, startToken, i, params = [];\n\n        expect('(');\n\n        if (match(')')) {\n            lex();\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: [],\n                rawParams: []\n            };\n        }\n\n        startToken = lookahead;\n        if (match('...')) {\n            expr = parseRestElement(params);\n            expect(')');\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: [expr]\n            };\n        }\n\n        isBindingElement = true;\n        expr = inheritCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            isAssignmentTarget = false;\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n\n                if (match('...')) {\n                    if (!isBindingElement) {\n                        throwUnexpectedToken(lookahead);\n                    }\n                    expressions.push(parseRestElement(params));\n                    expect(')');\n                    if (!match('=>')) {\n                        expect('=>');\n                    }\n                    isBindingElement = false;\n                    for (i = 0; i < expressions.length; i++) {\n                        reinterpretExpressionAsPattern(expressions[i]);\n                    }\n                    return {\n                        type: PlaceHolders.ArrowParameterPlaceHolder,\n                        params: expressions\n                    };\n                }\n\n                expressions.push(inheritCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n\n        expect(')');\n\n        if (match('=>')) {\n            if (!isBindingElement) {\n                throwUnexpectedToken(lookahead);\n            }\n\n            if (expr.type === Syntax.SequenceExpression) {\n                for (i = 0; i < expr.expressions.length; i++) {\n                    reinterpretExpressionAsPattern(expr.expressions[i]);\n                }\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            expr = {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]\n            };\n        }\n        isBindingElement = false;\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr, node;\n\n        if (match('(')) {\n            isBindingElement = false;\n            return inheritCoverGrammar(parseGroupExpression);\n        }\n\n        if (match('[')) {\n            return inheritCoverGrammar(parseArrayInitialiser);\n        }\n\n        if (match('{')) {\n            return inheritCoverGrammar(parseObjectInitialiser);\n        }\n\n        type = lookahead.type;\n        node = new Node();\n\n        if (type === Token.Identifier) {\n            expr = node.finishIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            if (strict && lookahead.octal) {\n                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = node.finishLiteral(lex());\n        } else if (type === Token.Keyword) {\n            isAssignmentTarget = isBindingElement = false;\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('this')) {\n                lex();\n                return node.finishThisExpression();\n            }\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n            throwUnexpectedToken(lex());\n        } else if (type === Token.BooleanLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = node.finishLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = null;\n            expr = node.finishLiteral(token);\n        } else if (match('/') || match('/=')) {\n            isAssignmentTarget = isBindingElement = false;\n            index = startIndex;\n\n            if (typeof extra.tokens !== 'undefined') {\n                token = collectRegex();\n            } else {\n                token = scanRegExp();\n            }\n            lex();\n            expr = node.finishLiteral(token);\n        } else if (type === Token.Template) {\n            expr = parseTemplateLiteral();\n        } else {\n            throwUnexpectedToken(lex());\n        }\n\n        return expr;\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [], expr;\n\n        expect('(');\n\n        if (!match(')')) {\n            while (startIndex < length) {\n                if (match('...')) {\n                    expr = new Node();\n                    lex();\n                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));\n                } else {\n                    expr = isolateCoverGrammar(parseAssignmentExpression);\n                }\n                args.push(expr);\n                if (match(')')) {\n                    break;\n                }\n                expectCommaSeparator();\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpectedToken(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = isolateCoverGrammar(parseExpression);\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, node = new Node();\n\n        expectKeyword('new');\n        callee = isolateCoverGrammar(parseLeftHandSideExpression);\n        args = match('(') ? parseArguments() : [];\n\n        isAssignmentTarget = isBindingElement = false;\n\n        return node.finishNewExpression(callee, args);\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n        startToken = lookahead;\n        state.allowIn = true;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('(') && !match('.') && !match('[')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                isBindingElement = false;\n                isAssignmentTarget = false;\n                args = parseArguments();\n                expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n            } else if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        state.allowIn = previousAllowIn;\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var quasi, expr, property, startToken;\n        assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n        startToken = lookahead;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('[') && !match('.')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token, startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);\n\n        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {\n            if (match('++') || match('--')) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    tolerateError(Messages.StrictLHSPostfix);\n                }\n\n                if (!isAssignmentTarget) {\n                    tolerateError(Messages.InvalidLHSInAssignment);\n                }\n\n                isAssignmentTarget = isBindingElement = false;\n\n                token = lex();\n                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr, startToken;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateError(Messages.StrictLHSPrefix);\n            }\n\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                tolerateError(Messages.StrictDelete);\n            }\n            isAssignmentTarget = isBindingElement = false;\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = lookahead;\n        left = inheritCoverGrammar(parseUnaryExpression);\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        isAssignmentTarget = isBindingElement = false;\n        token.prec = prec;\n        lex();\n\n        markers = [marker, lookahead];\n        right = isolateCoverGrammar(parseUnaryExpression);\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                markers.pop();\n                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(lookahead);\n            expr = isolateCoverGrammar(parseUnaryExpression);\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, startToken;\n\n        startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseBinaryExpression);\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = isolateCoverGrammar(parseAssignmentExpression);\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = isolateCoverGrammar(parseAssignmentExpression);\n\n            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n            isAssignmentTarget = isBindingElement = false;\n        }\n\n        return expr;\n    }\n\n    // [ES6] 14.2 Arrow Function\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return isolateCoverGrammar(parseAssignmentExpression);\n    }\n\n    function checkPatternParam(options, param) {\n        var i;\n        switch (param.type) {\n        case Syntax.Identifier:\n            validateParam(options, param, param.name);\n            break;\n        case Syntax.RestElement:\n            checkPatternParam(options, param.argument);\n            break;\n        case Syntax.AssignmentPattern:\n            checkPatternParam(options, param.left);\n            break;\n        case Syntax.ArrayPattern:\n            for (i = 0; i < param.elements.length; i++) {\n                if (param.elements[i] !== null) {\n                    checkPatternParam(options, param.elements[i]);\n                }\n            }\n            break;\n        default:\n            assert(param.type === Syntax.ObjectPattern, 'Invalid type');\n            for (i = 0; i < param.properties.length; i++) {\n                checkPatternParam(options, param.properties[i].value);\n            }\n            break;\n        }\n    }\n    function reinterpretAsCoverFormalsList(expr) {\n        var i, len, param, params, defaults, defaultCount, options, token;\n\n        defaults = [];\n        defaultCount = 0;\n        params = [expr];\n\n        switch (expr.type) {\n        case Syntax.Identifier:\n            break;\n        case PlaceHolders.ArrowParameterPlaceHolder:\n            params = expr.params;\n            break;\n        default:\n            return null;\n        }\n\n        options = {\n            paramSet: {}\n        };\n\n        for (i = 0, len = params.length; i < len; i += 1) {\n            param = params[i];\n            switch (param.type) {\n            case Syntax.AssignmentPattern:\n                params[i] = param.left;\n                defaults.push(param.right);\n                ++defaultCount;\n                checkPatternParam(options, param.left);\n                break;\n            default:\n                checkPatternParam(options, param);\n                params[i] = param;\n                defaults.push(null);\n                break;\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            token = strict ? options.stricted : options.firstRestricted;\n            throwUnexpectedToken(token, options.message);\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, node) {\n        var previousStrict, body;\n\n        if (hasLineTerminator) {\n            tolerateUnexpectedToken(lookahead);\n        }\n        expect('=>');\n        previousStrict = strict;\n\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwUnexpectedToken(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            tolerateUnexpectedToken(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n\n        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n    }\n\n    // [ES6] 14.4 Yield expression\n\n    function parseYieldExpression() {\n        var argument, expr, delegate;\n\n        expr = new Node();\n\n        if (!state.allowYield) {\n            tolerateUnexpectedToken(lookahead, Messages.IllegalYield);\n        }\n\n        expectKeyword('yield');\n\n        if (!hasLineTerminator) {\n            delegate = match('*');\n            if (delegate) {\n                lex();\n                argument = parseExpression();\n            } else {\n                if (!match(';') && !match('}') && lookahead.type !== Token.EOF) {\n                    argument = parseExpression();\n                }\n            }\n        }\n\n        return expr.finishYieldExpression(argument, delegate);\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, expr, right, list, startToken;\n\n        startToken = lookahead;\n        token = lookahead;\n\n        if (matchKeyword('yield')) {\n            return parseYieldExpression();\n        }\n\n        expr = parseConditionalExpression();\n\n        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n            isAssignmentTarget = isBindingElement = false;\n            list = reinterpretAsCoverFormalsList(expr);\n\n            if (list) {\n                firstCoverInitializedNameError = null;\n                return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n            }\n\n            return expr;\n        }\n\n        if (matchAssign()) {\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n            }\n\n            if (!match('=')) {\n                isAssignmentTarget = isBindingElement = false;\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            token = lex();\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n            firstCoverInitializedNameError = null;\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr, startToken = lookahead, expressions;\n\n        expr = isolateCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expressions.push(isolateCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementListItem() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                if (sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);\n                }\n                return parseExportDeclaration();\n            case 'import':\n                if (sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);\n                }\n                return parseImportDeclaration();\n            case 'const':\n            case 'let':\n                return parseLexicalDeclaration({inFor: false});\n            case 'function':\n                return parseFunctionDeclaration(new Node());\n            case 'class':\n                return parseClassDeclaration();\n            }\n        }\n\n        return parseStatement();\n    }\n\n    function parseStatementList() {\n        var list = [];\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            list.push(parseStatementListItem());\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, node = new Node();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return node.finishBlockStatement(block);\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (token.type !== Token.Identifier) {\n            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n                tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            } else {\n                throwUnexpectedToken(token);\n            }\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseVariableDeclaration() {\n        var init = null, id, node = new Node(), params = [];\n\n        id = parsePattern(params);\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (match('=')) {\n            lex();\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        } else if (id.type !== Syntax.Identifier) {\n            expect('=');\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseVariableDeclarationList() {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration());\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (startIndex < length);\n\n        return list;\n    }\n\n    function parseVariableStatement(node) {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return node.finishVariableDeclaration(declarations);\n    }\n\n    function parseLexicalBinding(kind, options) {\n        var init = null, id, node = new Node(), params = [];\n\n        id = parsePattern(params);\n\n        // 12.2.1\n        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            if (!matchKeyword('in') && !matchContextualKeyword('of')) {\n                expect('=');\n                init = isolateCoverGrammar(parseAssignmentExpression);\n            }\n        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {\n            expect('=');\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseBindingList(kind, options) {\n        var list = [];\n\n        do {\n            list.push(parseLexicalBinding(kind, options));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (startIndex < length);\n\n        return list;\n    }\n\n    function parseLexicalDeclaration(options) {\n        var kind, declarations, node = new Node();\n\n        kind = lex().value;\n        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n\n        declarations = parseBindingList(kind, options);\n\n        consumeSemicolon();\n\n        return node.finishLexicalDeclaration(declarations, kind);\n    }\n\n    function parseRestElement(params) {\n        var param, node = new Node();\n\n        lex();\n\n        if (match('{')) {\n            throwError(Messages.ObjectPatternAsRestParameter);\n        }\n\n        params.push(lookahead);\n\n        param = parseVariableIdentifier();\n\n        if (match('=')) {\n            throwError(Messages.DefaultRestParameter);\n        }\n\n        if (!match(')')) {\n            throwError(Messages.ParameterAfterRestParameter);\n        }\n\n        return node.finishRestElement(param);\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement(node) {\n        expect(';');\n        return node.finishEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement(node) {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement(node) {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return node.finishIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement(node) {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return node.finishDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement(node) {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return node.finishWhileStatement(test, body);\n    }\n\n    function parseForStatement(node) {\n        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,\n            body, oldInIteration, previousAllowIn = state.allowIn;\n\n        init = test = update = null;\n        forIn = true;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var')) {\n                init = new Node();\n                lex();\n\n                state.allowIn = false;\n                init = init.finishVariableDeclaration(parseVariableDeclarationList());\n                state.allowIn = previousAllowIn;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (init.declarations.length === 1 && init.declarations[0].init === null && matchContextualKeyword('of')) {\n                    lex();\n                    left = init;\n                    right = parseAssignmentExpression();\n                    init = null;\n                    forIn = false;\n                } else {\n                    expect(';');\n                }\n            } else if (matchKeyword('const') || matchKeyword('let')) {\n                init = new Node();\n                kind = lex().value;\n\n                state.allowIn = false;\n                declarations = parseBindingList(kind, {inFor: true});\n                state.allowIn = previousAllowIn;\n\n                if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {\n                    init = init.finishLexicalDeclaration(declarations, kind);\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n                    init = init.finishLexicalDeclaration(declarations, kind);\n                    lex();\n                    left = init;\n                    right = parseAssignmentExpression();\n                    init = null;\n                    forIn = false;\n                } else {\n                    consumeSemicolon();\n                    init = init.finishLexicalDeclaration(declarations, kind);\n                }\n            } else {\n                initStartToken = lookahead;\n                state.allowIn = false;\n                init = inheritCoverGrammar(parseAssignmentExpression);\n                state.allowIn = previousAllowIn;\n\n                if (matchKeyword('in')) {\n                    if (!isAssignmentTarget) {\n                        tolerateError(Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (matchContextualKeyword('of')) {\n                    if (!isAssignmentTarget) {\n                        tolerateError(Messages.InvalidLHSInForLoop);\n                    }\n\n                    lex();\n                    reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = parseAssignmentExpression();\n                    init = null;\n                    forIn = false;\n                } else {\n                    if (match(',')) {\n                        initSeq = [init];\n                        while (match(',')) {\n                            lex();\n                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));\n                        }\n                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);\n                    }\n                    expect(';');\n                }\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = isolateCoverGrammar(parseStatement);\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                node.finishForStatement(init, test, update, body) :\n                forIn ? node.finishForInStatement(left, right, body) :\n                    node.finishForOfStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement(node) {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(startIndex) === 0x3B) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError(Messages.IllegalContinue);\n        }\n\n        return node.finishContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement(node) {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(lastIndex) === 0x3B) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError(Messages.IllegalBreak);\n        }\n\n        return node.finishBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement(node) {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            tolerateError(Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(lastIndex) === 0x20) {\n            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return node.finishReturnStatement(argument);\n            }\n        }\n\n        if (hasLineTerminator) {\n            // HACK\n            return node.finishReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return node.finishReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement(node) {\n        var object, body;\n\n        if (strict) {\n            tolerateError(Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return node.finishWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test, consequent = [], statement, node = new Node();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (startIndex < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatementListItem();\n            consequent.push(statement);\n        }\n\n        return node.finishSwitchCase(test, consequent);\n    }\n\n    function parseSwitchStatement(node) {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return node.finishSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError(Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return node.finishSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement(node) {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (hasLineTerminator) {\n            throwError(Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return node.finishThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, params = [], paramMap = {}, key, i, body, node = new Node();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        param = parsePattern(params);\n        for (i = 0; i < params.length; i++) {\n            key = '$' + params[i].value;\n            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\n                tolerateError(Messages.DuplicateBinding, params[i].value);\n            }\n            paramMap[key] = true;\n        }\n\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            tolerateError(Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return node.finishCatchClause(param, body);\n    }\n\n    function parseTryStatement(node) {\n        var block, handler = null, finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handler = parseCatchClause();\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (!handler && !finalizer) {\n            throwError(Messages.NoCatchOrFinally);\n        }\n\n        return node.finishTryStatement(block, handler, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement(node) {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return node.finishDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key,\n            node;\n\n        if (type === Token.EOF) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        if (type === Token.Punctuator && lookahead.value === '{') {\n            return parseBlock();\n        }\n        isAssignmentTarget = isBindingElement = true;\n        node = new Node();\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement(node);\n            case '(':\n                return parseExpressionStatement(node);\n            default:\n                break;\n            }\n        } else if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement(node);\n            case 'continue':\n                return parseContinueStatement(node);\n            case 'debugger':\n                return parseDebuggerStatement(node);\n            case 'do':\n                return parseDoWhileStatement(node);\n            case 'for':\n                return parseForStatement(node);\n            case 'function':\n                return parseFunctionDeclaration(node);\n            case 'if':\n                return parseIfStatement(node);\n            case 'return':\n                return parseReturnStatement(node);\n            case 'switch':\n                return parseSwitchStatement(node);\n            case 'throw':\n                return parseThrowStatement(node);\n            case 'try':\n                return parseTryStatement(node);\n            case 'var':\n                return parseVariableStatement(node);\n            case 'while':\n                return parseWhileStatement(node);\n            case 'with':\n                return parseWithStatement(node);\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return node.finishLabeledStatement(expr, labeledBody);\n        }\n\n        consumeSemicolon();\n\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var statement, body = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,\n            node = new Node();\n\n        expect('{');\n\n        while (startIndex < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesisCount = state.parenthesizedCount;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            body.push(parseStatementListItem());\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesisCount;\n\n        return node.finishBlockStatement(body);\n    }\n\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n\n    function parseParam(options) {\n        var token, param, params = [], i, def;\n\n        token = lookahead;\n        if (token.value === '...') {\n            param = parseRestElement(params);\n            validateParam(options, param.argument, param.argument.name);\n            options.params.push(param);\n            options.defaults.push(null);\n            return false;\n        }\n\n        param = parsePatternWithDefault(params);\n        for (i = 0; i < params.length; i++) {\n            validateParam(options, params[i], params[i].value);\n        }\n\n        if (param.type === Syntax.AssignmentPattern) {\n            def = param.right;\n            param = param.left;\n            ++options.defaultCount;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options;\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = {};\n            while (startIndex < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        return {\n            params: options.params,\n            defaults: options.defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseFunctionDeclaration(node, identifierIsOptional) {\n        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,\n            isGenerator, previousAllowYield;\n\n        expectKeyword('function');\n\n        isGenerator = match('*');\n        if (isGenerator) {\n            lex();\n        }\n\n        if (!identifierIsOptional || !match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        previousAllowYield = state.allowYield;\n        state.allowYield = false;\n        tmp = parseParams(firstRestricted);\n        state.allowYield = previousAllowYield;\n\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousAllowYield = state.allowYield;\n        previousStrict = strict;\n        state.allowYield = isGenerator;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n        state.allowYield = previousAllowYield;\n\n        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp,\n            params = [], defaults = [], body, previousStrict, node = new Node(),\n            isGenerator, previousAllowYield;\n\n        expectKeyword('function');\n\n        isGenerator = match('*');\n        if (isGenerator) {\n            lex();\n        }\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        previousAllowYield = state.allowYield;\n        state.allowYield = false;\n        tmp = parseParams(firstRestricted);\n        state.allowYield = previousAllowYield;\n\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        previousAllowYield = state.allowYield;\n        state.allowYield = isGenerator;\n        body = parseFunctionSourceElements();\n\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n        state.allowYield = previousAllowYield;\n\n        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);\n    }\n\n\n    function parseClassBody() {\n        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;\n\n        classBody = new Node();\n\n        expect('{');\n        body = [];\n        while (!match('}')) {\n            if (match(';')) {\n                lex();\n            } else {\n                method = new Node();\n                token = lookahead;\n                isStatic = false;\n                computed = match('[');\n                if (match('*')) {\n                    lex();\n                } else {\n                    key = parseObjectPropertyKey();\n                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {\n                        token = lookahead;\n                        isStatic = true;\n                        computed = match('[');\n                        if (match('*')) {\n                            lex();\n                        } else {\n                            key = parseObjectPropertyKey();\n                        }\n                    }\n                }\n                method = tryParseMethodDefinition(token, key, computed, method);\n                if (method) {\n                    method['static'] = isStatic;\n                    if (method.kind === 'init') {\n                        method.kind = 'method';\n                    }\n                    if (!isStatic) {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {\n                            if (method.kind !== 'method' || !method.method || method.value.generator) {\n                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n                            }\n                            if (hasConstructor) {\n                                throwUnexpectedToken(token, Messages.DuplicateConstructor);\n                            } else {\n                                hasConstructor = true;\n                            }\n                            method.kind = 'constructor';\n                        }\n                    } else {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {\n                            throwUnexpectedToken(token, Messages.StaticPrototype);\n                        }\n                    }\n                    method.type = Syntax.MethodDefinition;\n                    delete method.method;\n                    delete method.shorthand;\n                    body.push(method);\n                } else {\n                    throwUnexpectedToken(lookahead);\n                }\n            }\n        }\n        lex();\n        return classBody.finishClassBody(body);\n    }\n\n    function parseClassDeclaration(identifierIsOptional) {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (!identifierIsOptional || lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassDeclaration(id, superClass, classBody);\n    }\n\n    function parseClassExpression() {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassExpression(id, superClass, classBody);\n    }\n\n    // Modules grammar from:\n    // people.mozilla.org/~jorendorff/es6-draft.html\n\n    function parseModuleSpecifier() {\n        var node = new Node();\n\n        if (lookahead.type !== Token.StringLiteral) {\n            throwError(Messages.InvalidModuleSpecifier);\n        }\n        return node.finishLiteral(lex());\n    }\n\n    function parseExportSpecifier() {\n        var exported, local, node = new Node(), def;\n        if (matchKeyword('default')) {\n            // export {default} from 'something';\n            def = new Node();\n            lex();\n            local = def.finishIdentifier('default');\n        } else {\n            local = parseVariableIdentifier();\n        }\n        if (matchContextualKeyword('as')) {\n            lex();\n            exported = parseNonComputedProperty();\n        }\n        return node.finishExportSpecifier(local, exported);\n    }\n\n    function parseExportNamedDeclaration(node) {\n        var declaration = null,\n            isExportFromIdentifier,\n            src = null, specifiers = [];\n\n        // non-default export\n        if (lookahead.type === Token.Keyword) {\n            // covers:\n            // export var f = 1;\n            switch (lookahead.value) {\n                case 'let':\n                case 'const':\n                case 'var':\n                case 'class':\n                case 'function':\n                    declaration = parseStatementListItem();\n                    return node.finishExportNamedDeclaration(declaration, specifiers, null);\n            }\n        }\n\n        expect('{');\n        if (!match('}')) {\n            do {\n                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n                specifiers.push(parseExportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n\n        if (matchContextualKeyword('from')) {\n            // covering:\n            // export {default} from 'foo';\n            // export {foo} from 'foo';\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n        } else if (isExportFromIdentifier) {\n            // covering:\n            // export {default}; // missing fromClause\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        } else {\n            // cover\n            // export {foo};\n            consumeSemicolon();\n        }\n        return node.finishExportNamedDeclaration(declaration, specifiers, src);\n    }\n\n    function parseExportDefaultDeclaration(node) {\n        var declaration = null,\n            expression = null;\n\n        // covers:\n        // export default ...\n        expectKeyword('default');\n\n        if (matchKeyword('function')) {\n            // covers:\n            // export default function foo () {}\n            // export default function () {}\n            declaration = parseFunctionDeclaration(new Node(), true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n        if (matchKeyword('class')) {\n            declaration = parseClassDeclaration(true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n\n        if (matchContextualKeyword('from')) {\n            throwError(Messages.UnexpectedToken, lookahead.value);\n        }\n\n        // covers:\n        // export default {};\n        // export default [];\n        // export default (1 + 2);\n        if (match('{')) {\n            expression = parseObjectInitialiser();\n        } else if (match('[')) {\n            expression = parseArrayInitialiser();\n        } else {\n            expression = parseAssignmentExpression();\n        }\n        consumeSemicolon();\n        return node.finishExportDefaultDeclaration(expression);\n    }\n\n    function parseExportAllDeclaration(node) {\n        var src;\n\n        // covers:\n        // export * from 'foo';\n        expect('*');\n        if (!matchContextualKeyword('from')) {\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return node.finishExportAllDeclaration(src);\n    }\n\n    function parseExportDeclaration() {\n        var node = new Node();\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalExportDeclaration);\n        }\n\n        expectKeyword('export');\n\n        if (matchKeyword('default')) {\n            return parseExportDefaultDeclaration(node);\n        }\n        if (match('*')) {\n            return parseExportAllDeclaration(node);\n        }\n        return parseExportNamedDeclaration(node);\n    }\n\n    function parseImportSpecifier() {\n        // import {<foo as bar>} ...;\n        var local, imported, node = new Node();\n\n        imported = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            local = parseVariableIdentifier();\n        }\n\n        return node.finishImportSpecifier(local, imported);\n    }\n\n    function parseNamedImports() {\n        var specifiers = [];\n        // {foo, bar as bas}\n        expect('{');\n        if (!match('}')) {\n            do {\n                specifiers.push(parseImportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n        return specifiers;\n    }\n\n    function parseImportDefaultSpecifier() {\n        // import <foo> ...;\n        var local, node = new Node();\n\n        local = parseNonComputedProperty();\n\n        return node.finishImportDefaultSpecifier(local);\n    }\n\n    function parseImportNamespaceSpecifier() {\n        // import <* as foo> ...;\n        var local, node = new Node();\n\n        expect('*');\n        if (!matchContextualKeyword('as')) {\n            throwError(Messages.NoAsAfterImportNamespace);\n        }\n        lex();\n        local = parseNonComputedProperty();\n\n        return node.finishImportNamespaceSpecifier(local);\n    }\n\n    function parseImportDeclaration() {\n        var specifiers, src, node = new Node();\n\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalImportDeclaration);\n        }\n\n        expectKeyword('import');\n        specifiers = [];\n\n        if (lookahead.type === Token.StringLiteral) {\n            // covers:\n            // import 'foo';\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n            return node.finishImportDeclaration(specifiers, src);\n        }\n\n        if (!matchKeyword('default') && isIdentifierName(lookahead)) {\n            // covers:\n            // import foo\n            // import foo, ...\n            specifiers.push(parseImportDefaultSpecifier());\n            if (match(',')) {\n                lex();\n            }\n        }\n        if (match('*')) {\n            // covers:\n            // import foo, * as foo\n            // import * as foo\n            specifiers.push(parseImportNamespaceSpecifier());\n        } else if (match('{')) {\n            // covers:\n            // import foo, {bar}\n            // import {bar}\n            specifiers = specifiers.concat(parseNamedImports());\n        }\n\n        if (!matchContextualKeyword('from')) {\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return node.finishImportDeclaration(specifiers, src);\n    }\n\n    // 14 Program\n\n    function parseScriptBody() {\n        var statement, body = [], token, directive, firstRestricted;\n\n        while (startIndex < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (startIndex < length) {\n            statement = parseStatementListItem();\n            /* istanbul ignore if */\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            body.push(statement);\n        }\n        return body;\n    }\n\n    function parseProgram() {\n        var body, node;\n\n        peek();\n        node = new Node();\n\n        body = parseScriptBody();\n        return node.finishProgram(body);\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            allowYield: false,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: []\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    lex();\n                } catch (lexError) {\n                    if (extra.errors) {\n                        recordError(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            allowYield: false,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: []\n        };\n        sourceType = 'script';\n        strict = false;\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n            if (options.sourceType === 'module') {\n                // very restrictive condition for now\n                sourceType = options.sourceType;\n                strict = true;\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '2.4.1';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n","pre":true},"util/formatNumber.js":{"path":"util/formatNumber.js","friendlyPath":"jsio.util.formatNumber","directory":"util/","filename":"formatNumber.js","src":"exports.integer = function(number, prefix, unitPlural, unitSingular) {\n\tprefix = prefix || '';\n\tif (unitPlural) {\n\t\tunitPlural = ' ' + unitPlural;\n\t} else {\n\t\tunitPlural = '';\n\t}\n\t\n\tif (unitSingular) {\n\t\tunitSingular = ' ' + unitSingular;\n\t} else {\n\t\tunitSingular = unitPlural;\n\t}\n\t\n\tvar arr = ('' + Math.round(number)).split('');\n\tvar n = arr.length;\n\t\n\tif (number == 1) {\n\t\treturn prefix + 1 + unitSingular;\n\t} else if (n > 3) {\n\t\tfor (var i = arr.length - 1; i > 0; --i) {\n\t\t\tif ((n - i) % 3 == 0) {\n\t\t\t\tarr.splice(i, 0, ',');\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn prefix + arr.join('') + unitPlural;\n}\n","pre":true},"util/jslint.js":{"path":"util/jslint.js","friendlyPath":"jsio.util.jslint","directory":"util/","filename":"jslint.js","src":"//\n// This file is a copy of jslint.js with *two* modifications:\n//   1. warning is printed when this module is imported\n//   2. global function JSLINT replaced with assignment to exports instead\n//\nlogger.warn('String.prototype has been modified.  Current browser session should only be used for debugging.');\n\n// jslint.js\n// 2010-11-18\n\n/*\nCopyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nThe Software shall be used for Good, not Evil.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/*\n    JSLINT is a global function. It takes two parameters.\n\n        var myResult = JSLINT(source, option);\n\n    The first parameter is either a string or an array of strings. If it is a\n    string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n    is assumed that each string represents one line. The source can be a\n    JavaScript text, or HTML text, or a JSON text, or a CSS text.\n\n    The second parameter is an optional object of options which control the\n    operation of JSLINT. Most of the options are booleans: They are all are\n    optional and have a default value of false.\n\n    If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n    If false, you can inspect JSLINT.errors to find out the problems.\n    JSLINT.errors is an array of objects containing these members:\n\n    {\n        line      : The line (relative to 0) at which the lint was found\n        character : The character (relative to 0) at which the lint was found\n        reason    : The problem\n        evidence  : The text line in which the problem occurred\n        raw       : The raw message before the details were inserted\n        a         : The first detail\n        b         : The second detail\n        c         : The third detail\n        d         : The fourth detail\n    }\n\n    If a fatal error was found, a null will be the last element of the\n    JSLINT.errors array.\n\n    You can request a Function Report, which shows all of the functions\n    and the parameters and vars that they use. This can be used to find\n    implied global variables and other problems. The report is in HTML and\n    can be inserted in an HTML <body>.\n\n        var myReport = JSLINT.report(limited);\n\n    If limited is true, then the report will be limited to only errors.\n\n    You can request a data structure which contains JSLint's results.\n\n        var myData = JSLINT.data();\n\n    It returns a structure with this form:\n\n    {\n        errors: [\n            {\n                line: NUMBER,\n                character: NUMBER,\n                reason: STRING,\n                evidence: STRING\n            }\n        ],\n        functions: [\n            name: STRING,\n            line: NUMBER,\n            last: NUMBER,\n            param: [\n                STRING\n            ],\n            closure: [\n                STRING\n            ],\n            var: [\n                STRING\n            ],\n            exception: [\n                STRING\n            ],\n            outer: [\n                STRING\n            ],\n            unused: [\n                STRING\n            ],\n            global: [\n                STRING\n            ],\n            label: [\n                STRING\n            ]\n        ],\n        globals: [\n            STRING\n        ],\n        member: {\n            STRING: NUMBER\n        },\n        unuseds: [\n            {\n                name: STRING,\n                line: NUMBER\n            }\n        ],\n        implieds: [\n            {\n                name: STRING,\n                line: NUMBER\n            }\n        ],\n        urls: [\n            STRING\n        ],\n        json: BOOLEAN\n    }\n\n    Empty arrays will not be included.\n\n*/\n\n/*jslint\n    evil: true, nomen: false, onevar: false, regexp: false, strict: true\n*/\n\n/*members \"\\b\", \"\\t\", \"\\n\", \"\\f\", \"\\r\", \"!=\", \"!==\", \"\\\"\", \"%\",\n    \"(begin)\", \"(breakage)\", \"(context)\", \"(error)\", \"(global)\",\n    \"(identifier)\", \"(last)\", \"(line)\", \"(loopage)\", \"(name)\", \"(onevar)\",\n    \"(params)\", \"(scope)\", \"(statement)\", \"(verb)\", \"*\", \"+\", \"++\", \"-\",\n    \"--\", \"\\/\", \"<\", \"<=\", \"==\", \"===\", \">\", \">=\", ADSAFE,\n    ActiveXObject, Array, Boolean, COM, CScript, Canvas, CustomAnimation,\n    Date, Debug, E, Enumerator, Error, EvalError, FadeAnimation, Flash,\n    FormField, Frame, Function, HotKey, Image, JSON, LN10, LN2, LOG10E,\n    LOG2E, MAX_VALUE, MIN_VALUE, Math, MenuItem, MoveAnimation,\n    NEGATIVE_INFINITY, Number, Object, Option, PI, POSITIVE_INFINITY, Point,\n    RangeError, Rectangle, ReferenceError, RegExp, ResizeAnimation,\n    RotateAnimation, SQRT1_2, SQRT2, ScrollBar, String, Style, SyntaxError,\n    System, Text, TextArea, Timer, TypeError, URIError, URL, VBArray,\n    WScript, Web, Window, XMLDOM, XMLHttpRequest, \"\\\\\", a, abbr, acronym,\n    activeborder, activecaption, addEventListener, address, adsafe, alert,\n    aliceblue, all, animator, antiquewhite, appleScript, applet, apply,\n    approved, appworkspace, aqua, aquamarine, area, arguments, arity,\n    article, aside, audio, autocomplete, azure, b, background,\n    \"background-attachment\", \"background-color\", \"background-image\",\n    \"background-position\", \"background-repeat\", base, bdo, beep, beige, big,\n    bisque, bitwise, black, blanchedalmond, block, blockquote, blue,\n    blueviolet, blur, body, border, \"border-bottom\", \"border-bottom-color\",\n    \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\",\n    \"border-color\", \"border-left\", \"border-left-color\", \"border-left-style\",\n    \"border-left-width\", \"border-right\", \"border-right-color\",\n    \"border-right-style\", \"border-right-width\", \"border-spacing\",\n    \"border-style\", \"border-top\", \"border-top-color\", \"border-top-style\",\n    \"border-top-width\", \"border-width\", bottom, br, braille, brown, browser,\n    burlywood, button, buttonface, buttonhighlight, buttonshadow,\n    buttontext, bytesToUIString, c, cadetblue, call, callee, caller, canvas,\n    cap, caption, \"caption-side\", captiontext, cases, center, charAt,\n    charCodeAt, character, chartreuse, chocolate, chooseColor, chooseFile,\n    chooseFolder, cite, clear, clearInterval, clearTimeout, clip, close,\n    closeWidget, closed, closure, cm, code, col, colgroup, color, command,\n    comment, condition, confirm, console, constructor, content,\n    convertPathToHFS, convertPathToPlatform, coral, cornflowerblue,\n    cornsilk, \"counter-increment\", \"counter-reset\", create, crimson, css,\n    cursor, cyan, d, darkblue, darkcyan, darkgoldenrod, darkgray, darkgreen,\n    darkkhaki, darkmagenta, darkolivegreen, darkorange, darkorchid, darkred,\n    darksalmon, darkseagreen, darkslateblue, darkslategray, darkturquoise,\n    darkviolet, data, datalist, dd, debug, decodeURI, decodeURIComponent,\n    deeppink, deepskyblue, defaultStatus, defineClass, del, deserialize,\n    details, devel, dfn, dialog, dimension, dimgray, dir, direction,\n    display, div, dl, document, dodgerblue, dt, edition, else, em, embed,\n    embossed, empty, \"empty-cells\", encodeURI, encodeURIComponent,\n    entityify, eqeqeq, errors, es5, escape, eval, event, evidence, evil, ex,\n    exception, exec, exps, fieldset, figure, filesystem, firebrick, first,\n    float, floor, floralwhite, focus, focusWidget, font, \"font-family\",\n    \"font-size\", \"font-size-adjust\", \"font-stretch\", \"font-style\",\n    \"font-variant\", \"font-weight\", footer, forestgreen, forin, form,\n    fragment, frame, frames, frameset, from, fromCharCode, fuchsia, fud,\n    funct, function, functions, g, gainsboro, gc, getComputedStyle,\n    ghostwhite, global, globals, gold, goldenrod, gray, graytext, green,\n    greenyellow, h1, h2, h3, h4, h5, h6, handheld, hasOwnProperty, head,\n    header, height, help, hgroup, highlight, highlighttext, history,\n    honeydew, hotpink, hr, \"hta:application\", html, i, iTunes, id,\n    identifier, iframe, img, immed, implieds, in, inactiveborder,\n    inactivecaption, inactivecaptiontext, include, indent, indexOf,\n    indianred, indigo, infobackground, infotext, init, input, ins, isAlpha,\n    isApplicationRunning, isDigit, isFinite, isNaN, ivory, join, jslint,\n    json, kbd, keygen, khaki, konfabulatorVersion, label, labelled, lang,\n    last, lavender, lavenderblush, lawngreen, laxbreak, lbp, led, left,\n    legend, lemonchiffon, length, \"letter-spacing\", li, lib, lightblue,\n    lightcoral, lightcyan, lightgoldenrodyellow, lightgreen, lightpink,\n    lightsalmon, lightseagreen, lightskyblue, lightslategray,\n    lightsteelblue, lightyellow, lime, limegreen, line, \"line-height\",\n    linen, link, \"list-style\", \"list-style-image\", \"list-style-position\",\n    \"list-style-type\", load, loadClass, location, log, m, magenta, map,\n    margin, \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\n    mark, \"marker-offset\", maroon, match, \"max-height\", \"max-width\", maxerr,\n    maxlen, md5, mediumaquamarine, mediumblue, mediumorchid, mediumpurple,\n    mediumseagreen, mediumslateblue, mediumspringgreen, mediumturquoise,\n    mediumvioletred, member, menu, menutext, message, meta, meter,\n    midnightblue, \"min-height\", \"min-width\", mintcream, mistyrose, mm,\n    moccasin, moveBy, moveTo, name, nav, navajowhite, navigator, navy, new,\n    newcap, noframes, nomen, noscript, nud, object, ol, oldlace, olive,\n    olivedrab, on, onbeforeunload, onblur, onerror, onevar, onfocus, onload,\n    onresize, onunload, opacity, open, openURL, opener, opera, optgroup,\n    option, orange, orangered, orchid, outer, outline, \"outline-color\",\n    \"outline-style\", \"outline-width\", output, overflow, \"overflow-x\",\n    \"overflow-y\", p, padding, \"padding-bottom\", \"padding-left\",\n    \"padding-right\", \"padding-top\", \"page-break-after\", \"page-break-before\",\n    palegoldenrod, palegreen, paleturquoise, palevioletred, papayawhip,\n    param, parent, parseFloat, parseInt, passfail, pc, peachpuff, peru,\n    pink, play, plum, plusplus, pop, popupMenu, position, powderblue, pre,\n    predef, preferenceGroups, preferences, print, progress, projection,\n    prompt, prototype, pt, purple, push, px, q, quit, quotes, random, range,\n    raw, reach, readFile, readUrl, reason, red, regexp, reloadWidget,\n    removeEventListener, replace, report, reserved, resizeBy, resizeTo,\n    resolvePath, resumeUpdates, rhino, right, rosybrown, royalblue, rp, rt,\n    ruby, runCommand, runCommandInBg, saddlebrown, safe, salmon, samp,\n    sandybrown, saveAs, savePreferences, screen, script, scroll, scrollBy,\n    scrollTo, scrollbar, seagreen, seal, search, seashell, section, select,\n    serialize, setInterval, setTimeout, shift, showWidgetPreferences,\n    sienna, silver, skyblue, slateblue, slategray, sleep, slice, small,\n    snow, sort, source, span, spawn, speak, speech, split, springgreen, src,\n    stack, status, steelblue, strict, strong, style, styleproperty, sub,\n    substr, sup, supplant, suppressUpdates, sync, system, table,\n    \"table-layout\", tan, tbody, td, teal, tellWidget, test, \"text-align\",\n    \"text-decoration\", \"text-indent\", \"text-shadow\", \"text-transform\",\n    textarea, tfoot, th, thead, thistle, threeddarkshadow, threedface,\n    threedhighlight, threedlightshadow, threedshadow, time, title,\n    toLowerCase, toString, toUpperCase, toint32, token, tomato, top, tr, tt,\n    tty, turquoise, tv, type, u, ul, undef, unescape, \"unicode-bidi\",\n    unused, unwatch, updateNow, urls, value, valueOf, var, version,\n    \"vertical-align\", video, violet, visibility, watch, wheat, white,\n    \"white-space\", whitesmoke, widget, width, window, windowframe, windows,\n    windowtext, \"word-spacing\", \"word-wrap\", yahooCheckLogin, yahooLogin,\n    yahooLogout, yellow, yellowgreen, \"z-index\"\n*/\n\n// We build the application inside a function so that we produce only a single\n// global variable. The function will be invoked, its return value is the JSLINT\n// application itself.\n\n\"use strict\";\n\nvar JSLINT = exports = (function () {\n    var adsafe_id,      // The widget's ADsafe id.\n        adsafe_may,     // The widget may load approved scripts.\n        adsafe_went,    // ADSAFE.go has been called.\n        anonname,       // The guessed name for anonymous functions.\n        approved,       // ADsafe approved urls.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<': true,\n            '<=': true,\n            '==': true,\n            '===': true,\n            '!==': true,\n            '!=': true,\n            '>': true,\n            '>=': true,\n            '+': true,\n            '-': true,\n            '*': true,\n            '/': true,\n            '%': true\n        },\n\n// These are members that should not be permitted in the safe subset.\n\n        banned = {              // the member names that ADsafe prohibits.\n            'arguments'     : true,\n            callee          : true,\n            caller          : true,\n            constructor     : true,\n            'eval'          : true,\n            prototype       : true,\n            stack           : true,\n            unwatch         : true,\n            valueOf         : true,\n            watch           : true\n        },\n\n\n// These are the JSLint boolean options.\n\n        boolOptions = {\n            adsafe     : true, // if ADsafe should be enforced\n            bitwise    : true, // if bitwise operators should not be allowed\n            browser    : true, // if the standard browser globals should be predefined\n            cap        : true, // if upper case HTML should be allowed\n            css        : true, // if CSS workarounds should be tolerated\n            debug      : true, // if debugger statements should be allowed\n            devel      : true, // if logging should be allowed (console, alert, etc.)\n            eqeqeq     : true, // if === should be required\n            es5        : true, // if ES5 syntax should be allowed\n            evil       : true, // if eval should be allowed\n            forin      : true, // if for in statements must filter\n            fragment   : true, // if HTML fragments should be allowed\n            immed      : true, // if immediate invocations must be wrapped in parens\n            laxbreak   : true, // if line breaks should not be checked\n            newcap     : true, // if constructor names must be capitalized\n            nomen      : true, // if names should be checked\n            on         : true, // if HTML event handlers should be allowed\n            onevar     : true, // if only one var statement per function should be allowed\n            passfail   : true, // if the scan should stop on first error\n            plusplus   : true, // if increment/decrement should not be allowed\n            regexp     : true, // if the . should not be allowed in regexp literals\n            rhino      : true, // if the Rhino environment globals should be predefined\n            undef      : true, // if variables should be declared before used\n            safe       : true, // if use of some browser features should be restricted\n            windows    : true, // if MS Windows-specigic globals should be predefined\n            strict     : true, // require the \"use strict\"; pragma\n            sub        : true, // if all forms of subscript notation are tolerated\n            white      : true, // if strict whitespace rules apply\n            widget     : true  // if the Yahoo Widgets globals should be predefined\n        },\n\n// browser contains a set of global names which are commonly provided by a\n// web browser environment.\n\n        browser = {\n            addEventListener: false,\n            blur            : false,\n            clearInterval   : false,\n            clearTimeout    : false,\n            close           : false,\n            closed          : false,\n            defaultStatus   : false,\n            document        : false,\n            event           : false,\n            focus           : false,\n            frames          : false,\n            getComputedStyle: false,\n            history         : false,\n            Image           : false,\n            length          : false,\n            location        : false,\n            moveBy          : false,\n            moveTo          : false,\n            name            : false,\n            navigator       : false,\n            onbeforeunload  : true,\n            onblur          : true,\n            onerror         : true,\n            onfocus         : true,\n            onload          : true,\n            onresize        : true,\n            onunload        : true,\n            open            : false,\n            opener          : false,\n            Option          : false,\n            parent          : false,\n            print           : false,\n            removeEventListener: false,\n            resizeBy        : false,\n            resizeTo        : false,\n            screen          : false,\n            scroll          : false,\n            scrollBy        : false,\n            scrollTo        : false,\n            setInterval     : false,\n            setTimeout      : false,\n            status          : false,\n            top             : false,\n            XMLHttpRequest  : false\n        },\n\n        cssAttributeData,\n        cssAny,\n\n        cssColorData = {\n            \"aliceblue\"             : true,\n            \"antiquewhite\"          : true,\n            \"aqua\"                  : true,\n            \"aquamarine\"            : true,\n            \"azure\"                 : true,\n            \"beige\"                 : true,\n            \"bisque\"                : true,\n            \"black\"                 : true,\n            \"blanchedalmond\"        : true,\n            \"blue\"                  : true,\n            \"blueviolet\"            : true,\n            \"brown\"                 : true,\n            \"burlywood\"             : true,\n            \"cadetblue\"             : true,\n            \"chartreuse\"            : true,\n            \"chocolate\"             : true,\n            \"coral\"                 : true,\n            \"cornflowerblue\"        : true,\n            \"cornsilk\"              : true,\n            \"crimson\"               : true,\n            \"cyan\"                  : true,\n            \"darkblue\"              : true,\n            \"darkcyan\"              : true,\n            \"darkgoldenrod\"         : true,\n            \"darkgray\"              : true,\n            \"darkgreen\"             : true,\n            \"darkkhaki\"             : true,\n            \"darkmagenta\"           : true,\n            \"darkolivegreen\"        : true,\n            \"darkorange\"            : true,\n            \"darkorchid\"            : true,\n            \"darkred\"               : true,\n            \"darksalmon\"            : true,\n            \"darkseagreen\"          : true,\n            \"darkslateblue\"         : true,\n            \"darkslategray\"         : true,\n            \"darkturquoise\"         : true,\n            \"darkviolet\"            : true,\n            \"deeppink\"              : true,\n            \"deepskyblue\"           : true,\n            \"dimgray\"               : true,\n            \"dodgerblue\"            : true,\n            \"firebrick\"             : true,\n            \"floralwhite\"           : true,\n            \"forestgreen\"           : true,\n            \"fuchsia\"               : true,\n            \"gainsboro\"             : true,\n            \"ghostwhite\"            : true,\n            \"gold\"                  : true,\n            \"goldenrod\"             : true,\n            \"gray\"                  : true,\n            \"green\"                 : true,\n            \"greenyellow\"           : true,\n            \"honeydew\"              : true,\n            \"hotpink\"               : true,\n            \"indianred\"             : true,\n            \"indigo\"                : true,\n            \"ivory\"                 : true,\n            \"khaki\"                 : true,\n            \"lavender\"              : true,\n            \"lavenderblush\"         : true,\n            \"lawngreen\"             : true,\n            \"lemonchiffon\"          : true,\n            \"lightblue\"             : true,\n            \"lightcoral\"            : true,\n            \"lightcyan\"             : true,\n            \"lightgoldenrodyellow\"  : true,\n            \"lightgreen\"            : true,\n            \"lightpink\"             : true,\n            \"lightsalmon\"           : true,\n            \"lightseagreen\"         : true,\n            \"lightskyblue\"          : true,\n            \"lightslategray\"        : true,\n            \"lightsteelblue\"        : true,\n            \"lightyellow\"           : true,\n            \"lime\"                  : true,\n            \"limegreen\"             : true,\n            \"linen\"                 : true,\n            \"magenta\"               : true,\n            \"maroon\"                : true,\n            \"mediumaquamarine\"      : true,\n            \"mediumblue\"            : true,\n            \"mediumorchid\"          : true,\n            \"mediumpurple\"          : true,\n            \"mediumseagreen\"        : true,\n            \"mediumslateblue\"       : true,\n            \"mediumspringgreen\"     : true,\n            \"mediumturquoise\"       : true,\n            \"mediumvioletred\"       : true,\n            \"midnightblue\"          : true,\n            \"mintcream\"             : true,\n            \"mistyrose\"             : true,\n            \"moccasin\"              : true,\n            \"navajowhite\"           : true,\n            \"navy\"                  : true,\n            \"oldlace\"               : true,\n            \"olive\"                 : true,\n            \"olivedrab\"             : true,\n            \"orange\"                : true,\n            \"orangered\"             : true,\n            \"orchid\"                : true,\n            \"palegoldenrod\"         : true,\n            \"palegreen\"             : true,\n            \"paleturquoise\"         : true,\n            \"palevioletred\"         : true,\n            \"papayawhip\"            : true,\n            \"peachpuff\"             : true,\n            \"peru\"                  : true,\n            \"pink\"                  : true,\n            \"plum\"                  : true,\n            \"powderblue\"            : true,\n            \"purple\"                : true,\n            \"red\"                   : true,\n            \"rosybrown\"             : true,\n            \"royalblue\"             : true,\n            \"saddlebrown\"           : true,\n            \"salmon\"                : true,\n            \"sandybrown\"            : true,\n            \"seagreen\"              : true,\n            \"seashell\"              : true,\n            \"sienna\"                : true,\n            \"silver\"                : true,\n            \"skyblue\"               : true,\n            \"slateblue\"             : true,\n            \"slategray\"             : true,\n            \"snow\"                  : true,\n            \"springgreen\"           : true,\n            \"steelblue\"             : true,\n            \"tan\"                   : true,\n            \"teal\"                  : true,\n            \"thistle\"               : true,\n            \"tomato\"                : true,\n            \"turquoise\"             : true,\n            \"violet\"                : true,\n            \"wheat\"                 : true,\n            \"white\"                 : true,\n            \"whitesmoke\"            : true,\n            \"yellow\"                : true,\n            \"yellowgreen\"           : true,\n\n            \"activeborder\"          : true,\n            \"activecaption\"         : true,\n            \"appworkspace\"          : true,\n            \"background\"            : true,\n            \"buttonface\"            : true,\n            \"buttonhighlight\"       : true,\n            \"buttonshadow\"          : true,\n            \"buttontext\"            : true,\n            \"captiontext\"           : true,\n            \"graytext\"              : true,\n            \"highlight\"             : true,\n            \"highlighttext\"         : true,\n            \"inactiveborder\"        : true,\n            \"inactivecaption\"       : true,\n            \"inactivecaptiontext\"   : true,\n            \"infobackground\"        : true,\n            \"infotext\"              : true,\n            \"menu\"                  : true,\n            \"menutext\"              : true,\n            \"scrollbar\"             : true,\n            \"threeddarkshadow\"      : true,\n            \"threedface\"            : true,\n            \"threedhighlight\"       : true,\n            \"threedlightshadow\"     : true,\n            \"threedshadow\"          : true,\n            \"window\"                : true,\n            \"windowframe\"           : true,\n            \"windowtext\"            : true\n        },\n\n        cssBorderStyle,\n        cssBreak,\n\n        cssLengthData = {\n            '%': true,\n            'cm': true,\n            'em': true,\n            'ex': true,\n            'in': true,\n            'mm': true,\n            'pc': true,\n            'pt': true,\n            'px': true\n        },\n\n        cssMedia,\n        cssOverflow,\n\n        devel = {\n            alert           : false,\n            confirm         : false,\n            console         : false,\n            Debug           : false,\n            opera           : false,\n            prompt          : false\n        },\n\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functionicity = [\n            'closure', 'exception', 'global', 'label',\n            'outer', 'unused', 'var'\n        ],\n\n        functions,      // All of the functions\n\n        global,         // The global scope\n        htmltag = {\n            a:        {},\n            abbr:     {},\n            acronym:  {},\n            address:  {},\n            applet:   {},\n            area:     {empty: true, parent: ' map '},\n            article:  {},\n            aside:    {},\n            audio:    {},\n            b:        {},\n            base:     {empty: true, parent: ' head '},\n            bdo:      {},\n            big:      {},\n            blockquote: {},\n            body:     {parent: ' html noframes '},\n            br:       {empty: true},\n            button:   {},\n            canvas:   {parent: ' body p div th td '},\n            caption:  {parent: ' table '},\n            center:   {},\n            cite:     {},\n            code:     {},\n            col:      {empty: true, parent: ' table colgroup '},\n            colgroup: {parent: ' table '},\n            command:  {parent: ' menu '},\n            datalist: {},\n            dd:       {parent: ' dl '},\n            del:      {},\n            details:  {},\n            dialog:   {},\n            dfn:      {},\n            dir:      {},\n            div:      {},\n            dl:       {},\n            dt:       {parent: ' dl '},\n            em:       {},\n            embed:    {},\n            fieldset: {},\n            figure:   {},\n            font:     {},\n            footer:   {},\n            form:     {},\n            frame:    {empty: true, parent: ' frameset '},\n            frameset: {parent: ' html frameset '},\n            h1:       {},\n            h2:       {},\n            h3:       {},\n            h4:       {},\n            h5:       {},\n            h6:       {},\n            head:     {parent: ' html '},\n            header:   {},\n            hgroup:   {},\n            hr:       {empty: true},\n            'hta:application':\n                      {empty: true, parent: ' head '},\n            html:     {parent: '*'},\n            i:        {},\n            iframe:   {},\n            img:      {empty: true},\n            input:    {empty: true},\n            ins:      {},\n            kbd:      {},\n            keygen:   {},\n            label:    {},\n            legend:   {parent: ' details fieldset figure '},\n            li:       {parent: ' dir menu ol ul '},\n            link:     {empty: true, parent: ' head '},\n            map:      {},\n            mark:     {},\n            menu:     {},\n            meta:     {empty: true, parent: ' head noframes noscript '},\n            meter:    {},\n            nav:      {},\n            noframes: {parent: ' html body '},\n            noscript: {parent: ' body head noframes '},\n            object:   {},\n            ol:       {},\n            optgroup: {parent: ' select '},\n            option:   {parent: ' optgroup select '},\n            output:   {},\n            p:        {},\n            param:    {empty: true, parent: ' applet object '},\n            pre:      {},\n            progress: {},\n            q:        {},\n            rp:       {},\n            rt:       {},\n            ruby:     {},\n            samp:     {},\n            script:   {empty: true, parent: ' body div frame head iframe p pre span '},\n            section:  {},\n            select:   {},\n            small:    {},\n            span:     {},\n            source:   {},\n            strong:   {},\n            style:    {parent: ' head ', empty: true},\n            sub:      {},\n            sup:      {},\n            table:    {},\n            tbody:    {parent: ' table '},\n            td:       {parent: ' tr '},\n            textarea: {},\n            tfoot:    {parent: ' table '},\n            th:       {parent: ' tr '},\n            thead:    {parent: ' table '},\n            time:     {},\n            title:    {parent: ' head '},\n            tr:       {parent: ' table tbody thead tfoot '},\n            tt:       {},\n            u:        {},\n            ul:       {},\n            'var':    {},\n            video:    {}\n        },\n\n        ids,            // HTML ids\n        implied,        // Implied globals\n        inblock,\n        indent,\n        jsonmode,\n        lines,\n        lookahead,\n        member,\n        membersOnly,\n        nexttoken,\n        noreach,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prevtoken,\n\n        rhino = {\n            defineClass : false,\n            deserialize : false,\n            gc          : false,\n            help        : false,\n            load        : false,\n            loadClass   : false,\n            print       : false,\n            quit        : false,\n            readFile    : false,\n            readUrl     : false,\n            runCommand  : false,\n            seal        : false,\n            serialize   : false,\n            spawn       : false,\n            sync        : false,\n            toint32     : false,\n            version     : false\n        },\n\n        scope,      // The current scope\n        src,\n        stack,\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = {\n            Array               : false,\n            Boolean             : false,\n            Date                : false,\n            decodeURI           : false,\n            decodeURIComponent  : false,\n            encodeURI           : false,\n            encodeURIComponent  : false,\n            Error               : false,\n            'eval'              : false,\n            EvalError           : false,\n            Function            : false,\n            hasOwnProperty      : false,\n            isFinite            : false,\n            isNaN               : false,\n            JSON                : false,\n            Math                : false,\n            Number              : false,\n            Object              : false,\n            parseInt            : false,\n            parseFloat          : false,\n            RangeError          : false,\n            ReferenceError      : false,\n            RegExp              : false,\n            String              : false,\n            SyntaxError         : false,\n            TypeError           : false,\n            URIError            : false\n        },\n\n        standard_member = {\n            E                   : true,\n            LN2                 : true,\n            LN10                : true,\n            LOG2E               : true,\n            LOG10E              : true,\n            MAX_VALUE           : true,\n            MIN_VALUE           : true,\n            NEGATIVE_INFINITY   : true,\n            PI                  : true,\n            POSITIVE_INFINITY   : true,\n            SQRT1_2             : true,\n            SQRT2               : true\n        },\n\n        strict_mode,\n        syntax = {},\n        tab,\n        token,\n        urls,\n        warnings,\n\n// widget contains the global names which are provided to a Yahoo\n// (fna Konfabulator) widget.\n\n        widget = {\n            alert                   : true,\n            animator                : true,\n            appleScript             : true,\n            beep                    : true,\n            bytesToUIString         : true,\n            Canvas                  : true,\n            chooseColor             : true,\n            chooseFile              : true,\n            chooseFolder            : true,\n            closeWidget             : true,\n            COM                     : true,\n            convertPathToHFS        : true,\n            convertPathToPlatform   : true,\n            CustomAnimation         : true,\n            escape                  : true,\n            FadeAnimation           : true,\n            filesystem              : true,\n            Flash                   : true,\n            focusWidget             : true,\n            form                    : true,\n            FormField               : true,\n            Frame                   : true,\n            HotKey                  : true,\n            Image                   : true,\n            include                 : true,\n            isApplicationRunning    : true,\n            iTunes                  : true,\n            konfabulatorVersion     : true,\n            log                     : true,\n            md5                     : true,\n            MenuItem                : true,\n            MoveAnimation           : true,\n            openURL                 : true,\n            play                    : true,\n            Point                   : true,\n            popupMenu               : true,\n            preferenceGroups        : true,\n            preferences             : true,\n            print                   : true,\n            prompt                  : true,\n            random                  : true,\n            Rectangle               : true,\n            reloadWidget            : true,\n            ResizeAnimation         : true,\n            resolvePath             : true,\n            resumeUpdates           : true,\n            RotateAnimation         : true,\n            runCommand              : true,\n            runCommandInBg          : true,\n            saveAs                  : true,\n            savePreferences         : true,\n            screen                  : true,\n            ScrollBar               : true,\n            showWidgetPreferences   : true,\n            sleep                   : true,\n            speak                   : true,\n            Style                   : true,\n            suppressUpdates         : true,\n            system                  : true,\n            tellWidget              : true,\n            Text                    : true,\n            TextArea                : true,\n            Timer                   : true,\n            unescape                : true,\n            updateNow               : true,\n            URL                     : true,\n            Web                     : true,\n            widget                  : true,\n            Window                  : true,\n            XMLDOM                  : true,\n            XMLHttpRequest          : true,\n            yahooCheckLogin         : true,\n            yahooLogin              : true,\n            yahooLogout             : true\n        },\n\n        windows = {\n            ActiveXObject: false,\n            CScript      : false,\n            Debug        : false,\n            Enumerator   : false,\n            System       : false,\n            VBArray      : false,\n            WScript      : false\n        },\n\n//  xmode is used to adapt to the exceptions in html parsing.\n//  It can have these states:\n//      false   .js script file\n//      html\n//      outer\n//      script\n//      style\n//      scriptstring\n//      styleproperty\n\n        xmode,\n        xquote,\n\n// Regular expressions. Some of these are ridiculously long.\n\n// unsafe comment or string\n        ax = /@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// token\n        tx = /^\\s*([(){}\\[.,:;'\"~\\?\\]#@]|==?=?|\\/(\\*(jslint|members?|global)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|%=?|&[&=]?|\\|[|=]?|>>?>?=?|<([\\/=!]|\\!(\\[|--)?|<=?)?|\\^=?|\\!=?=?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+([xX][0-9a-fA-F]+|\\.[0-9]*)?([eE][+\\-]?[0-9]+)?)/,\n// html token\n        hx = /^\\s*(['\"=>\\/&#]|<(?:\\/|\\!(?:--)?)?|[a-zA-Z][a-zA-Z0-9_\\-:]*|[0-9]+|--)/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n        nxg = /[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// outer html token\n        ox = /[>&]|<[\\/!]?|--/,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\\s*:/i,\n// url badness\n        ux = /&|\\+|\\u00AD|\\.\\.|\\/\\*|%[^;]|base64|url|expression|data|mailto/i,\n// style\n        sx = /^\\s*([{:#%.=,>+\\[\\]@()\"';]|\\*=?|\\$=|\\|=|\\^=|~=|[a-zA-Z_][a-zA-Z0-9_\\-]*|[0-9]+|<\\/|\\/\\*)/,\n        ssx = /^\\s*([@#!\"'};:\\-%.=,+\\[\\]()*_]|[a-zA-Z][a-zA-Z0-9._\\-]*|\\/\\*?|\\d+(?:\\.\\d+)?|<\\/)/,\n// attributes characters\n        qx = /[^a-zA-Z0-9+\\-_\\/ ]/,\n// query characters for ids\n        dx = /[\\[\\]\\/\\\\\"'*<>.&:(){}+=#]/,\n\n        rx = {\n            outer: hx,\n            html: hx,\n            style: sx,\n            styleproperty: ssx\n        };\n\n    function F() {}\n\n    if (typeof Object.create !== 'function') {\n        Object.create = function (o) {\n            F.prototype = o;\n            return new F();\n        };\n    }\n\n\n    function is_own(object, name) {\n        return Object.prototype.hasOwnProperty.call(object, name);\n    }\n\n\n    function combine(t, o) {\n        var n;\n        for (n in o) {\n            if (is_own(o, n)) {\n                t[n] = o[n];\n            }\n        }\n    }\n\n    String.prototype.entityify = function () {\n        return this\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n    };\n\n    String.prototype.isAlpha = function () {\n        return (this >= 'a' && this <= 'z\\uffff') ||\n            (this >= 'A' && this <= 'Z\\uffff');\n    };\n\n\n    String.prototype.isDigit = function () {\n        return (this >= '0' && this <= '9');\n    };\n\n\n    String.prototype.supplant = function (o) {\n        return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n            var r = o[b];\n            return typeof r === 'string' || typeof r === 'number' ? r : a;\n        });\n    };\n\n    String.prototype.name = function () {\n\n// If the string looks like an identifier, then we can return it as is.\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can simply slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe\n// sequences.\n\n        if (ix.test(this)) {\n            return this;\n        }\n        if (nx.test(this)) {\n            return '\"' + this.replace(nxg, function (a) {\n                var c = escapes[a];\n                if (c) {\n                    return c;\n                }\n                return '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n            }) + '\"';\n        }\n        return '\"' + this + '\"';\n    };\n\n\n    function assume() {\n        if (!option.safe) {\n            if (option.rhino) {\n                combine(predefined, rhino);\n            }\n            if (option.devel) {\n                combine(predefined, devel);\n            }\n            if (option.browser) {\n                combine(predefined, browser);\n            }\n            if (option.windows) {\n                combine(predefined, windows);\n            }\n            if (option.widget) {\n                combine(predefined, widget);\n            }\n        }\n    }\n\n\n// Produce an error warning.\n\n    function quit(m, l, ch) {\n        throw {\n            name: 'JSLintError',\n            line: l,\n            character: ch,\n            message: m + \" (\" + Math.floor((l / lines.length) * 100) +\n                    \"% scanned).\"\n        };\n    }\n\n    function warning(m, t, a, b, c, d) {\n        var ch, l, w;\n        t = t || nexttoken;\n        if (t.id === '(end)') {  // `~\n            t = token;\n        }\n        l = t.line || 0;\n        ch = t.from || 0;\n        w = {\n            id: '(error)',\n            raw: m,\n            evidence: lines[l - 1] || '',\n            line: l,\n            character: ch,\n            a: a,\n            b: b,\n            c: c,\n            d: d\n        };\n        w.reason = m.supplant(w);\n        JSLINT.errors.push(w);\n        if (option.passfail) {\n            quit('Stopping. ', l, ch);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit(\"Too many errors.\", l, ch);\n        }\n        return w;\n    }\n\n    function warningAt(m, l, ch, a, b, c, d) {\n        return warning(m, {\n            line: l,\n            from: ch\n        }, a, b, c, d);\n    }\n\n    function error(m, t, a, b, c, d) {\n        var w = warning(m, t, a, b, c, d);\n        quit(\"Stopping, unable to continue.\", w.line, w.character);\n    }\n\n    function errorAt(m, l, ch, a, b, c, d) {\n        return error(m, {\n            line: l,\n            from: ch\n        }, a, b, c, d);\n    }\n\n\n\n// lexical analysis\n\n    var lex = (function lex() {\n        var character, from, line, s;\n\n// Private lex methods\n\n        function nextLine() {\n            var at;\n            if (line >= lines.length) {\n                return false;\n            }\n            character = 1;\n            s = lines[line];\n            line += 1;\n            at = s.search(/ \\t/);\n            if (at >= 0) {\n                warningAt(\"Mixed spaces and tabs.\", line, at + 1);\n            }\n            s = s.replace(/\\t/g, tab);\n            at = s.search(cx);\n            if (at >= 0) {\n                warningAt(\"Unsafe character.\", line, at);\n            }\n            if (option.maxlen && option.maxlen < s.length) {\n                warningAt(\"Line too long.\", line, s.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var i, t;\n            if (type === '(color)' || type === '(range)') {\n                t = {type: type};\n            } else if (type === '(punctuator)' ||\n                    (type === '(identifier)' && is_own(syntax, value))) {\n                t = syntax[value] || syntax['(error)'];\n            } else {\n                t = syntax[type];\n            }\n            t = Object.create(t);\n            if (type === '(string)' || type === '(range)') {\n                if (jx.test(value)) {\n                    warningAt(\"Script URL.\", line, from);\n                }\n            }\n            if (type === '(identifier)') {\n                t.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    errorAt(\"Reserved name '{a}'.\",\n                        line, from, value);\n                } else if (option.nomen &&\n                        (value.charAt(0) === '_' ||\n                         value.charAt(value.length - 1) === '_')) {\n                    warningAt(\"Unexpected {a} in '{b}'.\", line, from,\n                        \"dangling '_'\", value);\n                }\n            }\n            t.value = value;\n            t.line = line;\n            t.character = character;\n            t.from = from;\n            i = t.id;\n            if (i !== '(endline)') {\n                prereg = i &&\n                    (('(,=:[!&|?{};'.indexOf(i.charAt(i.length - 1)) >= 0) ||\n                    i === 'return');\n            }\n            return t;\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source\n                        .replace(/\\r\\n/g, '\\n')\n                        .replace(/\\r/g, '\\n')\n                        .split('\\n');\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                nextLine();\n                from = 1;\n            },\n\n            range: function (begin, end) {\n                var c, value = '';\n                from = character;\n                if (s.charAt(0) !== begin) {\n                    errorAt(\"Expected '{a}' and instead saw '{b}'.\",\n                            line, character, begin, s.charAt(0));\n                }\n                for (;;) {\n                    s = s.slice(1);\n                    character += 1;\n                    c = s.charAt(0);\n                    switch (c) {\n                    case '':\n                        errorAt(\"Missing '{a}'.\", line, character, c);\n                        break;\n                    case end:\n                        s = s.slice(1);\n                        character += 1;\n                        return it('(range)', value);\n                    case xquote:\n                    case '\\\\':\n                        warningAt(\"Unexpected '{a}'.\", line, character, c);\n                    }\n                    value += c;\n                }\n\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var b, c, captures, d, depth, high, i, l, low, q, t;\n\n                function match(x) {\n                    var r = x.exec(s), r1;\n                    if (r) {\n                        l = r[0].length;\n                        r1 = r[1];\n                        c = r1.charAt(0);\n                        s = s.substr(l);\n                        from = character + l - r1.length;\n                        character += l;\n                        return r1;\n                    }\n                }\n\n                function string(x) {\n                    var c, j, r = '';\n\n                    if (jsonmode && x !== '\"') {\n                        warningAt(\"Strings must use doublequote.\",\n                                line, character);\n                    }\n\n                    if (xquote === x || (xmode === 'scriptstring' && !xquote)) {\n                        return it('(punctuator)', x);\n                    }\n\n                    function esc(n) {\n                        var i = parseInt(s.substr(j + 1, n), 16);\n                        j += n;\n                        if (i >= 32 && i <= 126 &&\n                                i !== 34 && i !== 92 && i !== 39) {\n                            warningAt(\"Unnecessary escapement.\", line, character);\n                        }\n                        character += n;\n                        c = String.fromCharCode(i);\n                    }\n                    j = 0;\n                    for (;;) {\n                        while (j >= s.length) {\n                            j = 0;\n                            if (xmode !== 'html' || !nextLine()) {\n                                errorAt(\"Unclosed string.\", line, from);\n                            }\n                        }\n                        c = s.charAt(j);\n                        if (c === x) {\n                            character += 1;\n                            s = s.substr(j + 1);\n                            return it('(string)', r, x);\n                        }\n                        if (c < ' ') {\n                            if (c === '\\n' || c === '\\r') {\n                                break;\n                            }\n                            warningAt(\"Control character in string: {a}.\",\n                                    line, character + j, s.slice(0, j));\n                        } else if (c === xquote) {\n                            warningAt(\"Bad HTML string\", line, character + j);\n                        } else if (c === '<') {\n                            if (option.safe && xmode === 'html') {\n                                warningAt(\"ADsafe string violation.\",\n                                        line, character + j);\n                            } else if (s.charAt(j + 1) === '/' && (xmode || option.safe)) {\n                                warningAt(\"Expected '<\\\\/' and instead saw '</'.\", line, character);\n                            } else if (s.charAt(j + 1) === '!' && (xmode || option.safe)) {\n                                warningAt(\"Unexpected '<!' in a string.\", line, character);\n                            }\n                        } else if (c === '\\\\') {\n                            if (xmode === 'html') {\n                                if (option.safe) {\n                                    warningAt(\"ADsafe string violation.\",\n                                            line, character + j);\n                                }\n                            } else if (xmode === 'styleproperty') {\n                                j += 1;\n                                character += 1;\n                                c = s.charAt(j);\n                                if (c !== x) {\n                                    warningAt(\"Escapement in style string.\",\n                                            line, character + j);\n                                }\n                            } else {\n                                j += 1;\n                                character += 1;\n                                c = s.charAt(j);\n                                switch (c) {\n                                case xquote:\n                                    warningAt(\"Bad HTML string\", line,\n                                        character + j);\n                                    break;\n                                case '\\\\':\n                                case '\\'':\n                                case '\"':\n                                case '/':\n                                    break;\n                                case 'b':\n                                    c = '\\b';\n                                    break;\n                                case 'f':\n                                    c = '\\f';\n                                    break;\n                                case 'n':\n                                    c = '\\n';\n                                    break;\n                                case 'r':\n                                    c = '\\r';\n                                    break;\n                                case 't':\n                                    c = '\\t';\n                                    break;\n                                case 'u':\n                                    esc(4);\n                                    break;\n                                case 'v':\n                                    c = '\\v';\n                                    break;\n                                case 'x':\n                                    if (jsonmode) {\n                                        warningAt(\"Avoid \\\\x-.\", line, character);\n                                    }\n                                    esc(2);\n                                    break;\n                                default:\n                                    warningAt(\"Bad escapement.\", line, character);\n                                }\n                            }\n                        }\n                        r += c;\n                        character += 1;\n                        j += 1;\n                    }\n                }\n\n                for (;;) {\n                    if (!s) {\n                        return it(nextLine() ? '(endline)' : '(end)', '');\n                    }\n                    while (xmode === 'outer') {\n                        i = s.search(ox);\n                        if (i === 0) {\n                            break;\n                        } else if (i > 0) {\n                            character += 1;\n                            s = s.slice(i);\n                            break;\n                        } else {\n                            if (!nextLine()) {\n                                return it('(end)', '');\n                            }\n                        }\n                    }\n//                     t = match(rx[xmode] || tx);\n//                     if (!t) {\n//                         if (xmode === 'html') {\n//                             return it('(error)', s.charAt(0));\n//                         } else {\n//                             t = '';\n//                             c = '';\n//                             while (s && s < '!') {\n//                                 s = s.substr(1);\n//                             }\n//                             if (s) {\n//                                 errorAt(\"Unexpected '{a}'.\",\n//                                         line, character, s.substr(0, 1));\n//                             }\n//                         }\n                    t = match(rx[xmode] || tx);\n                    if (!t) {\n                        t = '';\n                        c = '';\n                        while (s && s < '!') {\n                            s = s.substr(1);\n                        }\n                        if (s) {\n                            if (xmode === 'html') {\n                                return it('(error)', s.charAt(0));\n                            } else {\n                                errorAt(\"Unexpected '{a}'.\",\n                                        line, character, s.substr(0, 1));\n                            }\n                        }\n                    } else {\n\n    //      identifier\n\n                        if (c.isAlpha() || c === '_' || c === '$') {\n                            return it('(identifier)', t);\n                        }\n\n    //      number\n\n                        if (c.isDigit()) {\n                            if (xmode !== 'style' && !isFinite(Number(t))) {\n                                warningAt(\"Bad number '{a}'.\",\n                                    line, character, t);\n                            }\n                            if (xmode !== 'style' &&\n                                     xmode !== 'styleproperty' &&\n                                     s.substr(0, 1).isAlpha()) {\n                                warningAt(\"Missing space after '{a}'.\",\n                                        line, character, t);\n                            }\n                            if (c === '0') {\n                                d = t.substr(1, 1);\n                                if (d.isDigit()) {\n                                    if (token.id !== '.' && xmode !== 'styleproperty') {\n                                        warningAt(\"Don't use extra leading zeros '{a}'.\",\n                                            line, character, t);\n                                    }\n                                } else if (jsonmode && (d === 'x' || d === 'X')) {\n                                    warningAt(\"Avoid 0x-. '{a}'.\",\n                                            line, character, t);\n                                }\n                            }\n                            if (t.substr(t.length - 1) === '.') {\n                                warningAt(\n        \"A trailing decimal point can be confused with a dot '{a}'.\",\n                                        line, character, t);\n                            }\n                            return it('(number)', t);\n                        }\n                        switch (t) {\n\n    //      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(t);\n\n    //      // comment\n\n                        case '//':\n                            if (src || (xmode && xmode !== 'script')) {\n                                warningAt(\"Unexpected comment.\", line, character);\n                            } else if (xmode === 'script' && /<\\s*\\//i.test(s)) {\n                                warningAt(\"Unexpected <\\/ in comment.\", line, character);\n                            } else if ((option.safe || xmode === 'script') && ax.test(s)) {\n                                warningAt(\"Dangerous comment.\", line, character);\n                            }\n                            s = '';\n                            token.comment = true;\n                            break;\n\n    //      /* comment\n\n                        case '/*':\n                            if (src || (xmode && xmode !== 'script' && xmode !== 'style' && xmode !== 'styleproperty')) {\n                                warningAt(\"Unexpected comment.\", line, character);\n                            }\n                            if (option.safe && ax.test(s)) {\n                                warningAt(\"ADsafe comment violation.\", line, character);\n                            }\n                            for (;;) {\n                                i = s.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                if (!nextLine()) {\n                                    errorAt(\"Unclosed comment.\", line, character);\n                                } else {\n                                    if (option.safe && ax.test(s)) {\n                                        warningAt(\"ADsafe comment violation.\",\n                                                line, character);\n                                    }\n                                }\n                            }\n                            character += i + 2;\n                            if (s.substr(i, 1) === '/') {\n                                errorAt(\"Nested comment.\", line, character);\n                            }\n                            s = s.substr(i + 2);\n                            token.comment = true;\n                            break;\n\n    //      /*members /*jslint /*global\n\n                        case '/*members':\n                        case '/*member':\n                        case '/*jslint':\n                        case '/*global':\n                        case '*/':\n                            return {\n                                value: t,\n                                type: 'special',\n                                line: line,\n                                character: character,\n                                from: from\n                            };\n\n                        case '':\n                            break;\n    //      /\n                        case '/':\n                            if (token.id === '/=') {\n                                errorAt(\n\"A regular expression literal can be confused with '/='.\", line, from);\n                            }\n                            if (prereg) {\n                                depth = 0;\n                                captures = 0;\n                                l = 0;\n                                for (;;) {\n                                    b = true;\n                                    c = s.charAt(l);\n                                    l += 1;\n                                    switch (c) {\n                                    case '':\n                                        errorAt(\"Unclosed regular expression.\",\n                                                line, from);\n                                        return;\n                                    case '/':\n                                        if (depth > 0) {\n                                            warningAt(\"Unescaped '{a}'.\",\n                                                    line, from + l, '/');\n                                        }\n                                        c = s.substr(0, l - 1);\n                                        q = {\n                                            g: true,\n                                            i: true,\n                                            m: true\n                                        };\n                                        while (q[s.charAt(l)] === true) {\n                                            q[s.charAt(l)] = false;\n                                            l += 1;\n                                        }\n                                        character += l;\n                                        s = s.substr(l);\n                                        q = s.charAt(0);\n                                        if (q === '/' || q === '*') {\n                                            errorAt(\"Confusing regular expression.\",\n                                                    line, from);\n                                        }\n                                        return it('(regexp)', c);\n                                    case '\\\\':\n                                        c = s.charAt(l);\n                                        if (c < ' ') {\n                                            warningAt(\n\"Unexpected control character in regular expression.\", line, from + l);\n                                        } else if (c === '<') {\n                                            warningAt(\n\"Unexpected escaped character '{a}' in regular expression.\", line, from + l, c);\n                                        }\n                                        l += 1;\n                                        break;\n                                    case '(':\n                                        depth += 1;\n                                        b = false;\n                                        if (s.charAt(l) === '?') {\n                                            l += 1;\n                                            switch (s.charAt(l)) {\n                                            case ':':\n                                            case '=':\n                                            case '!':\n                                                l += 1;\n                                                break;\n                                            default:\n                                                warningAt(\n\"Expected '{a}' and instead saw '{b}'.\", line, from + l, ':', s.charAt(l));\n                                            }\n                                        } else {\n                                            captures += 1;\n                                        }\n                                        break;\n                                    case '|':\n                                        b = false;\n                                        break;\n                                    case ')':\n                                        if (depth === 0) {\n                                            warningAt(\"Unescaped '{a}'.\",\n                                                    line, from + l, ')');\n                                        } else {\n                                            depth -= 1;\n                                        }\n                                        break;\n                                    case ' ':\n                                        q = 1;\n                                        while (s.charAt(l) === ' ') {\n                                            l += 1;\n                                            q += 1;\n                                        }\n                                        if (q > 1) {\n                                            warningAt(\n\"Spaces are hard to count. Use {{a}}.\", line, from + l, q);\n                                        }\n                                        break;\n                                    case '[':\n                                        c = s.charAt(l);\n                                        if (c === '^') {\n                                            l += 1;\n                                            if (option.regexp) {\n                                                warningAt(\"Insecure '{a}'.\",\n                                                        line, from + l, c);\n                                            } else if (s.charAt(l) === ']') {\n                                                errorAt(\"Unescaped '{a}'.\",\n                                                    line, from + l, '^');\n                                            }\n                                        }\n                                        q = false;\n                                        if (c === ']') {\n                                            warningAt(\"Empty class.\", line,\n                                                    from + l - 1);\n                                            q = true;\n                                        }\nklass:                                  do {\n                                            c = s.charAt(l);\n                                            l += 1;\n                                            switch (c) {\n                                            case '[':\n                                            case '^':\n                                                warningAt(\"Unescaped '{a}'.\",\n                                                        line, from + l, c);\n                                                q = true;\n                                                break;\n                                            case '-':\n                                                if (q) {\n                                                    q = false;\n                                                } else {\n                                                    warningAt(\"Unescaped '{a}'.\",\n                                                            line, from + l, '-');\n                                                    q = true;\n                                                }\n                                                break;\n                                            case ']':\n                                                if (!q) {\n                                                    warningAt(\"Unescaped '{a}'.\",\n                                                            line, from + l - 1, '-');\n                                                }\n                                                break klass;\n                                            case '\\\\':\n                                                c = s.charAt(l);\n                                                if (c < ' ') {\n                                                    warningAt(\n\"Unexpected control character in regular expression.\", line, from + l);\n                                                } else if (c === '<') {\n                                                    warningAt(\n\"Unexpected escaped character '{a}' in regular expression.\", line, from + l, c);\n                                                }\n                                                l += 1;\n                                                q = true;\n                                                break;\n                                            case '/':\n                                                warningAt(\"Unescaped '{a}'.\",\n                                                        line, from + l - 1, '/');\n                                                q = true;\n                                                break;\n                                            case '<':\n                                                if (xmode === 'script') {\n                                                    c = s.charAt(l);\n                                                    if (c === '!' || c === '/') {\n                                                        warningAt(\n\"HTML confusion in regular expression '<{a}'.\", line, from + l, c);\n                                                    }\n                                                }\n                                                q = true;\n                                                break;\n                                            default:\n                                                q = true;\n                                            }\n                                        } while (c);\n                                        break;\n                                    case '.':\n                                        if (option.regexp) {\n                                            warningAt(\"Insecure '{a}'.\", line,\n                                                    from + l, c);\n                                        }\n                                        break;\n                                    case ']':\n                                    case '?':\n                                    case '{':\n                                    case '}':\n                                    case '+':\n                                    case '*':\n                                        warningAt(\"Unescaped '{a}'.\", line,\n                                                from + l, c);\n                                        break;\n                                    case '<':\n                                        if (xmode === 'script') {\n                                            c = s.charAt(l);\n                                            if (c === '!' || c === '/') {\n                                                warningAt(\n\"HTML confusion in regular expression '<{a}'.\", line, from + l, c);\n                                            }\n                                        }\n                                    }\n                                    if (b) {\n                                        switch (s.charAt(l)) {\n                                        case '?':\n                                        case '+':\n                                        case '*':\n                                            l += 1;\n                                            if (s.charAt(l) === '?') {\n                                                l += 1;\n                                            }\n                                            break;\n                                        case '{':\n                                            l += 1;\n                                            c = s.charAt(l);\n                                            if (c < '0' || c > '9') {\n                                                warningAt(\n\"Expected a number and instead saw '{a}'.\", line, from + l, c);\n                                            }\n                                            l += 1;\n                                            low = +c;\n                                            for (;;) {\n                                                c = s.charAt(l);\n                                                if (c < '0' || c > '9') {\n                                                    break;\n                                                }\n                                                l += 1;\n                                                low = +c + (low * 10);\n                                            }\n                                            high = low;\n                                            if (c === ',') {\n                                                l += 1;\n                                                high = Infinity;\n                                                c = s.charAt(l);\n                                                if (c >= '0' && c <= '9') {\n                                                    l += 1;\n                                                    high = +c;\n                                                    for (;;) {\n                                                        c = s.charAt(l);\n                                                        if (c < '0' || c > '9') {\n                                                            break;\n                                                        }\n                                                        l += 1;\n                                                        high = +c + (high * 10);\n                                                    }\n                                                }\n                                            }\n                                            if (s.charAt(l) !== '}') {\n                                                warningAt(\n\"Expected '{a}' and instead saw '{b}'.\", line, from + l, '}', c);\n                                            } else {\n                                                l += 1;\n                                            }\n                                            if (s.charAt(l) === '?') {\n                                                l += 1;\n                                            }\n                                            if (low > high) {\n                                                warningAt(\n\"'{a}' should not be greater than '{b}'.\", line, from + l, low, high);\n                                            }\n                                        }\n                                    }\n                                }\n                                c = s.substr(0, l - 1);\n                                character += l;\n                                s = s.substr(l);\n                                return it('(regexp)', c);\n                            }\n                            return it('(punctuator)', t);\n\n    //      punctuator\n\n                        case '<!--':\n                            l = line;\n                            c = character;\n                            for (;;) {\n                                i = s.indexOf('--');\n                                if (i >= 0) {\n                                    break;\n                                }\n                                i = s.indexOf('<!');\n                                if (i >= 0) {\n                                    errorAt(\"Nested HTML comment.\",\n                                        line, character + i);\n                                }\n                                if (!nextLine()) {\n                                    errorAt(\"Unclosed HTML comment.\", l, c);\n                                }\n                            }\n                            l = s.indexOf('<!');\n                            if (l >= 0 && l < i) {\n                                errorAt(\"Nested HTML comment.\",\n                                    line, character + l);\n                            }\n                            character += i;\n                            if (s.charAt(i + 2) !== '>') {\n                                errorAt(\"Expected -->.\", line, character);\n                            }\n                            character += 3;\n                            s = s.slice(i + 3);\n                            break;\n                        case '#':\n                            if (xmode === 'html' || xmode === 'styleproperty') {\n                                for (;;) {\n                                    c = s.charAt(0);\n                                    if ((c < '0' || c > '9') &&\n                                            (c < 'a' || c > 'f') &&\n                                            (c < 'A' || c > 'F')) {\n                                        break;\n                                    }\n                                    character += 1;\n                                    s = s.substr(1);\n                                    t += c;\n                                }\n                                if (t.length !== 4 && t.length !== 7) {\n                                    warningAt(\"Bad hex color '{a}'.\", line,\n                                        from + l, t);\n                                }\n                                return it('(color)', t);\n                            }\n                            return it('(punctuator)', t);\n                        default:\n                            if (xmode === 'outer' && c === '&') {\n                                character += 1;\n                                s = s.substr(1);\n                                for (;;) {\n                                    c = s.charAt(0);\n                                    character += 1;\n                                    s = s.substr(1);\n                                    if (c === ';') {\n                                        break;\n                                    }\n                                    if (!((c >= '0' && c <= '9') ||\n                                            (c >= 'a' && c <= 'z') ||\n                                            c === '#')) {\n                                        errorAt(\"Bad entity\", line, from + l,\n                                        character);\n                                    }\n                                }\n                                break;\n                            }\n                            return it('(punctuator)', t);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n\n    function addlabel(t, type) {\n\n        if (option.safe && funct['(global)'] &&\n                typeof predefined[t] !== 'boolean') {\n            warning('ADsafe global: ' + t + '.', token);\n        } else if (t === 'hasOwnProperty') {\n            warning(\"'hasOwnProperty' is a really bad name.\");\n        }\n\n// Define t in the current function in the current scope.\n\n        if (is_own(funct, t) && !funct['(global)']) {\n            warning(funct[t] === true ?\n                \"'{a}' was used before it was defined.\" :\n                \"'{a}' is already defined.\",\n                nexttoken, t);\n        }\n        funct[t] = type;\n        if (funct['(global)']) {\n            global[t] = funct;\n            if (is_own(implied, t)) {\n                warning(\"'{a}' was used before it was defined.\", nexttoken, t);\n                delete implied[t];\n            }\n        } else {\n            scope[t] = funct;\n        }\n    }\n\n\n    function doOption() {\n        var b, obj, filter, o = nexttoken.value, t, v;\n        switch (o) {\n        case '*/':\n            error(\"Unbegun comment.\");\n            break;\n        case '/*members':\n        case '/*member':\n            o = '/*members';\n            if (!membersOnly) {\n                membersOnly = {};\n            }\n            obj = membersOnly;\n            break;\n        case '/*jslint':\n            if (option.safe) {\n                warning(\"ADsafe restriction.\");\n            }\n            obj = option;\n            filter = boolOptions;\n            break;\n        case '/*global':\n            if (option.safe) {\n                warning(\"ADsafe restriction.\");\n            }\n            obj = predefined;\n            break;\n        default:\n        }\n        t = lex.token();\nloop:   for (;;) {\n            for (;;) {\n                if (t.type === 'special' && t.value === '*/') {\n                    break loop;\n                }\n                if (t.id !== '(endline)' && t.id !== ',') {\n                    break;\n                }\n                t = lex.token();\n            }\n            if (t.type !== '(string)' && t.type !== '(identifier)' &&\n                    o !== '/*members') {\n                error(\"Bad option.\", t);\n            }\n            v = lex.token();\n            if (v.id === ':') {\n                v = lex.token();\n                if (obj === membersOnly) {\n                    error(\"Expected '{a}' and instead saw '{b}'.\",\n                            t, '*/', ':');\n                }\n                if (t.value === 'indent' && o === '/*jslint') {\n                    b = +v.value;\n                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||\n                            Math.floor(b) !== b) {\n                        error(\"Expected a small integer and instead saw '{a}'.\",\n                                v, v.value);\n                    }\n                    obj.white = true;\n                    obj.indent = b;\n                } else if (t.value === 'maxerr' && o === '/*jslint') {\n                    b = +v.value;\n                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||\n                            Math.floor(b) !== b) {\n                        error(\"Expected a small integer and instead saw '{a}'.\",\n                                v, v.value);\n                    }\n                    obj.maxerr = b;\n                } else if (t.value === 'maxlen' && o === '/*jslint') {\n                    b = +v.value;\n                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||\n                            Math.floor(b) !== b) {\n                        error(\"Expected a small integer and instead saw '{a}'.\",\n                                v, v.value);\n                    }\n                    obj.maxlen = b;\n                } else if (v.value === 'true') {\n                    obj[t.value] = true;\n                } else if (v.value === 'false') {\n                    obj[t.value] = false;\n                } else {\n                    error(\"Bad option value.\", v);\n                }\n                t = lex.token();\n            } else {\n                if (o === '/*jslint') {\n                    error(\"Missing option value.\", t);\n                }\n                obj[t.value] = false;\n                t = v;\n            }\n        }\n        if (filter) {\n            assume();\n        }\n    }\n\n\n// We need a peek function. If it has an argument, it peeks that much farther\n// ahead. It is used to distinguish\n//     for ( var i in ...\n// from\n//     for ( var i = ...\n\n    function peek(p) {\n        var i = p || 0, j = 0, t;\n\n        while (j <= i) {\n            t = lookahead[j];\n            if (!t) {\n                t = lookahead[j] = lex.token();\n            }\n            j += 1;\n        }\n        return t;\n    }\n\n\n\n// Produce the next token. It looks for programming errors.\n\n    function advance(id, t) {\n        switch (token.id) {\n        case '(number)':\n            if (nexttoken.id === '.') {\n                warning(\n\"A dot following a number can be confused with a decimal point.\", token);\n            }\n            break;\n        case '-':\n            if (nexttoken.id === '-' || nexttoken.id === '--') {\n                warning(\"Confusing minusses.\");\n            }\n            break;\n        case '+':\n            if (nexttoken.id === '+' || nexttoken.id === '++') {\n                warning(\"Confusing plusses.\");\n            }\n            break;\n        }\n        if (token.type === '(string)' || token.identifier) {\n            anonname = token.value;\n        }\n\n        if (id && nexttoken.id !== id) {\n            if (t) {\n                if (nexttoken.id === '(end)') {\n                    warning(\"Unmatched '{a}'.\", t, t.id);\n                } else {\n                    warning(\n\"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",\n                            nexttoken, id, t.id, t.line, nexttoken.value);\n                }\n            } else if (nexttoken.type !== '(identifier)' ||\n                            nexttoken.value !== id) {\n                warning(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, id, nexttoken.value);\n            }\n        }\n        prevtoken = token;\n        token = nexttoken;\n        for (;;) {\n            nexttoken = lookahead.shift() || lex.token();\n            if (nexttoken.id === '(end)' || nexttoken.id === '(error)') {\n                return;\n            }\n            if (nexttoken.type === 'special') {\n                doOption();\n            } else {\n                if (nexttoken.id !== '(endline)') {\n                    break;\n                }\n            }\n        }\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add to Pratt's model .fud, which is\n// like nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define JavaScript. I retained Pratt's\n// nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are key to the parsing method called Top Down Operator Precedence.\n\n    function parse(rbp, initial) {\n        var left;\n        if (nexttoken.id === '(end)') {\n            error(\"Unexpected early end of program.\", token);\n        }\n        advance();\n        if (option.safe && typeof predefined[token.value] === 'boolean' &&\n                (nexttoken.id !== '(' && nexttoken.id !== '.')) {\n            warning('ADsafe violation.', token);\n        }\n        if (initial) {\n            anonname = 'anonymous';\n            funct['(verb)'] = token.value;\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (nexttoken.type === '(number)' && token.id === '.') {\n                    warning(\n\"A leading decimal point can be confused with a dot: '.{a}'.\",\n                            token, nexttoken.value);\n                    advance();\n                    return token;\n                } else {\n                    error(\"Expected an identifier and instead saw '{a}'.\",\n                            token, token.id);\n                }\n            }\n            while (rbp < nexttoken.lbp) {\n                advance();\n                if (token.led) {\n                    left = token.led(left);\n                } else {\n                    error(\"Expected an operator and instead saw '{a}'.\",\n                        token, token.id);\n                }\n            }\n        }\n        return left;\n    }\n\n\n// Functions for conformance of style.\n\n    function adjacent(left, right) {\n        left = left || token;\n        right = right || nexttoken;\n        if (option.white || xmode === 'styleproperty' || xmode === 'style') {\n            if (left.character !== right.from && left.line === right.line) {\n                warning(\"Unexpected space after '{a}'.\", right, left.value);\n            }\n        }\n    }\n\n    function nobreak(left, right) {\n        left = left || token;\n        right = right || nexttoken;\n        if (left.character !== right.from || left.line !== right.line) {\n            warning(\"Unexpected space before '{a}'.\", right, right.value);\n        }\n    }\n\n    function nospace(left, right) {\n        left = left || token;\n        right = right || nexttoken;\n        if (option.white && !left.comment) {\n            if (left.line === right.line) {\n                adjacent(left, right);\n            }\n        }\n    }\n\n\n    function nonadjacent(left, right) {\n        if (option.white) {\n            left = left || token;\n            right = right || nexttoken;\n            if (left.line === right.line && left.character === right.from) {\n                warning(\"Missing space after '{a}'.\",\n                        nexttoken, left.value);\n            }\n        }\n    }\n\n    function nobreaknonadjacent(left, right) {\n        left = left || token;\n        right = right || nexttoken;\n        if (!option.laxbreak && left.line !== right.line) {\n            warning(\"Bad line breaking before '{a}'.\", right, right.id);\n        } else if (option.white) {\n            left = left || token;\n            right = right || nexttoken;\n            if (left.character === right.from) {\n                warning(\"Missing space after '{a}'.\",\n                        nexttoken, left.value);\n            }\n        }\n    }\n\n    function indentation(bias) {\n        var i;\n        if (option.white && nexttoken.id !== '(end)') {\n            i = indent + (bias || 0);\n            if (nexttoken.from !== i) {\n                warning(\n\"Expected '{a}' to have an indentation at {b} instead at {c}.\",\n                        nexttoken, nexttoken.value, i, nexttoken.from);\n            }\n        }\n    }\n\n    function nolinebreak(t) {\n        t = t || token;\n        if (t.line !== nexttoken.line) {\n            warning(\"Line breaking error '{a}'.\", t, t.value);\n        }\n    }\n\n\n    function comma() {\n        if (token.line !== nexttoken.line) {\n            if (!option.laxbreak) {\n                warning(\"Bad line breaking before '{a}'.\", token, nexttoken.id);\n            }\n        } else if (token.character !== nexttoken.from && option.white) {\n            warning(\"Unexpected space after '{a}'.\", nexttoken, token.value);\n        }\n        advance(',');\n        nonadjacent(token, nexttoken);\n    }\n\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, p) {\n        var x = syntax[s];\n        if (!x || typeof x !== 'object') {\n            syntax[s] = x = {\n                id: s,\n                lbp: p,\n                value: s\n            };\n        }\n        return x;\n    }\n\n\n    function delim(s) {\n        return symbol(s, 0);\n    }\n\n\n    function stmt(s, f) {\n        var x = delim(s);\n        x.identifier = x.reserved = true;\n        x.fud = f;\n        return x;\n    }\n\n\n    function blockstmt(s, f) {\n        var x = stmt(s, f);\n        x.block = true;\n        return x;\n    }\n\n\n    function reserveName(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserveName(x);\n        x.nud = (typeof f === 'function') ? f : function () {\n            this.right = parse(150);\n            this.arity = 'unary';\n            if (this.id === '++' || this.id === '--') {\n                if (option.plusplus) {\n                    warning(\"Unexpected use of '{a}'.\", this, this.id);\n                } else if ((!this.right.identifier || this.right.reserved) &&\n                        this.right.id !== '.' && this.right.id !== '[') {\n                    warning(\"Bad operand.\", this);\n                }\n            }\n            return this;\n        };\n        return x;\n    }\n\n\n    function type(s, f) {\n        var x = delim(s);\n        x.type = s;\n        x.nud = f;\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = type(s, f);\n        x.identifier = x.reserved = true;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, f, p, w) {\n        var x = symbol(s, p);\n        reserveName(x);\n        x.led = function (left) {\n            if (!w) {\n                nobreaknonadjacent(prevtoken, token);\n                nonadjacent(token, nexttoken);\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            } else {\n                this.left = left;\n                this.right = parse(p);\n                return this;\n            }\n        };\n        return x;\n    }\n\n\n    function relation(s, f) {\n        var x = symbol(s, 100);\n        x.led = function (left) {\n            nobreaknonadjacent(prevtoken, token);\n            nonadjacent(token, nexttoken);\n            var right = parse(100);\n            if ((left && left.id === 'NaN') || (right && right.id === 'NaN')) {\n                warning(\"Use the isNaN function to compare with NaN.\", this);\n            } else if (f) {\n                f.apply(this, [left, right]);\n            }\n            if (left.id === '!') {\n                warning(\"Confusing use of '{a}'.\", left, '!');\n            }\n            if (right.id === '!') {\n                warning(\"Confusing use of '{a}'.\", left, '!');\n            }\n            this.left = left;\n            this.right = right;\n            return this;\n        };\n        return x;\n    }\n\n\n    function isPoorRelation(node) {\n        return node &&\n              ((node.type === '(number)' && +node.value === 0) ||\n               (node.type === '(string)' && node.value === '') ||\n                node.type === 'true' ||\n                node.type === 'false' ||\n                node.type === 'undefined' ||\n                node.type === 'null');\n    }\n\n\n    function assignop(s, f) {\n        symbol(s, 20).exps = true;\n        return infix(s, function (left, that) {\n            var l;\n            that.left = left;\n            if (predefined[left.value] === false &&\n                    scope[left.value]['(global)'] === true) {\n                warning(\"Read only.\", left);\n            } else if (left['function']) {\n                warning(\"'{a}' is a function.\", left, left.value);\n            }\n            if (option.safe) {\n                l = left;\n                do {\n                    if (typeof predefined[l.value] === 'boolean') {\n                        warning('ADsafe violation.', l);\n                    }\n                    l = l.left;\n                } while (l);\n            }\n            if (left) {\n                if (left.id === '.' || left.id === '[') {\n                    if (!left.left || left.left.value === 'arguments') {\n                        warning('Bad assignment.', that);\n                    }\n                    that.right = parse(19);\n                    return that;\n                } else if (left.identifier && !left.reserved) {\n                    if (funct[left.value] === 'exception') {\n                        warning(\"Do not assign to the exception parameter.\", left);\n                    }\n                    that.right = parse(19);\n                    return that;\n                }\n                if (left === syntax['function']) {\n                    warning(\n\"Expected an identifier in an assignment and instead saw a function invocation.\",\n                                token);\n                }\n            }\n            error(\"Bad assignment.\", that);\n        }, 20);\n    }\n\n\n    function bitwise(s, f, p) {\n        var x = symbol(s, p);\n        reserveName(x);\n        x.led = (typeof f === 'function') ? f : function (left) {\n            if (option.bitwise) {\n                warning(\"Unexpected use of '{a}'.\", this, this.id);\n            }\n            this.left = left;\n            this.right = parse(p);\n            return this;\n        };\n        return x;\n    }\n\n\n    function bitwiseassignop(s) {\n        symbol(s, 20).exps = true;\n        return infix(s, function (left, that) {\n            if (option.bitwise) {\n                warning(\"Unexpected use of '{a}'.\", that, that.id);\n            }\n            nonadjacent(prevtoken, token);\n            nonadjacent(token, nexttoken);\n            if (left) {\n                if (left.id === '.' || left.id === '[' ||\n                        (left.identifier && !left.reserved)) {\n                    parse(19);\n                    return that;\n                }\n                if (left === syntax['function']) {\n                    warning(\n\"Expected an identifier in an assignment, and instead saw a function invocation.\",\n                                token);\n                }\n                return that;\n            }\n            error(\"Bad assignment.\", that);\n        }, 20);\n    }\n\n\n    function suffix(s, f) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            if (option.plusplus) {\n                warning(\"Unexpected use of '{a}'.\", this, this.id);\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                warning(\"Bad operand.\", this);\n            }\n            this.left = left;\n            return this;\n        };\n        return x;\n    }\n\n\n    function optionalidentifier() {\n        if (nexttoken.identifier) {\n            advance();\n            if (option.safe && banned[token.value]) {\n                warning(\"ADsafe violation: '{a}'.\", token, token.value);\n            } else if (token.reserved && !option.es5) {\n                warning(\"Expected an identifier and instead saw '{a}' (a reserved word).\",\n                        token, token.id);\n            }\n            return token.value;\n        }\n    }\n\n\n    function identifier() {\n        var i = optionalidentifier();\n        if (i) {\n            return i;\n        }\n        if (token.id === 'function' && nexttoken.id === '(') {\n            warning(\"Missing name in function statement.\");\n        } else {\n            error(\"Expected an identifier and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n        }\n    }\n\n\n    function reachable(s) {\n        var i = 0, t;\n        if (nexttoken.id !== ';' || noreach) {\n            return;\n        }\n        for (;;) {\n            t = peek(i);\n            if (t.reach) {\n                return;\n            }\n            if (t.id !== '(endline)') {\n                if (t.id === 'function') {\n                    warning(\n\"Inner functions should be listed at the top of the outer function.\", t);\n                    break;\n                }\n                warning(\"Unreachable '{a}' after '{b}'.\", t, t.value, s);\n                break;\n            }\n            i += 1;\n        }\n    }\n\n\n    function statement(noindent) {\n        var i = indent, r, s = scope, t = nexttoken;\n\n// We don't like the empty statement.\n\n        if (t.id === ';') {\n            warning(\"Unnecessary semicolon.\", t);\n            advance(';');\n            return;\n        }\n\n// Is this a labelled statement?\n\n        if (t.identifier && !t.reserved && peek().id === ':') {\n            advance();\n            advance(':');\n            scope = Object.create(s);\n            addlabel(t.value, 'label');\n            if (!nexttoken.labelled) {\n                warning(\"Label '{a}' on {b} statement.\",\n                        nexttoken, t.value, nexttoken.value);\n            }\n            if (jx.test(t.value + ':')) {\n                warning(\"Label '{a}' looks like a javascript url.\",\n                        t, t.value);\n            }\n            nexttoken.label = t.value;\n            t = nexttoken;\n        }\n\n// Parse the statement.\n\n        if (!noindent) {\n            indentation();\n        }\n        r = parse(0, true);\n\n// Look for the final semicolon.\n\n        if (!t.block) {\n            if (!r || !r.exps) {\n                warning(\n\"Expected an assignment or function call and instead saw an expression.\",\n                        token);\n            } else if (r.id === '(' && r.left.id === 'new') {\n                warning(\"Do not use 'new' for side effects.\");\n            }\n            if (nexttoken.id !== ';') {\n                warningAt(\"Missing semicolon.\", token.line,\n                        token.from + token.value.length);\n            } else {\n                adjacent(token, nexttoken);\n                advance(';');\n                nonadjacent(token, nexttoken);\n            }\n        }\n\n// Restore the indentation.\n\n        indent = i;\n        scope = s;\n        return r;\n    }\n\n\n    function use_strict() {\n        if (nexttoken.value === 'use strict') {\n            advance();\n            advance(';');\n            strict_mode = true;\n            option.newcap = true;\n            option.undef = true;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\n    function statements(begin) {\n        var a = [], f, p;\n        if (begin && !use_strict() && option.strict) {\n            warning('Missing \"use strict\" statement.', nexttoken);\n        }\n        if (option.adsafe) {\n            switch (begin) {\n            case 'script':\n                if (!adsafe_may) {\n                    if (nexttoken.value !== 'ADSAFE' ||\n                            peek(0).id !== '.' ||\n                            (peek(1).value !== 'id' &&\n                            peek(1).value !== 'go')) {\n                        error('ADsafe violation: Missing ADSAFE.id or ADSAFE.go.',\n                            nexttoken);\n                    }\n                }\n                if (nexttoken.value === 'ADSAFE' &&\n                        peek(0).id === '.' &&\n                        peek(1).value === 'id') {\n                    if (adsafe_may) {\n                        error('ADsafe violation.', nexttoken);\n                    }\n                    advance('ADSAFE');\n                    advance('.');\n                    advance('id');\n                    advance('(');\n                    if (nexttoken.value !== adsafe_id) {\n                        error('ADsafe violation: id does not match.', nexttoken);\n                    }\n                    advance('(string)');\n                    advance(')');\n                    advance(';');\n                    adsafe_may = true;\n                }\n                break;\n            case 'lib':\n                if (nexttoken.value === 'ADSAFE') {\n                    advance('ADSAFE');\n                    advance('.');\n                    advance('lib');\n                    advance('(');\n                    advance('(string)');\n                    comma();\n                    f = parse(0);\n                    if (f.id !== 'function') {\n                        error('The second argument to lib must be a function.', f);\n                    }\n                    p = f.funct['(params)'];\n                    p = p && p.join(', ');\n                    if (p && p !== 'lib') {\n                        error(\"Expected '{a}' and instead saw '{b}'.\",\n                            f, '(lib)', '(' + p + ')');\n                    }\n                    advance(')');\n                    advance(';');\n                    return a;\n                } else {\n                    error(\"ADsafe lib violation.\");\n                }\n            }\n        }\n        while (!nexttoken.reach && nexttoken.id !== '(end)') {\n            if (nexttoken.id === ';') {\n                warning(\"Unnecessary semicolon.\");\n                advance(';');\n            } else {\n                a.push(statement());\n            }\n        }\n        return a;\n    }\n\n\n    function block(f) {\n        var a, b = inblock, old_indent = indent, s = scope, t;\n        inblock = f;\n        scope = Object.create(scope);\n        nonadjacent(token, nexttoken);\n        t = nexttoken;\n        if (nexttoken.id === '{') {\n            advance('{');\n            if (nexttoken.id !== '}' || token.line !== nexttoken.line) {\n                indent += option.indent;\n                while (!f && nexttoken.from > indent) {\n                    indent += option.indent;\n                }\n                if (!f) {\n                    use_strict();\n                }\n                a = statements();\n                indent -= option.indent;\n                indentation();\n            }\n            advance('}', t);\n            indent = old_indent;\n        } else {\n            warning(\"Expected '{a}' and instead saw '{b}'.\",\n                    nexttoken, '{', nexttoken.value);\n            noreach = true;\n            a = [statement()];\n            noreach = false;\n        }\n        funct['(verb)'] = null;\n        scope = s;\n        inblock = b;\n        if (f && (!a || a.length === 0)) {\n            warning(\"Empty block.\");\n        }\n        return a;\n    }\n\n\n    function countMember(m) {\n        if (membersOnly && typeof membersOnly[m] !== 'boolean') {\n            warning(\"Unexpected /*member '{a}'.\", token, m);\n        }\n        if (typeof member[m] === 'number') {\n            member[m] += 1;\n        } else {\n            member[m] = 1;\n        }\n    }\n\n\n    function note_implied(token) {\n        var name = token.value, line = token.line, a = implied[name];\n        if (typeof a === 'function') {\n            a = false;\n        }\n        if (!a) {\n            a = [line];\n            implied[name] = a;\n        } else if (a[a.length - 1] !== line) {\n            a.push(line);\n        }\n    }\n\n\n// CSS parsing.\n\n\n    function cssName() {\n        if (nexttoken.identifier) {\n            advance();\n            return true;\n        }\n    }\n\n\n    function cssNumber() {\n        if (nexttoken.id === '-') {\n            advance('-');\n            adjacent();\n            nolinebreak();\n        }\n        if (nexttoken.type === '(number)') {\n            advance('(number)');\n            return true;\n        }\n    }\n\n\n    function cssString() {\n        if (nexttoken.type === '(string)') {\n            advance();\n            return true;\n        }\n    }\n\n\n    function cssColor() {\n        var i, number, value;\n        if (nexttoken.identifier) {\n            value = nexttoken.value;\n            if (value === 'rgb' || value === 'rgba') {\n                advance();\n                advance('(');\n                for (i = 0; i < 3; i += 1) {\n                    if (i) {\n                        advance(',');\n                    }\n                    number = nexttoken.value;\n                    if (nexttoken.type !== '(number)' || number < 0) {\n                        warning(\"Expected a positive number and instead saw '{a}'\",\n                            nexttoken, number);\n                        advance();\n                    } else {\n                        advance();\n                        if (nexttoken.id === '%') {\n                            advance('%');\n                            if (number > 100) {\n                                warning(\"Expected a percentage and instead saw '{a}'\",\n                                    token, number);\n                            }\n                        } else {\n                            if (number > 255) {\n                                warning(\"Expected a small number and instead saw '{a}'\",\n                                    token, number);\n                            }\n                        }\n                    }\n                }\n                if (value === 'rgba') {\n                    advance(',');\n                    number = +nexttoken.value;\n                    if (nexttoken.type !== '(number)' || number < 0 || number > 1) {\n                        warning(\"Expected a number between 0 and 1 and instead saw '{a}'\",\n                            nexttoken, number);\n                    }\n                    advance();\n                    if (nexttoken.id === '%') {\n                        warning(\"Unexpected '%'.\");\n                        advance('%');\n                    }\n                }\n                advance(')');\n                return true;\n            } else if (cssColorData[nexttoken.value] === true) {\n                advance();\n                return true;\n            }\n        } else if (nexttoken.type === '(color)') {\n            advance();\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssLength() {\n        if (nexttoken.id === '-') {\n            advance('-');\n            adjacent();\n            nolinebreak();\n        }\n        if (nexttoken.type === '(number)') {\n            advance();\n            if (nexttoken.type !== '(string)' &&\n                    cssLengthData[nexttoken.value] === true) {\n                adjacent();\n                advance();\n            } else if (+token.value !== 0) {\n                warning(\"Expected a linear unit and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n            }\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssLineHeight() {\n        if (nexttoken.id === '-') {\n            advance('-');\n            adjacent();\n        }\n        if (nexttoken.type === '(number)') {\n            advance();\n            if (nexttoken.type !== '(string)' &&\n                    cssLengthData[nexttoken.value] === true) {\n                adjacent();\n                advance();\n            }\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssWidth() {\n        if (nexttoken.identifier) {\n            switch (nexttoken.value) {\n            case 'thin':\n            case 'medium':\n            case 'thick':\n                advance();\n                return true;\n            }\n        } else {\n            return cssLength();\n        }\n    }\n\n\n    function cssMargin() {\n        if (nexttoken.identifier) {\n            if (nexttoken.value === 'auto') {\n                advance();\n                return true;\n            }\n        } else {\n            return cssLength();\n        }\n    }\n\n    function cssAttr() {\n        if (nexttoken.identifier && nexttoken.value === 'attr') {\n            advance();\n            advance('(');\n            if (!nexttoken.identifier) {\n                warning(\"Expected a name and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n            }\n            advance();\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssCommaList() {\n        while (nexttoken.id !== ';') {\n            if (!cssName() && !cssString()) {\n                warning(\"Expected a name and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n            }\n            if (nexttoken.id !== ',') {\n                return true;\n            }\n            comma();\n        }\n    }\n\n\n    function cssCounter() {\n        if (nexttoken.identifier && nexttoken.value === 'counter') {\n            advance();\n            advance('(');\n            advance();\n            if (nexttoken.id === ',') {\n                comma();\n                if (nexttoken.type !== '(string)') {\n                    warning(\"Expected a string and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n            }\n            advance(')');\n            return true;\n        }\n        if (nexttoken.identifier && nexttoken.value === 'counters') {\n            advance();\n            advance('(');\n            if (!nexttoken.identifier) {\n                warning(\"Expected a name and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n            }\n            advance();\n            if (nexttoken.id === ',') {\n                comma();\n                if (nexttoken.type !== '(string)') {\n                    warning(\"Expected a string and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n            }\n            if (nexttoken.id === ',') {\n                comma();\n                if (nexttoken.type !== '(string)') {\n                    warning(\"Expected a string and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n            }\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssShape() {\n        var i;\n        if (nexttoken.identifier && nexttoken.value === 'rect') {\n            advance();\n            advance('(');\n            for (i = 0; i < 4; i += 1) {\n                if (!cssLength()) {\n                    warning(\"Expected a number and instead saw '{a}'.\",\n                        nexttoken, nexttoken.value);\n                    break;\n                }\n            }\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function cssUrl() {\n        var c, url;\n        if (nexttoken.identifier && nexttoken.value === 'url') {\n            nexttoken = lex.range('(', ')');\n            url = nexttoken.value;\n            c = url.charAt(0);\n            if (c === '\"' || c === '\\'') {\n                if (url.slice(-1) !== c) {\n                    warning(\"Bad url string.\");\n                } else {\n                    url = url.slice(1, -1);\n                    if (url.indexOf(c) >= 0) {\n                        warning(\"Bad url string.\");\n                    }\n                }\n            }\n            if (!url) {\n                warning(\"Missing url.\");\n            }\n            advance();\n            if (option.safe && ux.test(url)) {\n                error(\"ADsafe URL violation.\");\n            }\n            urls.push(url);\n            return true;\n        }\n        return false;\n    }\n\n\n    cssAny = [cssUrl, function () {\n        for (;;) {\n            if (nexttoken.identifier) {\n                switch (nexttoken.value.toLowerCase()) {\n                case 'url':\n                    cssUrl();\n                    break;\n                case 'expression':\n                    warning(\"Unexpected expression '{a}'.\",\n                        nexttoken, nexttoken.value);\n                    advance();\n                    break;\n                default:\n                    advance();\n                }\n            } else {\n                if (nexttoken.id === ';' || nexttoken.id === '!'  ||\n                        nexttoken.id === '(end)' || nexttoken.id === '}') {\n                    return true;\n                }\n                advance();\n            }\n        }\n    }];\n\n\n    cssBorderStyle = [\n        'none', 'dashed', 'dotted', 'double', 'groove',\n        'hidden', 'inset', 'outset', 'ridge', 'solid'\n    ];\n\n    cssBreak = [\n        'auto', 'always', 'avoid', 'left', 'right'\n    ];\n\n    cssMedia = {\n        'all': true,\n        'braille': true,\n        'embossed': true,\n        'handheld': true,\n        'print': true,\n        'projection': true,\n        'screen': true,\n        'speech': true,\n        'tty': true,\n        'tv': true\n    };\n\n    cssOverflow = [\n        'auto', 'hidden', 'scroll', 'visible'\n    ];\n\n    cssAttributeData = {\n        background: [\n            true, 'background-attachment', 'background-color',\n            'background-image', 'background-position', 'background-repeat'\n        ],\n        'background-attachment': ['scroll', 'fixed'],\n        'background-color': ['transparent', cssColor],\n        'background-image': ['none', cssUrl],\n        'background-position': [\n            2, [cssLength, 'top', 'bottom', 'left', 'right', 'center']\n        ],\n        'background-repeat': [\n            'repeat', 'repeat-x', 'repeat-y', 'no-repeat'\n        ],\n        'border': [true, 'border-color', 'border-style', 'border-width'],\n        'border-bottom': [\n            true, 'border-bottom-color', 'border-bottom-style',\n            'border-bottom-width'\n        ],\n        'border-bottom-color': cssColor,\n        'border-bottom-style': cssBorderStyle,\n        'border-bottom-width': cssWidth,\n        'border-collapse': ['collapse', 'separate'],\n        'border-color': ['transparent', 4, cssColor],\n        'border-left': [\n            true, 'border-left-color', 'border-left-style', 'border-left-width'\n        ],\n        'border-left-color': cssColor,\n        'border-left-style': cssBorderStyle,\n        'border-left-width': cssWidth,\n        'border-right': [\n            true, 'border-right-color', 'border-right-style',\n            'border-right-width'\n        ],\n        'border-right-color': cssColor,\n        'border-right-style': cssBorderStyle,\n        'border-right-width': cssWidth,\n        'border-spacing': [2, cssLength],\n        'border-style': [4, cssBorderStyle],\n        'border-top': [\n            true, 'border-top-color', 'border-top-style', 'border-top-width'\n        ],\n        'border-top-color': cssColor,\n        'border-top-style': cssBorderStyle,\n        'border-top-width': cssWidth,\n        'border-width': [4, cssWidth],\n        bottom: [cssLength, 'auto'],\n        'caption-side' : ['bottom', 'left', 'right', 'top'],\n        clear: ['both', 'left', 'none', 'right'],\n        clip: [cssShape, 'auto'],\n        color: cssColor,\n        content: [\n            'open-quote', 'close-quote', 'no-open-quote', 'no-close-quote',\n            cssString, cssUrl, cssCounter, cssAttr\n        ],\n        'counter-increment': [\n            cssName, 'none'\n        ],\n        'counter-reset': [\n            cssName, 'none'\n        ],\n        cursor: [\n            cssUrl, 'auto', 'crosshair', 'default', 'e-resize', 'help', 'move',\n            'n-resize', 'ne-resize', 'nw-resize', 'pointer', 's-resize',\n            'se-resize', 'sw-resize', 'w-resize', 'text', 'wait'\n        ],\n        direction: ['ltr', 'rtl'],\n        display: [\n            'block', 'compact', 'inline', 'inline-block', 'inline-table',\n            'list-item', 'marker', 'none', 'run-in', 'table', 'table-caption',\n            'table-cell', 'table-column', 'table-column-group',\n            'table-footer-group', 'table-header-group', 'table-row',\n            'table-row-group'\n        ],\n        'empty-cells': ['show', 'hide'],\n        'float': ['left', 'none', 'right'],\n        font: [\n            'caption', 'icon', 'menu', 'message-box', 'small-caption',\n            'status-bar', true, 'font-size', 'font-style', 'font-weight',\n            'font-family'\n        ],\n        'font-family': cssCommaList,\n        'font-size': [\n            'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large',\n            'xx-large', 'larger', 'smaller', cssLength\n        ],\n        'font-size-adjust': ['none', cssNumber],\n        'font-stretch': [\n            'normal', 'wider', 'narrower', 'ultra-condensed',\n            'extra-condensed', 'condensed', 'semi-condensed',\n            'semi-expanded', 'expanded', 'extra-expanded'\n        ],\n        'font-style': [\n            'normal', 'italic', 'oblique'\n        ],\n        'font-variant': [\n            'normal', 'small-caps'\n        ],\n        'font-weight': [\n            'normal', 'bold', 'bolder', 'lighter', cssNumber\n        ],\n        height: [cssLength, 'auto'],\n        left: [cssLength, 'auto'],\n        'letter-spacing': ['normal', cssLength],\n        'line-height': ['normal', cssLineHeight],\n        'list-style': [\n            true, 'list-style-image', 'list-style-position', 'list-style-type'\n        ],\n        'list-style-image': ['none', cssUrl],\n        'list-style-position': ['inside', 'outside'],\n        'list-style-type': [\n            'circle', 'disc', 'square', 'decimal', 'decimal-leading-zero',\n            'lower-roman', 'upper-roman', 'lower-greek', 'lower-alpha',\n            'lower-latin', 'upper-alpha', 'upper-latin', 'hebrew', 'katakana',\n            'hiragana-iroha', 'katakana-oroha', 'none'\n        ],\n        margin: [4, cssMargin],\n        'margin-bottom': cssMargin,\n        'margin-left': cssMargin,\n        'margin-right': cssMargin,\n        'margin-top': cssMargin,\n        'marker-offset': [cssLength, 'auto'],\n        'max-height': [cssLength, 'none'],\n        'max-width': [cssLength, 'none'],\n        'min-height': cssLength,\n        'min-width': cssLength,\n        opacity: cssNumber,\n        outline: [true, 'outline-color', 'outline-style', 'outline-width'],\n        'outline-color': ['invert', cssColor],\n        'outline-style': [\n            'dashed', 'dotted', 'double', 'groove', 'inset', 'none',\n            'outset', 'ridge', 'solid'\n        ],\n        'outline-width': cssWidth,\n        overflow: cssOverflow,\n        'overflow-x': cssOverflow,\n        'overflow-y': cssOverflow,\n        padding: [4, cssLength],\n        'padding-bottom': cssLength,\n        'padding-left': cssLength,\n        'padding-right': cssLength,\n        'padding-top': cssLength,\n        'page-break-after': cssBreak,\n        'page-break-before': cssBreak,\n        position: ['absolute', 'fixed', 'relative', 'static'],\n        quotes: [8, cssString],\n        right: [cssLength, 'auto'],\n        'table-layout': ['auto', 'fixed'],\n        'text-align': ['center', 'justify', 'left', 'right'],\n        'text-decoration': [\n            'none', 'underline', 'overline', 'line-through', 'blink'\n        ],\n        'text-indent': cssLength,\n        'text-shadow': ['none', 4, [cssColor, cssLength]],\n        'text-transform': ['capitalize', 'uppercase', 'lowercase', 'none'],\n        top: [cssLength, 'auto'],\n        'unicode-bidi': ['normal', 'embed', 'bidi-override'],\n        'vertical-align': [\n            'baseline', 'bottom', 'sub', 'super', 'top', 'text-top', 'middle',\n            'text-bottom', cssLength\n        ],\n        visibility: ['visible', 'hidden', 'collapse'],\n        'white-space': [\n            'normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'inherit'\n        ],\n        width: [cssLength, 'auto'],\n        'word-spacing': ['normal', cssLength],\n        'word-wrap': ['break-word', 'normal'],\n        'z-index': ['auto', cssNumber]\n    };\n\n    function styleAttribute() {\n        var v;\n        while (nexttoken.id === '*' || nexttoken.id === '#' ||\n                nexttoken.value === '_') {\n            if (!option.css) {\n                warning(\"Unexpected '{a}'.\", nexttoken, nexttoken.value);\n            }\n            advance();\n        }\n        if (nexttoken.id === '-') {\n            if (!option.css) {\n                warning(\"Unexpected '{a}'.\", nexttoken, nexttoken.value);\n            }\n            advance('-');\n            if (!nexttoken.identifier) {\n                warning(\n\"Expected a non-standard style attribute and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n            }\n            advance();\n            return cssAny;\n        } else {\n            if (!nexttoken.identifier) {\n                warning(\"Excepted a style attribute, and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n            } else {\n                if (is_own(cssAttributeData, nexttoken.value)) {\n                    v = cssAttributeData[nexttoken.value];\n                } else {\n                    v = cssAny;\n                    if (!option.css) {\n                        warning(\"Unrecognized style attribute '{a}'.\",\n                                nexttoken, nexttoken.value);\n                    }\n                }\n            }\n            advance();\n            return v;\n        }\n    }\n\n\n    function styleValue(v) {\n        var i = 0,\n            n,\n            once,\n            match,\n            round,\n            start = 0,\n            vi;\n        switch (typeof v) {\n        case 'function':\n            return v();\n        case 'string':\n            if (nexttoken.identifier && nexttoken.value === v) {\n                advance();\n                return true;\n            }\n            return false;\n        }\n        for (;;) {\n            if (i >= v.length) {\n                return false;\n            }\n            vi = v[i];\n            i += 1;\n            if (vi === true) {\n                break;\n            } else if (typeof vi === 'number') {\n                n = vi;\n                vi = v[i];\n                i += 1;\n            } else {\n                n = 1;\n            }\n            match = false;\n            while (n > 0) {\n                if (styleValue(vi)) {\n                    match = true;\n                    n -= 1;\n                } else {\n                    break;\n                }\n            }\n            if (match) {\n                return true;\n            }\n        }\n        start = i;\n        once = [];\n        for (;;) {\n            round = false;\n            for (i = start; i < v.length; i += 1) {\n                if (!once[i]) {\n                    if (styleValue(cssAttributeData[v[i]])) {\n                        match = true;\n                        round = true;\n                        once[i] = true;\n                        break;\n                    }\n                }\n            }\n            if (!round) {\n                return match;\n            }\n        }\n    }\n\n    function styleChild() {\n        if (nexttoken.id === '(number)') {\n            advance();\n            if (nexttoken.value === 'n' && nexttoken.identifier) {\n                adjacent();\n                advance();\n                if (nexttoken.id === '+') {\n                    adjacent();\n                    advance('+');\n                    adjacent();\n                    advance('(number)');\n                }\n            }\n            return;\n        } else {\n            switch (nexttoken.value) {\n            case 'odd':\n            case 'even':\n                if (nexttoken.identifier) {\n                    advance();\n                    return;\n                }\n            }\n        }\n        warning(\"Unexpected token '{a}'.\", nexttoken, nexttoken.value);\n    }\n\n    function substyle() {\n        var v;\n        for (;;) {\n            if (nexttoken.id === '}' || nexttoken.id === '(end)' ||\n                    xquote && nexttoken.id === xquote) {\n                return;\n            }\n            while (nexttoken.id === ';') {\n                warning(\"Misplaced ';'.\");\n                advance(';');\n            }\n            v = styleAttribute();\n            advance(':');\n            if (nexttoken.identifier && nexttoken.value === 'inherit') {\n                advance();\n            } else {\n                if (!styleValue(v)) {\n                    warning(\"Unexpected token '{a}'.\", nexttoken,\n                        nexttoken.value);\n                    advance();\n                }\n            }\n            if (nexttoken.id === '!') {\n                advance('!');\n                adjacent();\n                if (nexttoken.identifier && nexttoken.value === 'important') {\n                    advance();\n                } else {\n                    warning(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, 'important', nexttoken.value);\n                }\n            }\n            if (nexttoken.id === '}' || nexttoken.id === xquote) {\n                warning(\"Missing '{a}'.\", nexttoken, ';');\n            } else {\n                advance(';');\n            }\n        }\n    }\n\n    function styleSelector() {\n        if (nexttoken.identifier) {\n            if (!is_own(htmltag, option.cap ?\n                    nexttoken.value.toLowerCase() : nexttoken.value)) {\n                warning(\"Expected a tagName, and instead saw {a}.\",\n                    nexttoken, nexttoken.value);\n            }\n            advance();\n        } else {\n            switch (nexttoken.id) {\n            case '>':\n            case '+':\n                advance();\n                styleSelector();\n                break;\n            case ':':\n                advance(':');\n                switch (nexttoken.value) {\n                case 'active':\n                case 'after':\n                case 'before':\n                case 'checked':\n                case 'disabled':\n                case 'empty':\n                case 'enabled':\n                case 'first-child':\n                case 'first-letter':\n                case 'first-line':\n                case 'first-of-type':\n                case 'focus':\n                case 'hover':\n                case 'last-child':\n                case 'last-of-type':\n                case 'link':\n                case 'only-of-type':\n                case 'root':\n                case 'target':\n                case 'visited':\n                    advance();\n                    break;\n                case 'lang':\n                    advance();\n                    advance('(');\n                    if (!nexttoken.identifier) {\n                        warning(\"Expected a lang code, and instead saw :{a}.\",\n                            nexttoken, nexttoken.value);\n                    }\n                    advance(')');\n                    break;\n                case 'nth-child':\n                case 'nth-last-child':\n                case 'nth-last-of-type':\n                case 'nth-of-type':\n                    advance();\n                    advance('(');\n                    styleChild();\n                    advance(')');\n                    break;\n                case 'not':\n                    advance();\n                    advance('(');\n                    if (nexttoken.id === ':' && peek(0).value === 'not') {\n                        warning(\"Nested not.\");\n                    }\n                    styleSelector();\n                    advance(')');\n                    break;\n                default:\n                    warning(\"Expected a pseudo, and instead saw :{a}.\",\n                        nexttoken, nexttoken.value);\n                }\n                break;\n            case '#':\n                advance('#');\n                if (!nexttoken.identifier) {\n                    warning(\"Expected an id, and instead saw #{a}.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n                break;\n            case '*':\n                advance('*');\n                break;\n            case '.':\n                advance('.');\n                if (!nexttoken.identifier) {\n                    warning(\"Expected a class, and instead saw #.{a}.\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n                break;\n            case '[':\n                advance('[');\n                if (!nexttoken.identifier) {\n                    warning(\"Expected an attribute, and instead saw [{a}].\",\n                        nexttoken, nexttoken.value);\n                }\n                advance();\n                if (nexttoken.id === '=' || nexttoken.value === '~=' ||\n                        nexttoken.value === '$=' ||\n                        nexttoken.value === '|=' ||\n                        nexttoken.id === '*=' ||\n                        nexttoken.id === '^=') {\n                    advance();\n                    if (nexttoken.type !== '(string)') {\n                        warning(\"Expected a string, and instead saw {a}.\",\n                            nexttoken, nexttoken.value);\n                    }\n                    advance();\n                }\n                advance(']');\n                break;\n            default:\n                error(\"Expected a CSS selector, and instead saw {a}.\",\n                    nexttoken, nexttoken.value);\n            }\n        }\n    }\n\n    function stylePattern() {\n        if (nexttoken.id === '{') {\n            warning(\"Expected a style pattern, and instead saw '{a}'.\", nexttoken,\n                nexttoken.id);\n        }\n        for (;;) {\n            styleSelector();\n            if (nexttoken.id === '</' || nexttoken.id === '{' ||\n                    nexttoken.id === '(end)') {\n                return '';\n            }\n            if (nexttoken.id === ',') {\n                comma();\n            }\n        }\n    }\n\n    function stylelist() {\n        while (nexttoken.id !== '</' && nexttoken.id !== '(end)') {\n            stylePattern();\n            xmode = 'styleproperty';\n            if (nexttoken.id === ';') {\n                advance(';');\n            } else {\n                advance('{');\n                substyle();\n                xmode = 'style';\n                advance('}');\n            }\n        }\n    }\n\n    function styles() {\n        var i;\n        while (nexttoken.id === '@') {\n            i = peek();\n            advance('@');\n            if (nexttoken.identifier) {\n                switch (nexttoken.value) {\n                case 'import':\n                    advance();\n                    if (!cssUrl()) {\n                        warning(\"Expected '{a}' and instead saw '{b}'.\",\n                            nexttoken, 'url', nexttoken.value);\n                        advance();\n                    }\n                    advance(';');\n                    break;\n                case 'media':\n                    advance();\n                    for (;;) {\n                        if (!nexttoken.identifier || cssMedia[nexttoken.value] === true) {\n                            error(\"Expected a CSS media type, and instead saw '{a}'.\", nexttoken, nexttoken.id);\n                        }\n                        advance();\n                        if (nexttoken.id !== ',') {\n                            break;\n                        }\n                        advance(',');\n                    }\n                    advance('{');\n                    stylelist();\n                    advance('}');\n                    break;\n                default:\n                    warning(\"Expected an at-rule, and instead saw @{a}.\",\n                        nexttoken, nexttoken.value);\n                }\n            } else {\n                warning(\"Expected an at-rule, and instead saw '{a}'.\",\n                    nexttoken, nexttoken.value);\n            }\n        }\n        stylelist();\n    }\n\n\n// HTML parsing.\n\n    function doBegin(n) {\n        if (n !== 'html' && !option.fragment) {\n            if (n === 'div' && option.adsafe) {\n                error(\"ADSAFE: Use the fragment option.\");\n            } else {\n                error(\"Expected '{a}' and instead saw '{b}'.\",\n                    token, 'html', n);\n            }\n        }\n        if (option.adsafe) {\n            if (n === 'html') {\n                error(\n\"Currently, ADsafe does not operate on whole HTML documents. It operates on <div> fragments and .js files.\", token);\n            }\n            if (option.fragment) {\n                if (n !== 'div') {\n                    error(\"ADsafe violation: Wrap the widget in a div.\", token);\n                }\n            } else {\n                error(\"Use the fragment option.\", token);\n            }\n        }\n        option.browser = true;\n        assume();\n    }\n\n    function doAttribute(n, a, v) {\n        var u, x;\n        if (a === 'id') {\n            u = typeof v === 'string' ? v.toUpperCase() : '';\n            if (ids[u] === true) {\n                warning(\"Duplicate id='{a}'.\", nexttoken, v);\n            }\n            if (!/^[A-Za-z][A-Za-z0-9._:\\-]*$/.test(v)) {\n                warning(\"Bad id: '{a}'.\", nexttoken, v);\n            } else if (option.adsafe) {\n                if (adsafe_id) {\n                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {\n                        warning(\"ADsafe violation: An id must have a '{a}' prefix\",\n                                nexttoken, adsafe_id);\n                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {\n                        warning(\"ADSAFE violation: bad id.\");\n                    }\n                } else {\n                    adsafe_id = v;\n                    if (!/^[A-Z]+_$/.test(v)) {\n                        warning(\"ADSAFE violation: bad id.\");\n                    }\n                }\n            }\n            x = v.search(dx);\n            if (x >= 0) {\n                warning(\"Unexpected character '{a}' in {b}.\", token, v.charAt(x), a);\n            }\n            ids[u] = true;\n        } else if (a === 'class' || a === 'type' || a === 'name') {\n            x = v.search(qx);\n            if (x >= 0) {\n                warning(\"Unexpected character '{a}' in {b}.\", token, v.charAt(x), a);\n            }\n            ids[u] = true;\n        } else if (a === 'href' || a === 'background' ||\n                a === 'content' || a === 'data' ||\n                a.indexOf('src') >= 0 || a.indexOf('url') >= 0) {\n            if (option.safe && ux.test(v)) {\n                error(\"ADsafe URL violation.\");\n            }\n            urls.push(v);\n        } else if (a === 'for') {\n            if (option.adsafe) {\n                if (adsafe_id) {\n                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {\n                        warning(\"ADsafe violation: An id must have a '{a}' prefix\",\n                                nexttoken, adsafe_id);\n                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {\n                        warning(\"ADSAFE violation: bad id.\");\n                    }\n                } else {\n                    warning(\"ADSAFE violation: bad id.\");\n                }\n            }\n        } else if (a === 'name') {\n            if (option.adsafe && v.indexOf('_') >= 0) {\n                warning(\"ADsafe name violation.\");\n            }\n        }\n    }\n\n    function doTag(n, a) {\n        var i, t = htmltag[n], x;\n        src = false;\n        if (!t) {\n            error(\"Unrecognized tag '<{a}>'.\",\n                    nexttoken,\n                    n === n.toLowerCase() ? n :\n                        n + ' (capitalization error)');\n        }\n        if (stack.length > 0) {\n            if (n === 'html') {\n                error(\"Too many <html> tags.\", token);\n            }\n            x = t.parent;\n            if (x) {\n                if (x.indexOf(' ' + stack[stack.length - 1].name + ' ') < 0) {\n                    error(\"A '<{a}>' must be within '<{b}>'.\",\n                            token, n, x);\n                }\n            } else if (!option.adsafe && !option.fragment) {\n                i = stack.length;\n                do {\n                    if (i <= 0) {\n                        error(\"A '<{a}>' must be within '<{b}>'.\",\n                                token, n, 'body');\n                    }\n                    i -= 1;\n                } while (stack[i].name !== 'body');\n            }\n        }\n        switch (n) {\n        case 'div':\n            if (option.adsafe && stack.length === 1 && !adsafe_id) {\n                warning(\"ADSAFE violation: missing ID_.\");\n            }\n            break;\n        case 'script':\n            xmode = 'script';\n            advance('>');\n            indent = nexttoken.from;\n            if (a.lang) {\n                warning(\"lang is deprecated.\", token);\n            }\n            if (option.adsafe && stack.length !== 1) {\n                warning(\"ADsafe script placement violation.\", token);\n            }\n            if (a.src) {\n                if (option.adsafe && (!adsafe_may || !approved[a.src])) {\n                    warning(\"ADsafe unapproved script source.\", token);\n                }\n                if (a.type) {\n                    warning(\"type is unnecessary.\", token);\n                }\n            } else {\n                if (adsafe_went) {\n                    error(\"ADsafe script violation.\", token);\n                }\n                statements('script');\n            }\n            xmode = 'html';\n            advance('</');\n            if (!nexttoken.identifier && nexttoken.value !== 'script') {\n                warning(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, 'script', nexttoken.value);\n            }\n            advance();\n            xmode = 'outer';\n            break;\n        case 'style':\n            xmode = 'style';\n            advance('>');\n            styles();\n            xmode = 'html';\n            advance('</');\n            if (!nexttoken.identifier && nexttoken.value !== 'style') {\n                warning(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, 'style', nexttoken.value);\n            }\n            advance();\n            xmode = 'outer';\n            break;\n        case 'input':\n            switch (a.type) {\n            case 'radio':\n            case 'checkbox':\n            case 'button':\n            case 'reset':\n            case 'submit':\n                break;\n            case 'text':\n            case 'file':\n            case 'password':\n            case 'file':\n            case 'hidden':\n            case 'image':\n                if (option.adsafe && a.autocomplete !== 'off') {\n                    warning(\"ADsafe autocomplete violation.\");\n                }\n                break;\n            default:\n                warning(\"Bad input type.\");\n            }\n            break;\n        case 'applet':\n        case 'body':\n        case 'embed':\n        case 'frame':\n        case 'frameset':\n        case 'head':\n        case 'iframe':\n        case 'noembed':\n        case 'noframes':\n        case 'object':\n        case 'param':\n            if (option.adsafe) {\n                warning(\"ADsafe violation: Disallowed tag: \" + n);\n            }\n            break;\n        }\n    }\n\n\n    function closetag(n) {\n        return '</' + n + '>';\n    }\n\n    function html() {\n        var a, attributes, e, n, q, t, v, w = option.white, wmode;\n        xmode = 'html';\n        xquote = '';\n        stack = null;\n        for (;;) {\n            switch (nexttoken.value) {\n            case '<':\n                xmode = 'html';\n                advance('<');\n                attributes = {};\n                t = nexttoken;\n                if (!t.identifier) {\n                    warning(\"Bad identifier {a}.\", t, t.value);\n                }\n                n = t.value;\n                if (option.cap) {\n                    n = n.toLowerCase();\n                }\n                t.name = n;\n                advance();\n                if (!stack) {\n                    stack = [];\n                    doBegin(n);\n                }\n                v = htmltag[n];\n                if (typeof v !== 'object') {\n                    error(\"Unrecognized tag '<{a}>'.\", t, n);\n                }\n                e = v.empty;\n                t.type = n;\n                for (;;) {\n                    if (nexttoken.id === '/') {\n                        advance('/');\n                        if (nexttoken.id !== '>') {\n                            warning(\"Expected '{a}' and instead saw '{b}'.\",\n                                    nexttoken, '>', nexttoken.value);\n                        }\n                        break;\n                    }\n                    if (nexttoken.id && nexttoken.id.substr(0, 1) === '>') {\n                        break;\n                    }\n                    if (!nexttoken.identifier) {\n                        if (nexttoken.id === '(end)' || nexttoken.id === '(error)') {\n                            error(\"Missing '>'.\", nexttoken);\n                        }\n                        warning(\"Bad identifier.\");\n                    }\n                    option.white = true;\n                    nonadjacent(token, nexttoken);\n                    a = nexttoken.value;\n                    option.white = w;\n                    advance();\n                    if (!option.cap && a !== a.toLowerCase()) {\n                        warning(\"Attribute '{a}' not all lower case.\", nexttoken, a);\n                    }\n                    a = a.toLowerCase();\n                    xquote = '';\n                    if (is_own(attributes, a)) {\n                        warning(\"Attribute '{a}' repeated.\", nexttoken, a);\n                    }\n                    if (a.slice(0, 2) === 'on') {\n                        if (!option.on) {\n                            warning(\"Avoid HTML event handlers.\");\n                        }\n                        xmode = 'scriptstring';\n                        advance('=');\n                        q = nexttoken.id;\n                        if (q !== '\"' && q !== \"'\") {\n                            error(\"Missing quote.\");\n                        }\n                        xquote = q;\n                        wmode = option.white;\n                        option.white = false;\n                        advance(q);\n                        statements('on');\n                        option.white = wmode;\n                        if (nexttoken.id !== q) {\n                            error(\"Missing close quote on script attribute.\");\n                        }\n                        xmode = 'html';\n                        xquote = '';\n                        advance(q);\n                        v = false;\n                    } else if (a === 'style') {\n                        xmode = 'scriptstring';\n                        advance('=');\n                        q = nexttoken.id;\n                        if (q !== '\"' && q !== \"'\") {\n                            error(\"Missing quote.\");\n                        }\n                        xmode = 'styleproperty';\n                        xquote = q;\n                        advance(q);\n                        substyle();\n                        xmode = 'html';\n                        xquote = '';\n                        advance(q);\n                        v = false;\n                    } else {\n                        if (nexttoken.id === '=') {\n                            advance('=');\n                            v = nexttoken.value;\n                            if (!nexttoken.identifier &&\n                                    nexttoken.id !== '\"' &&\n                                    nexttoken.id !== '\\'' &&\n                                    nexttoken.type !== '(string)' &&\n                                    nexttoken.type !== '(number)' &&\n                                    nexttoken.type !== '(color)') {\n                                warning(\"Expected an attribute value and instead saw '{a}'.\", token, a);\n                            }\n                            advance();\n                        } else {\n                            v = true;\n                        }\n                    }\n                    attributes[a] = v;\n                    doAttribute(n, a, v);\n                }\n                doTag(n, attributes);\n                if (!e) {\n                    stack.push(t);\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '</':\n                xmode = 'html';\n                advance('</');\n                if (!nexttoken.identifier) {\n                    warning(\"Bad identifier.\");\n                }\n                n = nexttoken.value;\n                if (option.cap) {\n                    n = n.toLowerCase();\n                }\n                advance();\n                if (!stack) {\n                    error(\"Unexpected '{a}'.\", nexttoken, closetag(n));\n                }\n                t = stack.pop();\n                if (!t) {\n                    error(\"Unexpected '{a}'.\", nexttoken, closetag(n));\n                }\n                if (t.name !== n) {\n                    error(\"Expected '{a}' and instead saw '{b}'.\",\n                            nexttoken, closetag(t.name), closetag(n));\n                }\n                if (nexttoken.id !== '>') {\n                    error(\"Missing '{a}'.\", nexttoken, '>');\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '<!':\n                if (option.safe) {\n                    warning(\"ADsafe HTML violation.\");\n                }\n                xmode = 'html';\n                for (;;) {\n                    advance();\n                    if (nexttoken.id === '>' || nexttoken.id === '(end)') {\n                        break;\n                    }\n                    if (nexttoken.value.indexOf('--') >= 0) {\n                        error(\"Unexpected --.\");\n                    }\n                    if (nexttoken.value.indexOf('<') >= 0) {\n                        error(\"Unexpected <.\");\n                    }\n                    if (nexttoken.value.indexOf('>') >= 0) {\n                        error(\"Unexpected >.\");\n                    }\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '(end)':\n                return;\n            default:\n                if (nexttoken.id === '(end)') {\n                    error(\"Missing '{a}'.\", nexttoken,\n                            '</' + stack[stack.length - 1].value + '>');\n                } else {\n                    advance();\n                }\n            }\n            if (stack && stack.length === 0 && (option.adsafe ||\n                    !option.fragment || nexttoken.id === '(end)')) {\n                break;\n            }\n        }\n        if (nexttoken.id !== '(end)') {\n            error(\"Unexpected material after the end.\");\n        }\n    }\n\n\n// Build the syntax table by declaring the syntactic elements of the language.\n\n    type('(number)', function () {\n        return this;\n    });\n    type('(string)', function () {\n        return this;\n    });\n\n    syntax['(identifier)'] = {\n        type: '(identifier)',\n        lbp: 0,\n        identifier: true,\n        nud: function () {\n            var v = this.value,\n                s = scope[v],\n                f;\n            if (typeof s === 'function') {\n\n// Protection against accidental inheritance.\n\n                s = undefined;\n            } else if (typeof s === 'boolean') {\n                f = funct;\n                funct = functions[0];\n                addlabel(v, 'var');\n                s = funct;\n                funct = f;\n            }\n\n// The name is in scope and defined in the current function.\n\n            if (funct === s) {\n\n//      Change 'unused' to 'var', and reject labels.\n\n                switch (funct[v]) {\n                case 'unused':\n                    funct[v] = 'var';\n                    break;\n                case 'unction':\n                    funct[v] = 'function';\n                    this['function'] = true;\n                    break;\n                case 'function':\n                    this['function'] = true;\n                    break;\n                case 'label':\n                    warning(\"'{a}' is a statement label.\", token, v);\n                    break;\n                }\n\n// The name is not defined in the function.  If we are in the global scope,\n// then we have an undefined variable.\n\n            } else if (funct['(global)']) {\n                if (option.undef && predefined[v] !== 'boolean') {\n                    warning(\"'{a}' is not defined.\", token, v);\n                }\n                note_implied(token);\n\n// If the name is already defined in the current\n// function, but not as outer, then there is a scope error.\n\n            } else {\n                switch (funct[v]) {\n                case 'closure':\n                case 'function':\n                case 'var':\n                case 'unused':\n                    warning(\"'{a}' used out of scope.\", token, v);\n                    break;\n                case 'label':\n                    warning(\"'{a}' is a statement label.\", token, v);\n                    break;\n                case 'outer':\n                case 'global':\n                    break;\n                default:\n\n// If the name is defined in an outer function, make an outer entry, and if\n// it was unused, make it var.\n\n                    if (s === true) {\n                        funct[v] = true;\n                    } else if (s === null) {\n                        warning(\"'{a}' is not allowed.\", token, v);\n                        note_implied(token);\n                    } else if (typeof s !== 'object') {\n                        if (option.undef) {\n                            warning(\"'{a}' is not defined.\", token, v);\n                        } else {\n                            funct[v] = true;\n                        }\n                        note_implied(token);\n                    } else {\n                        switch (s[v]) {\n                        case 'function':\n                        case 'unction':\n                            this['function'] = true;\n                            s[v] = 'closure';\n                            funct[v] = s['(global)'] ? 'global' : 'outer';\n                            break;\n                        case 'var':\n                        case 'unused':\n                            s[v] = 'closure';\n                            funct[v] = s['(global)'] ? 'global' : 'outer';\n                            break;\n                        case 'closure':\n                        case 'parameter':\n                            funct[v] = s['(global)'] ? 'global' : 'outer';\n                            break;\n                        case 'label':\n                            warning(\"'{a}' is a statement label.\", token, v);\n                        }\n                    }\n                }\n            }\n            return this;\n        },\n        led: function () {\n            error(\"Expected an operator and instead saw '{a}'.\",\n                nexttoken, nexttoken.value);\n        }\n    };\n\n    type('(regexp)', function () {\n        return this;\n    });\n\n\n// ECMAScript parser\n\n    delim('(endline)');\n    delim('(begin)');\n    delim('(end)').reach = true;\n    delim('</').reach = true;\n    delim('<!');\n    delim('<!--');\n    delim('-->');\n    delim('(error)').reach = true;\n    delim('}').reach = true;\n    delim(')');\n    delim(']');\n    delim('\"').reach = true;\n    delim(\"'\").reach = true;\n    delim(';');\n    delim(':').reach = true;\n    delim(',');\n    delim('#');\n    delim('@');\n    reserve('else');\n    reserve('case').reach = true;\n    reserve('catch');\n    reserve('default').reach = true;\n    reserve('finally');\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct['(global)']) {\n            warning(\"Strict violation.\", x);\n        } else if (option.safe) {\n            warning(\"ADsafe violation.\", x);\n        }\n    });\n    reservevar('eval', function (x) {\n        if (option.safe) {\n            warning(\"ADsafe violation.\", x);\n        }\n    });\n    reservevar('false');\n    reservevar('Infinity');\n    reservevar('NaN');\n    reservevar('null');\n    reservevar('this', function (x) {\n        if (strict_mode && ((funct['(statement)'] &&\n                funct['(name)'].charAt(0) > 'Z') || funct['(global)'])) {\n            warning(\"Strict violation.\", x);\n        } else if (option.safe) {\n            warning(\"ADsafe violation.\", x);\n        }\n    });\n    reservevar('true');\n    reservevar('undefined');\n    assignop('=', 'assign', 20);\n    assignop('+=', 'assignadd', 20);\n    assignop('-=', 'assignsub', 20);\n    assignop('*=', 'assignmult', 20);\n    assignop('/=', 'assigndiv', 20).nud = function () {\n        error(\"A regular expression literal can be confused with '/='.\");\n    };\n    assignop('%=', 'assignmod', 20);\n    bitwiseassignop('&=', 'assignbitand', 20);\n    bitwiseassignop('|=', 'assignbitor', 20);\n    bitwiseassignop('^=', 'assignbitxor', 20);\n    bitwiseassignop('<<=', 'assignshiftleft', 20);\n    bitwiseassignop('>>=', 'assignshiftright', 20);\n    bitwiseassignop('>>>=', 'assignshiftrightunsigned', 20);\n    infix('?', function (left, that) {\n        that.left = left;\n        that.right = parse(10);\n        advance(':');\n        that['else'] = parse(10);\n        return that;\n    }, 30);\n\n    infix('||', 'or', 40);\n    infix('&&', 'and', 50);\n    bitwise('|', 'bitor', 70);\n    bitwise('^', 'bitxor', 80);\n    bitwise('&', 'bitand', 90);\n    relation('==', function (left, right) {\n        if (option.eqeqeq) {\n            warning(\"Expected '{a}' and instead saw '{b}'.\",\n                    this, '===', '==');\n        } else if (isPoorRelation(left)) {\n            warning(\"Use '{a}' to compare with '{b}'.\",\n                this, '===', left.value);\n        } else if (isPoorRelation(right)) {\n            warning(\"Use '{a}' to compare with '{b}'.\",\n                this, '===', right.value);\n        }\n        return this;\n    });\n    relation('===');\n    relation('!=', function (left, right) {\n        if (option.eqeqeq) {\n            warning(\"Expected '{a}' and instead saw '{b}'.\",\n                    this, '!==', '!=');\n        } else if (isPoorRelation(left)) {\n            warning(\"Use '{a}' to compare with '{b}'.\",\n                    this, '!==', left.value);\n        } else if (isPoorRelation(right)) {\n            warning(\"Use '{a}' to compare with '{b}'.\",\n                    this, '!==', right.value);\n        }\n        return this;\n    });\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n    bitwise('<<', 'shiftleft', 120);\n    bitwise('>>', 'shiftright', 120);\n    bitwise('>>>', 'shiftrightunsigned', 120);\n    infix('in', 'in', 120);\n    infix('instanceof', 'instanceof', 120);\n    infix('+', function (left, that) {\n        var right = parse(130);\n        if (left && right && left.id === '(string)' && right.id === '(string)') {\n            left.value += right.value;\n            left.character = right.character;\n            if (jx.test(left.value)) {\n                warning(\"JavaScript URL.\", left);\n            }\n            return left;\n        }\n        that.left = left;\n        that.right = right;\n        return that;\n    }, 130);\n    prefix('+', 'num');\n    prefix('+++', function () {\n        warning(\"Confusing pluses.\");\n        this.right = parse(150);\n        this.arity = 'unary';\n        return this;\n    });\n    infix('+++', function (left) {\n        warning(\"Confusing pluses.\");\n        this.left = left;\n        this.right = parse(130);\n        return this;\n    }, 130);\n    infix('-', 'sub', 130);\n    prefix('-', 'neg');\n    prefix('---', function () {\n        warning(\"Confusing minuses.\");\n        this.right = parse(150);\n        this.arity = 'unary';\n        return this;\n    });\n    infix('---', function (left) {\n        warning(\"Confusing minuses.\");\n        this.left = left;\n        this.right = parse(130);\n        return this;\n    }, 130);\n    infix('*', 'mult', 140);\n    infix('/', 'div', 140);\n    infix('%', 'mod', 140);\n\n    suffix('++', 'postinc');\n    prefix('++', 'preinc');\n    syntax['++'].exps = true;\n\n    suffix('--', 'postdec');\n    prefix('--', 'predec');\n    syntax['--'].exps = true;\n    prefix('delete', function () {\n        var p = parse(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            warning(\"Variables should not be deleted.\");\n        }\n        this.first = p;\n        return this;\n    }).exps = true;\n\n\n    prefix('~', function () {\n        if (option.bitwise) {\n            warning(\"Unexpected '{a}'.\", this, '~');\n        }\n        parse(150);\n        return this;\n    });\n    prefix('!', function () {\n        this.right = parse(150);\n        this.arity = 'unary';\n        if (bang[this.right.id] === true) {\n            warning(\"Confusing use of '{a}'.\", this, '!');\n        }\n        return this;\n    });\n    prefix('typeof', 'typeof');\n    prefix('new', function () {\n        var c = parse(155), i;\n        if (c && c.id !== 'function') {\n            if (c.identifier) {\n                c['new'] = true;\n                switch (c.value) {\n                case 'Object':\n                    warning(\"Use the object literal notation {}.\", token);\n                    break;\n                case 'Array':\n                    if (nexttoken.id !== '(') {\n                        warning(\"Use the array literal notation [].\", token);\n                    } else {\n                        advance('(');\n                        if (nexttoken.id === ')') {\n                            warning(\"Use the array literal notation [].\", token);\n                        } else {\n                            i = parse(0);\n                            c.dimension = i;\n                            if ((i.id === '(number)' && /[.+\\-Ee]/.test(i.value)) ||\n                                    (i.id === '-' && !i.right) ||\n                                    i.id === '(string)' || i.id === '[' ||\n                                    i.id === '{' || i.id === 'true' ||\n                                    i.id === 'false' ||\n                                    i.id === 'null' || i.id === 'undefined' ||\n                                    i.id === 'Infinity') {\n                                warning(\"Use the array literal notation [].\", token);\n                            }\n                            if (nexttoken.id !== ')') {\n                                error(\"Use the array literal notation [].\", token);\n                            }\n                        }\n                        advance(')');\n                    }\n                    this.first = c;\n                    return this;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    warning(\"Do not use {a} as a constructor.\", token, c.value);\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        warning(\"The Function constructor is eval.\");\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        i = c.value.substr(0, 1);\n                        if (option.newcap && (i < 'A' || i > 'Z')) {\n                            warning(\n                    \"A constructor name should start with an uppercase letter.\",\n                                token);\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    warning(\"Bad constructor.\", token);\n                }\n            }\n        } else {\n            warning(\"Weird construction. Delete 'new'.\", this);\n        }\n        adjacent(token, nexttoken);\n        if (nexttoken.id !== '(') {\n            warning(\"Missing '()' invoking a constructor.\");\n        }\n        this.first = c;\n        return this;\n    });\n    syntax['new'].exps = true;\n\n    infix('.', function (left, that) {\n        adjacent(prevtoken, token);\n        nobreak();\n        var m = identifier();\n        if (typeof m === 'string') {\n            countMember(m);\n        }\n        that.left = left;\n        that.right = m;\n        if (left && left.value === 'arguments' &&\n                (m === 'callee' || m === 'caller')) {\n            warning(\"Avoid arguments.{a}.\", left, m);\n        } else if (!option.evil && left && left.value === 'document' &&\n                (m === 'write' || m === 'writeln')) {\n            warning(\"document.write can be a form of eval.\", left);\n        } else if (option.adsafe) {\n            if (left && left.value === 'ADSAFE') {\n                if (m === 'id' || m === 'lib') {\n                    warning(\"ADsafe violation.\", that);\n                } else if (m === 'go') {\n                    if (xmode !== 'script') {\n                        warning(\"ADsafe violation.\", that);\n                    } else if (adsafe_went || nexttoken.id !== '(' ||\n                            peek(0).id !== '(string)' ||\n                            peek(0).value !== adsafe_id ||\n                            peek(1).id !== ',') {\n                        error(\"ADsafe violation: go.\", that);\n                    }\n                    adsafe_went = true;\n                    adsafe_may = false;\n                }\n            }\n        }\n        if (!option.evil && (m === 'eval' || m === 'execScript')) {\n            warning('eval is evil.');\n        } else if (option.safe) {\n            for (;;) {\n                if (banned[m] === true) {\n                    warning(\"ADsafe restricted word '{a}'.\", token, m);\n                }\n                if (typeof predefined[left.value] !== 'boolean' ||\n                        nexttoken.id === '(') {\n                    break;\n                }\n                if (standard_member[m] === true) {\n                    if (nexttoken.id === '.') {\n                        warning(\"ADsafe violation.\", that);\n                    }\n                    break;\n                }\n                if (nexttoken.id !== '.') {\n                    warning(\"ADsafe violation.\", that);\n                    break;\n                }\n                advance('.');\n                token.left = that;\n                token.right = m;\n                that = token;\n                m = identifier();\n                if (typeof m === 'string') {\n                    countMember(m);\n                }\n            }\n        }\n        return that;\n    }, 160, true);\n\n    infix('(', function (left, that) {\n        if (prevtoken.id !== '}' && prevtoken.id !== ')') {\n            nobreak(prevtoken, token);\n        }\n        nospace();\n        if (option.immed && !left.immed && left.id === 'function') {\n            warning(\"Wrap an immediate function invocation in parentheses \" +\n                \"to assist the reader in understanding that the expression \" +\n                \"is the result of a function, and not the function itself.\");\n        }\n        var n = 0,\n            p = [];\n        if (left) {\n            if (left.type === '(identifier)') {\n                if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                    if (left.value !== 'Number' && left.value !== 'String' &&\n                            left.value !== 'Boolean' &&\n                            left.value !== 'Date') {\n                        if (left.value === 'Math') {\n                            warning(\"Math is not a function.\", left);\n                        } else if (option.newcap) {\n                            warning(\n\"Missing 'new' prefix when invoking a constructor.\", left);\n                        }\n                    }\n                }\n            } else if (left.id === '.') {\n                if (option.safe && left.left.value === 'Math' &&\n                        left.right === 'random') {\n                    warning(\"ADsafe violation.\", left);\n                }\n            }\n        }\n        if (nexttoken.id !== ')') {\n            for (;;) {\n                p[p.length] = parse(10);\n                n += 1;\n                if (nexttoken.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        advance(')');\n        nospace(prevtoken, token);\n        if (typeof left === 'object') {\n            if (left.value === 'parseInt' && n === 1) {\n                warning(\"Missing radix parameter.\", left);\n            }\n            if (!option.evil) {\n                if (left.value === 'eval' || left.value === 'Function' ||\n                        left.value === 'execScript') {\n                    warning(\"eval is evil.\", left);\n                } else if (p[0] && p[0].id === '(string)' &&\n                       (left.value === 'setTimeout' ||\n                        left.value === 'setInterval')) {\n                    warning(\n    \"Implied eval is evil. Pass a function instead of a string.\", left);\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                warning(\"Bad invocation.\", left);\n            }\n        }\n        that.left = left;\n        return that;\n    }, 155, true).exps = true;\n\n    prefix('(', function () {\n        nospace();\n        if (nexttoken.id === 'function') {\n            nexttoken.immed = true;\n        }\n        var v = parse(0);\n        advance(')', this);\n        nospace(prevtoken, token);\n        if (option.immed && v.id === 'function') {\n            if (nexttoken.id === '(') {\n                warning(\n\"Move the invocation into the parens that contain the function.\", nexttoken);\n            } else {\n                warning(\n\"Do not wrap function literals in parens unless they are to be immediately invoked.\",\n                        this);\n            }\n        }\n        return v;\n    });\n\n    infix('[', function (left, that) {\n        nobreak(prevtoken, token);\n        nospace();\n        var e = parse(0), s;\n        if (e && e.type === '(string)') {\n            if (option.safe && banned[e.value] === true) {\n                warning(\"ADsafe restricted word '{a}'.\", that, e.value);\n            } else if (!option.evil &&\n                    (e.value === 'eval' || e.value === 'execScript')) {\n                warning(\"eval is evil.\", that);\n            } else if (option.safe &&\n                    (e.value.charAt(0) === '_' || e.value.charAt(0) === '-')) {\n                warning(\"ADsafe restricted subscript '{a}'.\", that, e.value);\n            }\n            countMember(e.value);\n            if (!option.sub && ix.test(e.value)) {\n                s = syntax[e.value];\n                if (!s || !s.reserved) {\n                    warning(\"['{a}'] is better written in dot notation.\",\n                            e, e.value);\n                }\n            }\n        } else if (!e || e.type !== '(number)' || e.value < 0) {\n            if (option.safe) {\n                warning('ADsafe subscripting.');\n            }\n        }\n        advance(']', that);\n        nospace(prevtoken, token);\n        that.left = left;\n        that.right = e;\n        return that;\n    }, 160, true);\n\n    prefix('[', function () {\n        var b = token.line !== nexttoken.line;\n        this.first = [];\n        if (b) {\n            indent += option.indent;\n            if (nexttoken.from === indent + option.indent) {\n                indent += option.indent;\n            }\n        }\n        while (nexttoken.id !== '(end)') {\n            while (nexttoken.id === ',') {\n                warning(\"Extra comma.\");\n                advance(',');\n            }\n            if (nexttoken.id === ']') {\n                break;\n            }\n            if (b && token.line !== nexttoken.line) {\n                indentation();\n            }\n            this.first.push(parse(10));\n            if (nexttoken.id === ',') {\n                comma();\n                if (nexttoken.id === ']' && !option.es5) {\n                    warning(\"Extra comma.\", token);\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        if (b) {\n            indent -= option.indent;\n            indentation();\n        }\n        advance(']', this);\n        return this;\n    }, 160);\n\n\n    function property_name() {\n        var id = optionalidentifier(true);\n        if (!id) {\n            if (nexttoken.id === '(string)') {\n                id = nexttoken.value;\n                if (option.adsafe &&\n                        (id.charAt(0) === '_' ||\n                         id.charAt(id.length - 1) === '_')) {\n                    warning(\"Unexpected {a} in '{b}'.\", token,\n                        \"dangling '_'\", id);\n                }\n                advance();\n            } else if (nexttoken.id === '(number)') {\n                id = nexttoken.value.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n    function functionparams() {\n        var i, t = nexttoken, p = [];\n        advance('(');\n        nospace();\n        if (nexttoken.id === ')') {\n            advance(')');\n            nospace(prevtoken, token);\n            return;\n        }\n        for (;;) {\n            i = identifier();\n            p.push(i);\n            addlabel(i, 'parameter');\n            if (nexttoken.id === ',') {\n                comma();\n            } else {\n                advance(')', t);\n                nospace(prevtoken, token);\n                return p;\n            }\n        }\n    }\n\n\n    function doFunction(i, statement) {\n        var f, s = scope;\n        scope = Object.create(s);\n        funct = {\n            '(name)'     : i || '\"' + anonname + '\"',\n            '(line)'     : nexttoken.line,\n            '(context)'  : funct,\n            '(breakage)' : 0,\n            '(loopage)'  : 0,\n            '(scope)'    : scope,\n            '(statement)': statement\n        };\n        f = funct;\n        token.funct = funct;\n        functions.push(funct);\n        if (i) {\n            addlabel(i, 'function');\n        }\n        funct['(params)'] = functionparams();\n\n        block(false);\n        scope = s;\n        funct['(last)'] = token.line;\n        funct = funct['(context)'];\n        return f;\n    }\n\n\n    (function (x) {\n        x.nud = function () {\n            var b, f, i, j, p, seen = {}, t;\n            b = token.line !== nexttoken.line;\n            if (b) {\n                indent += option.indent;\n                if (nexttoken.from === indent + option.indent) {\n                    indent += option.indent;\n                }\n            }\n            for (;;) {\n                if (nexttoken.id === '}') {\n                    break;\n                }\n                if (b) {\n                    indentation();\n                }\n                if (nexttoken.value === 'get' && peek().id !== ':') {\n                    advance('get');\n                    if (!option.es5) {\n                        error(\"get/set are ES5 features.\");\n                    }\n                    i = property_name();\n                    if (!i) {\n                        error(\"Missing property name.\");\n                    }\n                    t = nexttoken;\n                    adjacent(token, nexttoken);\n                    f = doFunction(i);\n                    if (funct['(loopage)']) {\n                        warning(\"Don't make functions within a loop.\", t);\n                    }\n                    p = f['(params)'];\n                    if (p) {\n                        warning(\"Unexpected parameter '{a}' in get {b} function.\", t, p[0], i);\n                    }\n                    adjacent(token, nexttoken);\n                    advance(',');\n                    indentation();\n                    advance('set');\n                    j = property_name();\n                    if (i !== j) {\n                        error(\"Expected {a} and instead saw {b}.\", token, i, j);\n                    }\n                    t = nexttoken;\n                    adjacent(token, nexttoken);\n                    f = doFunction(i);\n                    p = f['(params)'];\n                    if (!p || p.length !== 1 || p[0] !== 'value') {\n                        warning(\"Expected (value) in set {a} function.\", t, i);\n                    }\n                } else {\n                    i = property_name();\n                    if (typeof i !== 'string') {\n                        break;\n                    }\n                    advance(':');\n                    nonadjacent(token, nexttoken);\n                    parse(10);\n                }\n                if (seen[i] === true) {\n                    warning(\"Duplicate member '{a}'.\", nexttoken, i);\n                }\n                seen[i] = true;\n                countMember(i);\n                if (nexttoken.id === ',') {\n                    comma();\n                    if (nexttoken.id === ',') {\n                        warning(\"Extra comma.\", token);\n                    } else if (nexttoken.id === '}' && !option.es5) {\n                        warning(\"Extra comma.\", token);\n                    }\n                } else {\n                    break;\n                }\n            }\n            if (b) {\n                indent -= option.indent;\n                indentation();\n            }\n            advance('}', this);\n            return this;\n        };\n        x.fud = function () {\n            error(\"Expected to see a statement and instead saw a block.\", token);\n        };\n    }(delim('{')));\n\n\n    var varstatement = function varstatement(prefix) {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n        var id, name, value;\n\n        if (funct['(onevar)'] && option.onevar) {\n            warning(\"Too many var statements.\");\n        } else if (!funct['(global)']) {\n            funct['(onevar)'] = true;\n        }\n        this.first = [];\n        for (;;) {\n            nonadjacent(token, nexttoken);\n            id = identifier();\n            if (funct['(global)'] && predefined[id] === false) {\n                warning(\"Redefinition of '{a}'.\", token, id);\n            }\n            addlabel(id, 'unused');\n            if (prefix) {\n                break;\n            }\n            name = token;\n            this.first.push(token);\n            if (nexttoken.id === '=') {\n                nonadjacent(token, nexttoken);\n                advance('=');\n                nonadjacent(token, nexttoken);\n                if (nexttoken.id === 'undefined') {\n                    warning(\"It is not necessary to initialize '{a}' to 'undefined'.\", token, id);\n                }\n                if (peek(0).id === '=' && nexttoken.identifier) {\n                    advance();\n                    advance('=');\n                    advance();\n//                    error(\"Variable {a} was not declared correctly.\",\n//                            nexttoken, nexttoken.value);\n                }\n                value = parse(0);\n                name.first = value;\n            }\n            if (nexttoken.id !== ',') {\n                break;\n            }\n            comma();\n        }\n        return this;\n    };\n\n\n    stmt('var', varstatement).exps = true;\n\n\n    blockstmt('function', function () {\n        if (inblock) {\n            warning(\n\"Function statements cannot be placed in blocks. Use a function expression or move the statement to the top of the outer function.\", token);\n\n        }\n        var i = identifier();\n        adjacent(token, nexttoken);\n        addlabel(i, 'unction');\n        doFunction(i, true);\n        if (nexttoken.id === '(' && nexttoken.line === token.line) {\n            error(\n\"Function statements are not invocable. Wrap the whole function invocation in parens.\");\n        }\n        return this;\n    });\n\n    prefix('function', function () {\n        var i = optionalidentifier();\n        if (i) {\n            adjacent(token, nexttoken);\n        } else {\n            nonadjacent(token, nexttoken);\n        }\n        doFunction(i);\n        if (funct['(loopage)']) {\n            warning(\"Don't make functions within a loop.\");\n        }\n        return this;\n    });\n\n    blockstmt('if', function () {\n        var t = nexttoken;\n        advance('(');\n        nonadjacent(this, t);\n        nospace();\n        parse(20);\n        if (nexttoken.id === '=') {\n            warning(\"Expected a conditional expression and instead saw an assignment.\");\n            advance('=');\n            parse(20);\n        }\n        advance(')', t);\n        nospace(prevtoken, token);\n        block(true);\n        if (nexttoken.id === 'else') {\n            nonadjacent(token, nexttoken);\n            advance('else');\n            if (nexttoken.id === 'if' || nexttoken.id === 'switch') {\n                statement(true);\n            } else {\n                block(true);\n            }\n        }\n        return this;\n    });\n\n    blockstmt('try', function () {\n        var b, e, s;\n        if (option.adsafe) {\n            warning(\"ADsafe try violation.\", this);\n        }\n        block(false);\n        if (nexttoken.id === 'catch') {\n            advance('catch');\n            nonadjacent(token, nexttoken);\n            advance('(');\n            s = scope;\n            scope = Object.create(s);\n            e = nexttoken.value;\n            if (nexttoken.type !== '(identifier)') {\n                warning(\"Expected an identifier and instead saw '{a}'.\",\n                    nexttoken, e);\n            } else {\n                addlabel(e, 'exception');\n            }\n            advance();\n            advance(')');\n            block(false);\n            b = true;\n            scope = s;\n        }\n        if (nexttoken.id === 'finally') {\n            advance('finally');\n            block(false);\n            return;\n        } else if (!b) {\n            error(\"Expected '{a}' and instead saw '{b}'.\",\n                    nexttoken, 'catch', nexttoken.value);\n        }\n        return this;\n    });\n\n    blockstmt('while', function () {\n        var t = nexttoken;\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        advance('(');\n        nonadjacent(this, t);\n        nospace();\n        parse(20);\n        if (nexttoken.id === '=') {\n            warning(\"Expected a conditional expression and instead saw an assignment.\");\n            advance('=');\n            parse(20);\n        }\n        advance(')', t);\n        nospace(prevtoken, token);\n        block(true);\n        funct['(breakage)'] -= 1;\n        funct['(loopage)'] -= 1;\n        return this;\n    }).labelled = true;\n\n    reserve('with');\n\n    blockstmt('switch', function () {\n        var t = nexttoken,\n            g = false;\n        funct['(breakage)'] += 1;\n        advance('(');\n        nonadjacent(this, t);\n        nospace();\n        this.condition = parse(20);\n        advance(')', t);\n        nospace(prevtoken, token);\n        nonadjacent(token, nexttoken);\n        t = nexttoken;\n        advance('{');\n        nonadjacent(token, nexttoken);\n        indent += option.indent;\n        this.cases = [];\n        for (;;) {\n            switch (nexttoken.id) {\n            case 'case':\n                switch (funct['(verb)']) {\n                case 'break':\n                case 'case':\n                case 'continue':\n                case 'return':\n                case 'switch':\n                case 'throw':\n                    break;\n                default:\n                    warning(\n                        \"Expected a 'break' statement before 'case'.\",\n                        token);\n                }\n                indentation(-option.indent);\n                advance('case');\n                this.cases.push(parse(20));\n                g = true;\n                advance(':');\n                funct['(verb)'] = 'case';\n                break;\n            case 'default':\n                switch (funct['(verb)']) {\n                case 'break':\n                case 'continue':\n                case 'return':\n                case 'throw':\n                    break;\n                default:\n                    warning(\n                        \"Expected a 'break' statement before 'default'.\",\n                        token);\n                }\n                indentation(-option.indent);\n                advance('default');\n                g = true;\n                advance(':');\n                break;\n            case '}':\n                indent -= option.indent;\n                indentation();\n                advance('}', t);\n                if (this.cases.length === 1 || this.condition.id === 'true' ||\n                        this.condition.id === 'false') {\n                    warning(\"This 'switch' should be an 'if'.\", this);\n                }\n                funct['(breakage)'] -= 1;\n                funct['(verb)'] = undefined;\n                return;\n            case '(end)':\n                error(\"Missing '{a}'.\", nexttoken, '}');\n                return;\n            default:\n                if (g) {\n                    switch (token.id) {\n                    case ',':\n                        error(\"Each value should have its own case label.\");\n                        return;\n                    case ':':\n                        statements();\n                        break;\n                    default:\n                        error(\"Missing ':' on a case clause.\", token);\n                    }\n                } else {\n                    error(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, 'case', nexttoken.value);\n                }\n            }\n        }\n    }).labelled = true;\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            warning(\"All 'debugger' statements should be removed.\");\n        }\n        return this;\n    }).exps = true;\n\n    (function () {\n        var x = stmt('do', function () {\n            funct['(breakage)'] += 1;\n            funct['(loopage)'] += 1;\n            this.first = block(true);\n            advance('while');\n            var t = nexttoken;\n            nonadjacent(token, t);\n            advance('(');\n            nospace();\n            parse(20);\n            if (nexttoken.id === '=') {\n                warning(\"Expected a conditional expression and instead saw an assignment.\");\n                advance('=');\n                parse(20);\n            }\n            advance(')', t);\n            nospace(prevtoken, token);\n            funct['(breakage)'] -= 1;\n            funct['(loopage)'] -= 1;\n            return this;\n        });\n        x.labelled = true;\n        x.exps = true;\n    }());\n\n    blockstmt('for', function () {\n        var f = option.forin, s, t = nexttoken;\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        advance('(');\n        nonadjacent(this, t);\n        nospace();\n        if (peek(nexttoken.id === 'var' ? 1 : 0).id === 'in') {\n            if (nexttoken.id === 'var') {\n                advance('var');\n                varstatement(true);\n            } else {\n                switch (funct[nexttoken.value]) {\n                case 'unused':\n                    funct[nexttoken.value] = 'var';\n                    break;\n                case 'var':\n                    break;\n                default:\n                    warning(\"Bad for in variable '{a}'.\",\n                            nexttoken, nexttoken.value);\n                }\n                advance();\n            }\n            advance('in');\n            parse(20);\n            advance(')', t);\n            s = block(true);\n            if (!f && (s.length > 1 || typeof s[0] !== 'object' ||\n                    s[0].value !== 'if')) {\n                warning(\"The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.\", this);\n            }\n            funct['(breakage)'] -= 1;\n            funct['(loopage)'] -= 1;\n            return this;\n        } else {\n            if (nexttoken.id !== ';') {\n                if (nexttoken.id === 'var') {\n                    advance('var');\n                    varstatement();\n                } else {\n                    for (;;) {\n                        parse(0, 'for');\n                        if (nexttoken.id !== ',') {\n                            break;\n                        }\n                        comma();\n                    }\n                }\n            }\n            nolinebreak(token);\n            advance(';');\n            if (nexttoken.id !== ';') {\n                parse(20);\n                if (nexttoken.id === '=') {\n                    warning(\"Expected a conditional expression and instead saw an assignment.\");\n                    advance('=');\n                    parse(20);\n                }\n            }\n            nolinebreak(token);\n            advance(';');\n            if (nexttoken.id === ';') {\n                error(\"Expected '{a}' and instead saw '{b}'.\",\n                        nexttoken, ')', ';');\n            }\n            if (nexttoken.id !== ')') {\n                for (;;) {\n                    parse(0, 'for');\n                    if (nexttoken.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n            }\n            advance(')', t);\n            nospace(prevtoken, token);\n            block(true);\n            funct['(breakage)'] -= 1;\n            funct['(loopage)'] -= 1;\n            return this;\n        }\n    }).labelled = true;\n\n\n    stmt('break', function () {\n        var v = nexttoken.value;\n        if (funct['(breakage)'] === 0) {\n            warning(\"Unexpected '{a}'.\", nexttoken, this.value);\n        }\n        nolinebreak(this);\n        if (nexttoken.id !== ';') {\n            if (token.line === nexttoken.line) {\n                if (funct[v] !== 'label') {\n                    warning(\"'{a}' is not a statement label.\", nexttoken, v);\n                } else if (scope[v] !== funct) {\n                    warning(\"'{a}' is out of scope.\", nexttoken, v);\n                }\n                this.first = nexttoken;\n                advance();\n            }\n        }\n        reachable('break');\n        return this;\n    }).exps = true;\n\n\n    stmt('continue', function () {\n        var v = nexttoken.value;\n        if (funct['(breakage)'] === 0) {\n            warning(\"Unexpected '{a}'.\", nexttoken, this.value);\n        }\n        nolinebreak(this);\n        if (nexttoken.id !== ';') {\n            if (token.line === nexttoken.line) {\n                if (funct[v] !== 'label') {\n                    warning(\"'{a}' is not a statement label.\", nexttoken, v);\n                } else if (scope[v] !== funct) {\n                    warning(\"'{a}' is out of scope.\", nexttoken, v);\n                }\n                this.first = nexttoken;\n                advance();\n            }\n        } else if (!funct['(loopage)']) {\n            warning(\"Unexpected '{a}'.\", nexttoken, this.value);\n        }\n        reachable('continue');\n        return this;\n    }).exps = true;\n\n\n    stmt('return', function () {\n        nolinebreak(this);\n        if (nexttoken.id === '(regexp)') {\n            warning(\"Wrap the /regexp/ literal in parens to disambiguate the slash operator.\");\n        }\n        if (nexttoken.id !== ';' && !nexttoken.reach) {\n            nonadjacent(token, nexttoken);\n            this.first = parse(20);\n        }\n        reachable('return');\n        return this;\n    }).exps = true;\n\n\n    stmt('throw', function () {\n        nolinebreak(this);\n        nonadjacent(token, nexttoken);\n        this.first = parse(20);\n        reachable('throw');\n        return this;\n    }).exps = true;\n\n    reserve('void');\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n    reserve('let');\n    reserve('yield');\n    reserve('implements');\n    reserve('interface');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n\n\n// Parse JSON\n\n    function jsonValue() {\n\n        function jsonObject() {\n            var o = {}, t = nexttoken;\n            advance('{');\n            if (nexttoken.id !== '}') {\n                for (;;) {\n                    if (nexttoken.id === '(end)') {\n                        error(\"Missing '}' to match '{' from line {a}.\",\n                                nexttoken, t.line);\n                    } else if (nexttoken.id === '}') {\n                        warning(\"Unexpected comma.\", token);\n                        break;\n                    } else if (nexttoken.id === ',') {\n                        error(\"Unexpected comma.\", nexttoken);\n                    } else if (nexttoken.id !== '(string)') {\n                        warning(\"Expected a string and instead saw {a}.\",\n                                nexttoken, nexttoken.value);\n                    }\n                    if (o[nexttoken.value] === true) {\n                        warning(\"Duplicate key '{a}'.\",\n                                nexttoken, nexttoken.value);\n                    } else if (nexttoken.value === '__proto__') {\n                        warning(\"Stupid key '{a}'.\",\n                                nexttoken, nexttoken.value);\n                    } else {\n                        o[nexttoken.value] = true;\n                    }\n                    advance();\n                    advance(':');\n                    jsonValue();\n                    if (nexttoken.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                }\n            }\n            advance('}');\n        }\n\n        function jsonArray() {\n            var t = nexttoken;\n            advance('[');\n            if (nexttoken.id !== ']') {\n                for (;;) {\n                    if (nexttoken.id === '(end)') {\n                        error(\"Missing ']' to match '[' from line {a}.\",\n                                nexttoken, t.line);\n                    } else if (nexttoken.id === ']') {\n                        warning(\"Unexpected comma.\", token);\n                        break;\n                    } else if (nexttoken.id === ',') {\n                        error(\"Unexpected comma.\", nexttoken);\n                    }\n                    jsonValue();\n                    if (nexttoken.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                }\n            }\n            advance(']');\n        }\n\n        switch (nexttoken.id) {\n        case '{':\n            jsonObject();\n            break;\n        case '[':\n            jsonArray();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            if (token.character !== nexttoken.from) {\n                warning(\"Unexpected space after '-'.\", token);\n            }\n            adjacent(token, nexttoken);\n            advance('(number)');\n            break;\n        default:\n            error(\"Expected a JSON value.\", nexttoken);\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    var itself = function (s, o) {\n        var a, i;\n        JSLINT.errors = [];\n        predefined = Object.create(standard);\n        if (o) {\n            a = o.predef;\n            if (a instanceof Array) {\n                for (i = 0; i < a.length; i += 1) {\n                    predefined[a[i]] = true;\n                }\n            }\n            if (o.adsafe) {\n                o.safe = true;\n            }\n            if (o.safe) {\n                o.browser =\n                o.css     =\n                o.debug   =\n                o.devel   =\n                o.evil    =\n                o.forin   =\n                o.on      =\n                o.rhino   =\n                o.windows =\n                o.sub     =\n                o.widget  = false;\n\n                o.eqeqeq  =\n                o.nomen   =\n                o.safe    =\n                o.strict  =\n                o.undef   = true;\n\n                predefined.Date =\n                predefined['eval'] =\n                predefined.Function =\n                predefined.Object = null;\n\n                predefined.ADSAFE =\n                predefined.lib = false;\n            }\n            option = o;\n        } else {\n            option = {};\n        }\n        option.indent = option.indent || 4;\n        option.maxerr = option.maxerr || 50;\n        adsafe_id = '';\n        adsafe_may = false;\n        adsafe_went = false;\n        approved = {};\n        if (option.approved) {\n            for (i = 0; i < option.approved.length; i += 1) {\n                approved[option.approved[i]] = option.approved[i];\n            }\n        } else {\n            approved.test = 'test';\n        }\n        tab = '';\n        for (i = 0; i < option.indent; i += 1) {\n            tab += ' ';\n        }\n        indent = 1;\n        global = Object.create(predefined);\n        scope = global;\n        funct = {\n            '(global)': true,\n            '(name)': '(global)',\n            '(scope)': scope,\n            '(breakage)': 0,\n            '(loopage)': 0\n        };\n        functions = [funct];\n        ids = {};\n        urls = [];\n        src = false;\n        xmode = false;\n        stack = null;\n        member = {};\n        membersOnly = null;\n        implied = {};\n        inblock = false;\n        lookahead = [];\n        jsonmode = false;\n        warnings = 0;\n        lex.init(s);\n        prereg = true;\n        strict_mode = false;\n\n        prevtoken = token = nexttoken = syntax['(begin)'];\n        assume();\n\n        try {\n            advance();\n            if (nexttoken.value.charAt(0) === '<') {\n                html();\n                if (option.adsafe && !adsafe_went) {\n                    warning(\"ADsafe violation: Missing ADSAFE.go.\", this);\n                }\n            } else {\n                switch (nexttoken.id) {\n                case '{':\n                case '[':\n                    option.laxbreak = true;\n                    jsonmode = true;\n                    jsonValue();\n                    break;\n                case '@':\n                case '*':\n                case '#':\n                case '.':\n                case ':':\n                    xmode = 'style';\n                    advance();\n                    if (token.id !== '@' || !nexttoken.identifier ||\n                            nexttoken.value !== 'charset' || token.line !== 1 ||\n                            token.from !== 1) {\n                        error(\"A css file should begin with @charset 'UTF-8';\");\n                    }\n                    advance();\n                    if (nexttoken.type !== '(string)' &&\n                            nexttoken.value !== 'UTF-8') {\n                        error(\"A css file should begin with @charset 'UTF-8';\");\n                    }\n                    advance();\n                    advance(';');\n                    styles();\n                    break;\n\n                default:\n                    if (option.adsafe && option.fragment) {\n                        error(\"Expected '{a}' and instead saw '{b}'.\",\n                            nexttoken, '<div>', nexttoken.value);\n                    }\n                    statements('lib');\n                }\n            }\n            advance('(end)');\n        } catch (e) {\n            if (e) {\n                JSLINT.errors.push({\n                    reason    : e.message,\n                    line      : e.line || nexttoken.line,\n                    character : e.character || nexttoken.from\n                }, null);\n            }\n        }\n        return JSLINT.errors.length === 0;\n    };\n\n    function is_array(o) {\n        return Object.prototype.toString.apply(o) === '[object Array]';\n    }\n\n    function to_array(o) {\n        var a = [], k;\n        for (k in o) {\n            if (is_own(o, k)) {\n                a.push(k);\n            }\n        }\n        return a;\n    }\n\n\n// Data summary.\n\n    itself.data = function () {\n\n        var data = {functions: []}, fu, globals, implieds = [], f, i, j,\n            members = [], n, unused = [], v;\n        if (itself.errors.length) {\n            data.errors = itself.errors;\n        }\n\n        if (jsonmode) {\n            data.json = true;\n        }\n\n        for (n in implied) {\n            if (is_own(implied, n)) {\n                implieds.push({\n                    name: n,\n                    line: implied[n]\n                });\n            }\n        }\n        if (implieds.length > 0) {\n            data.implieds = implieds;\n        }\n\n        if (urls.length > 0) {\n            data.urls = urls;\n        }\n\n        globals = to_array(scope);\n        if (globals.length > 0) {\n            data.globals = globals;\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            f = functions[i];\n            fu = {};\n            for (j = 0; j < functionicity.length; j += 1) {\n                fu[functionicity[j]] = [];\n            }\n            for (n in f) {\n                if (is_own(f, n) && n.charAt(0) !== '(') {\n                    v = f[n];\n                    if (v === 'unction') {\n                        v = 'unused';\n                    }\n                    if (is_array(fu[v])) {\n                        fu[v].push(n);\n                        if (v === 'unused') {\n                            unused.push({\n                                name: n,\n                                line: f['(line)'],\n                                'function': f['(name)']\n                            });\n                        }\n                    }\n                }\n            }\n            for (j = 0; j < functionicity.length; j += 1) {\n                if (fu[functionicity[j]].length === 0) {\n                    delete fu[functionicity[j]];\n                }\n            }\n            fu.name = f['(name)'];\n            fu.param = f['(params)'];\n            fu.line = f['(line)'];\n            fu.last = f['(last)'];\n            data.functions.push(fu);\n        }\n\n        if (unused.length > 0) {\n            data.unused = unused;\n        }\n\n        members = [];\n        for (n in member) {\n            if (typeof member[n] === 'number') {\n                data.member = member;\n                break;\n            }\n        }\n\n        return data;\n    };\n\n    itself.report = function (option) {\n        var data = itself.data();\n\n        var a = [], c, e, err, f, i, k, l, m = '', n, o = [], s;\n\n        function detail(h, array) {\n            var b, i, singularity;\n            if (array) {\n                o.push('<div><i>' + h + '</i> ');\n                array = array.sort();\n                for (i = 0; i < array.length; i += 1) {\n                    if (array[i] !== singularity) {\n                        singularity = array[i];\n                        o.push((b ? ', ' : '') + singularity);\n                        b = true;\n                    }\n                }\n                o.push('</div>');\n            }\n        }\n\n\n        if (data.errors || data.implieds || data.unused) {\n            err = true;\n            o.push('<div id=errors><i>Error:</i>');\n            if (data.errors) {\n                for (i = 0; i < data.errors.length; i += 1) {\n                    c = data.errors[i];\n                    if (c) {\n                        e = c.evidence || '';\n                        o.push('<p>Problem' + (isFinite(c.line) ? ' at line ' +\n                                c.line + ' character ' + c.character : '') +\n                                ': ' + c.reason.entityify() +\n                                '</p><p class=evidence>' +\n                                (e && (e.length > 80 ? e.slice(0, 77) + '...' :\n                                e).entityify()) + '</p>');\n                    }\n                }\n            }\n\n            if (data.implieds) {\n                s = [];\n                for (i = 0; i < data.implieds.length; i += 1) {\n                    s[i] = '<code>' + data.implieds[i].name + '</code>&nbsp;<i>' +\n                        data.implieds[i].line + '</i>';\n                }\n                o.push('<p><i>Implied global:</i> ' + s.join(', ') + '</p>');\n            }\n\n            if (data.unused) {\n                s = [];\n                for (i = 0; i < data.unused.length; i += 1) {\n                    s[i] = '<code><u>' + data.unused[i].name + '</u></code>&nbsp;<i>' +\n                        data.unused[i].line + '</i> <code>' +\n                        data.unused[i]['function'] + '</code>';\n                }\n                o.push('<p><i>Unused variable:</i> ' + s.join(', ') + '</p>');\n            }\n            if (data.json) {\n                o.push('<p>JSON: bad.</p>');\n            }\n            o.push('</div>');\n        }\n\n        if (!option) {\n\n            o.push('<br><div id=functions>');\n\n            if (data.urls) {\n                detail(\"URLs<br>\", data.urls, '<br>');\n            }\n\n            if (xmode === 'style') {\n                o.push('<p>CSS.</p>');\n            } else if (data.json && !err) {\n                o.push('<p>JSON: good.</p>');\n            } else if (data.globals) {\n                o.push('<div><i>Global</i> ' +\n                        data.globals.sort().join(', ') + '</div>');\n            } else {\n                o.push('<div><i>No new global variables introduced.</i></div>');\n            }\n\n            for (i = 0; i < data.functions.length; i += 1) {\n                f = data.functions[i];\n\n                o.push('<br><div class=function><i>' + f.line + '-' +\n                        f.last + '</i> ' + (f.name || '') + '(' +\n                        (f.param ? f.param.join(', ') : '') + ')</div>');\n                detail('<big><b>Unused</b></big>', f.unused);\n                detail('Closure', f.closure);\n                detail('Variable', f['var']);\n                detail('Exception', f.exception);\n                detail('Outer', f.outer);\n                detail('Global', f.global);\n                detail('Label', f.label);\n            }\n\n            if (data.member) {\n                a = to_array(data.member);\n                if (a.length) {\n                    a = a.sort();\n                    m = '<br><pre id=members>/*members ';\n                    l = 10;\n                    for (i = 0; i < a.length; i += 1) {\n                        k = a[i];\n                        n = k.name();\n                        if (l + n.length > 72) {\n                            o.push(m + '<br>');\n                            m = '    ';\n                            l = 1;\n                        }\n                        l += n.length + 2;\n                        if (data.member[k] === 1) {\n                            n = '<i>' + n + '</i>';\n                        }\n                        if (i < a.length - 1) {\n                            n += ', ';\n                        }\n                        m += n;\n                    }\n                    o.push(m + '<br>*/</pre>');\n                }\n                o.push('</div>');\n            }\n        }\n        return o.join('');\n    };\n    itself.jslint = itself;\n\n    itself.edition = '2010-11-18';\n\n    return itself;\n\n}());\n","pre":true},"util/parseJS.js":{"path":"util/parseJS.js","friendlyPath":"jsio.util.parseJS","directory":"util/","filename":"parseJS.js","src":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n\n  This version is suitable for Node.js.  With minimal changes (the\n  exports stuff) it should work on any JS platform.\n\n  This file contains the tokenizer/parser.  It is a port to JavaScript\n  of parse-js [1], a JavaScript parser library written in Common Lisp\n  by Marijn Haverbeke.  Thank you Marijn!\n\n  [1] http://marijn.haverbeke.nl/parse-js/\n\n  Exported functions:\n\n    - tokenizer(code) -- returns a function.  Call the returned\n      function to fetch the next token.\n\n    - parse(code) -- returns an AST of the given JavaScript code.\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>\n    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n/* -----[ Tokenizer (constants) ]----- */\n\nvar KEYWORDS = array_to_hash([\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"const\",\n        \"continue\",\n        \"debugger\",\n        \"default\",\n        \"delete\",\n        \"do\",\n        \"else\",\n        \"finally\",\n        \"for\",\n        \"function\",\n        \"if\",\n        \"import\",\n        \"in\",\n        \"as\",\n        \"instanceof\",\n        \"new\",\n        \"return\",\n        \"switch\",\n        \"throw\",\n        \"try\",\n        \"typeof\",\n        \"var\",\n        \"void\",\n        \"while\",\n        \"with\"\n]);\n\nvar RESERVED_WORDS = array_to_hash([\n        \"abstract\",\n        \"boolean\",\n        \"byte\",\n        \"char\",\n        \"class\",\n        \"double\",\n        \"enum\",\n        \"export\",\n        \"extends\",\n        \"final\",\n        \"float\",\n        \"goto\",\n        \"implements\",\n        \"int\",\n        \"interface\",\n        \"long\",\n        \"native\",\n        \"package\",\n        \"private\",\n        \"protected\",\n        \"public\",\n        \"short\",\n        \"static\",\n        \"super\",\n        \"synchronized\",\n        \"throws\",\n        \"transient\",\n        \"volatile\"\n]);\n\nvar KEYWORDS_BEFORE_EXPRESSION = array_to_hash([\n        \"return\",\n        \"new\",\n        \"delete\",\n        \"throw\",\n        \"else\",\n        \"case\"\n]);\n\nvar KEYWORDS_ATOM = array_to_hash([\n        \"false\",\n        \"null\",\n        \"true\",\n        \"undefined\"\n]);\n\nvar OPERATOR_CHARS = array_to_hash(characters(\"+-*&%=<>!?|~^\"));\n\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\nvar RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n\nvar OPERATORS = array_to_hash([\n        \"in\",\n        \"as\",\n        \"instanceof\",\n        \"typeof\",\n        \"new\",\n        \"void\",\n        \"delete\",\n        \"++\",\n        \"--\",\n        \"+\",\n        \"-\",\n        \"!\",\n        \"~\",\n        \"&\",\n        \"|\",\n        \"^\",\n        \"*\",\n        \"/\",\n        \"%\",\n        \">>\",\n        \"<<\",\n        \">>>\",\n        \"<\",\n        \">\",\n        \"<=\",\n        \">=\",\n        \"==\",\n        \"===\",\n        \"!=\",\n        \"!==\",\n        \"?\",\n        \"=\",\n        \"+=\",\n        \"-=\",\n        \"/=\",\n        \"*=\",\n        \"%=\",\n        \">>=\",\n        \"<<=\",\n        \">>>=\",\n        \"|=\",\n        \"^=\",\n        \"&=\",\n        \"&&\",\n        \"||\"\n]);\n\nvar WHITESPACE_CHARS = array_to_hash(characters(\" \\u00a0\\n\\r\\t\\f\\u000b\\u200b\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\"));\n\nvar PUNC_BEFORE_EXPRESSION = array_to_hash(characters(\"[{(,.;:\"));\n\nvar PUNC_CHARS = array_to_hash(characters(\"[]{}(),;:\"));\n\nvar REGEXP_MODIFIERS = array_to_hash(characters(\"gmsiy\"));\n\n/* -----[ Tokenizer ]----- */\n\nvar UNICODE = {  // Unicode 6.1\n        letter: new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0620-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0800-\\\\u0815\\\\u081A\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08A0\\\\u08A2-\\\\u08AC\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0CF1\\\\u0CF2\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D\\\\u0D4E\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8C\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u10D0-\\\\u10FA\\\\u10FC-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16EE-\\\\u16F0\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1A20-\\\\u1A54\\\\u1AA7\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1BBA-\\\\u1BE5\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1CE9-\\\\u1CEC\\\\u1CEE-\\\\u1CF1\\\\u1CF5\\\\u1CF6\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2160-\\\\u2188\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2CE4\\\\u2CEB-\\\\u2CEE\\\\u2CF2\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\u2D30-\\\\u2D67\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FCC\\\\uA000-\\\\uA48C\\\\uA4D0-\\\\uA4FD\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA6A0-\\\\uA6EF\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA78E\\\\uA790-\\\\uA793\\\\uA7A0-\\\\uA7AA\\\\uA7F8-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA8F2-\\\\uA8F7\\\\uA8FB\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uA960-\\\\uA97C\\\\uA984-\\\\uA9B2\\\\uA9CF\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAA60-\\\\uAA76\\\\uAA7A\\\\uAA80-\\\\uAAAF\\\\uAAB1\\\\uAAB5\\\\uAAB6\\\\uAAB9-\\\\uAABD\\\\uAAC0\\\\uAAC2\\\\uAADB-\\\\uAADD\\\\uAAE0-\\\\uAAEA\\\\uAAF2-\\\\uAAF4\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uABC0-\\\\uABE2\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),\n        combining_mark: new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065F\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0859-\\\\u085B\\\\u08E4-\\\\u08FE\\\\u0900-\\\\u0903\\\\u093A-\\\\u093C\\\\u093E-\\\\u094F\\\\u0951-\\\\u0957\\\\u0962\\\\u0963\\\\u0981-\\\\u0983\\\\u09BC\\\\u09BE-\\\\u09C4\\\\u09C7\\\\u09C8\\\\u09CB-\\\\u09CD\\\\u09D7\\\\u09E2\\\\u09E3\\\\u0A01-\\\\u0A03\\\\u0A3C\\\\u0A3E-\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81-\\\\u0A83\\\\u0ABC\\\\u0ABE-\\\\u0AC5\\\\u0AC7-\\\\u0AC9\\\\u0ACB-\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01-\\\\u0B03\\\\u0B3C\\\\u0B3E-\\\\u0B44\\\\u0B47\\\\u0B48\\\\u0B4B-\\\\u0B4D\\\\u0B56\\\\u0B57\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BBE-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCD\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C3E-\\\\u0C44\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0C82\\\\u0C83\\\\u0CBC\\\\u0CBE-\\\\u0CC4\\\\u0CC6-\\\\u0CC8\\\\u0CCA-\\\\u0CCD\\\\u0CD5\\\\u0CD6\\\\u0CE2\\\\u0CE3\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D44\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4D\\\\u0D57\\\\u0D62\\\\u0D63\\\\u0D82\\\\u0D83\\\\u0DCA\\\\u0DCF-\\\\u0DD4\\\\u0DD6\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F3E\\\\u0F3F\\\\u0F71-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F8D-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102B-\\\\u103E\\\\u1056-\\\\u1059\\\\u105E-\\\\u1060\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1071-\\\\u1074\\\\u1082-\\\\u108D\\\\u108F\\\\u109A-\\\\u109D\\\\u135D-\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B4-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u192B\\\\u1930-\\\\u193B\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A17-\\\\u1A1B\\\\u1A55-\\\\u1A5E\\\\u1A60-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B04\\\\u1B34-\\\\u1B44\\\\u1B6B-\\\\u1B73\\\\u1B80-\\\\u1B82\\\\u1BA1-\\\\u1BAD\\\\u1BE6-\\\\u1BF3\\\\u1C24-\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE8\\\\u1CED\\\\u1CF2-\\\\u1CF4\\\\u1DC0-\\\\u1DE6\\\\u1DFC-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2D7F\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA674-\\\\uA67D\\\\uA69F\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA823-\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA953\\\\uA980-\\\\uA983\\\\uA9B3-\\\\uA9C0\\\\uAA29-\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAA4D\\\\uAA7B\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uAAEB-\\\\uAAEF\\\\uAAF5\\\\uAAF6\\\\uABE3-\\\\uABEA\\\\uABEC\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),\n        connector_punctuation: new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\"),\n        digit: new RegExp(\"[\\\\u0030-\\\\u0039\\\\u0660-\\\\u0669\\\\u06F0-\\\\u06F9\\\\u07C0-\\\\u07C9\\\\u0966-\\\\u096F\\\\u09E6-\\\\u09EF\\\\u0A66-\\\\u0A6F\\\\u0AE6-\\\\u0AEF\\\\u0B66-\\\\u0B6F\\\\u0BE6-\\\\u0BEF\\\\u0C66-\\\\u0C6F\\\\u0CE6-\\\\u0CEF\\\\u0D66-\\\\u0D6F\\\\u0E50-\\\\u0E59\\\\u0ED0-\\\\u0ED9\\\\u0F20-\\\\u0F29\\\\u1040-\\\\u1049\\\\u1090-\\\\u1099\\\\u17E0-\\\\u17E9\\\\u1810-\\\\u1819\\\\u1946-\\\\u194F\\\\u19D0-\\\\u19D9\\\\u1A80-\\\\u1A89\\\\u1A90-\\\\u1A99\\\\u1B50-\\\\u1B59\\\\u1BB0-\\\\u1BB9\\\\u1C40-\\\\u1C49\\\\u1C50-\\\\u1C59\\\\uA620-\\\\uA629\\\\uA8D0-\\\\uA8D9\\\\uA900-\\\\uA909\\\\uA9D0-\\\\uA9D9\\\\uAA50-\\\\uAA59\\\\uABF0-\\\\uABF9\\\\uFF10-\\\\uFF19]\")\n};\n\nfunction is_letter(ch) {\n        return UNICODE.letter.test(ch);\n};\n\nfunction is_digit(ch) {\n        ch = ch.charCodeAt(0);\n        return ch >= 48 && ch <= 57;\n};\n\nfunction is_unicode_digit(ch) {\n        return UNICODE.digit.test(ch);\n}\n\nfunction is_alphanumeric_char(ch) {\n        return is_digit(ch) || is_letter(ch);\n};\n\nfunction is_unicode_combining_mark(ch) {\n        return UNICODE.combining_mark.test(ch);\n};\n\nfunction is_unicode_connector_punctuation(ch) {\n        return UNICODE.connector_punctuation.test(ch);\n};\n\nfunction is_identifier_start(ch) {\n        return ch == \"$\" || ch == \"_\" || is_letter(ch);\n};\n\nfunction is_identifier_char(ch) {\n        return is_identifier_start(ch)\n                || is_unicode_combining_mark(ch)\n                || is_unicode_digit(ch)\n                || is_unicode_connector_punctuation(ch)\n                || ch == \"\\u200c\" // zero-width non-joiner <ZWNJ>\n                || ch == \"\\u200d\" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)\n        ;\n};\n\nfunction parse_js_number(num) {\n        if (RE_HEX_NUMBER.test(num)) {\n                return parseInt(num.substr(2), 16);\n        } else if (RE_OCT_NUMBER.test(num)) {\n                return parseInt(num.substr(1), 8);\n        } else if (RE_DEC_NUMBER.test(num)) {\n                return parseFloat(num);\n        }\n};\n\nfunction JS_Parse_Error(message, line, col, pos) {\n        this.message = message;\n        this.line = line + 1;\n        this.col = col + 1;\n        this.pos = pos + 1;\n        this.stack = new Error().stack;\n};\n\nJS_Parse_Error.prototype.toString = function() {\n        return this.message + \" (line: \" + this.line + \", col: \" + this.col + \", pos: \" + this.pos + \")\" + \"\\n\\n\" + this.stack;\n};\n\nfunction js_error(message, line, col, pos) {\n        throw new JS_Parse_Error(message, line, col, pos);\n};\n\nfunction is_token(token, type, val) {\n        return token.type == type && (val == null || token.value == val);\n};\n\nvar EX_EOF = {};\n\nfunction tokenizer($TEXT) {\n\n        var S = {\n                text            : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\n                pos             : 0,\n                tokpos          : 0,\n                line            : 0,\n                tokline         : 0,\n                col             : 0,\n                tokcol          : 0,\n                newline_before  : false,\n                regex_allowed   : false,\n                comments_before : []\n        };\n\n        function peek() { return S.text.charAt(S.pos); };\n\n        function next(signal_eof, in_string) {\n                var ch = S.text.charAt(S.pos++);\n                if (signal_eof && !ch)\n                        throw EX_EOF;\n                if (ch == \"\\n\") {\n                        S.newline_before = S.newline_before || !in_string;\n                        ++S.line;\n                        S.col = 0;\n                } else {\n                        ++S.col;\n                }\n                return ch;\n        };\n\n        function eof() {\n                return !S.peek();\n        };\n\n        function find(what, signal_eof) {\n                var pos = S.text.indexOf(what, S.pos);\n                if (signal_eof && pos == -1) throw EX_EOF;\n                return pos;\n        };\n\n        function start_token() {\n                S.tokline = S.line;\n                S.tokcol = S.col;\n                S.tokpos = S.pos;\n        };\n\n        function token(type, value, is_comment) {\n                S.regex_allowed = ((type == \"operator\" && !HOP(UNARY_POSTFIX, value)) ||\n                                   (type == \"keyword\" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||\n                                   (type == \"punc\" && HOP(PUNC_BEFORE_EXPRESSION, value)));\n                var ret = {\n                        type   : type,\n                        value  : value,\n                        line   : S.tokline,\n                        col    : S.tokcol,\n                        pos    : S.tokpos,\n                        endpos : S.pos,\n                        nlb    : S.newline_before\n                };\n                if (!is_comment) {\n                        ret.comments_before = S.comments_before;\n                        S.comments_before = [];\n                        // make note of any newlines in the comments that came before\n                        for (var i = 0, len = ret.comments_before.length; i < len; i++) {\n                                ret.nlb = ret.nlb || ret.comments_before[i].nlb;\n                        }\n                }\n                S.newline_before = false;\n                return ret;\n        };\n\n        function skip_whitespace() {\n                while (HOP(WHITESPACE_CHARS, peek()))\n                        next();\n        };\n\n        function read_while(pred) {\n                var ret = \"\", ch = peek(), i = 0;\n                while (ch && pred(ch, i++)) {\n                        ret += next();\n                        ch = peek();\n                }\n                return ret;\n        };\n\n        function parse_error(err) {\n                js_error(err, S.tokline, S.tokcol, S.tokpos);\n        };\n\n        function read_num(prefix) {\n                var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n                var num = read_while(function(ch, i){\n                        if (ch == \"x\" || ch == \"X\") {\n                                if (has_x) return false;\n                                return has_x = true;\n                        }\n                        if (!has_x && (ch == \"E\" || ch == \"e\")) {\n                                if (has_e) return false;\n                                return has_e = after_e = true;\n                        }\n                        if (ch == \"-\") {\n                                if (after_e || (i == 0 && !prefix)) return true;\n                                return false;\n                        }\n                        if (ch == \"+\") return after_e;\n                        after_e = false;\n                        if (ch == \".\") {\n                                if (!has_dot && !has_x && !has_e)\n                                        return has_dot = true;\n                                return false;\n                        }\n                        return is_alphanumeric_char(ch);\n                });\n                if (prefix)\n                        num = prefix + num;\n                var valid = parse_js_number(num);\n                if (!isNaN(valid)) {\n                        return token(\"num\", valid);\n                } else {\n                        parse_error(\"Invalid syntax: \" + num);\n                }\n        };\n\n        function read_escaped_char(in_string) {\n                var ch = next(true, in_string);\n                switch (ch) {\n                    case \"n\" : return \"\\n\";\n                    case \"r\" : return \"\\r\";\n                    case \"t\" : return \"\\t\";\n                    case \"b\" : return \"\\b\";\n                    case \"v\" : return \"\\u000b\";\n                    case \"f\" : return \"\\f\";\n                    case \"0\" : return \"\\0\";\n                    case \"x\" : return String.fromCharCode(hex_bytes(2));\n                    case \"u\" : return String.fromCharCode(hex_bytes(4));\n                    case \"\\n\": return \"\";\n                    default  : return ch;\n                }\n        };\n\n        function hex_bytes(n) {\n                var num = 0;\n                for (; n > 0; --n) {\n                        var digit = parseInt(next(true), 16);\n                        if (isNaN(digit))\n                                parse_error(\"Invalid hex-character pattern in string\");\n                        num = (num << 4) | digit;\n                }\n                return num;\n        };\n\n        function read_string() {\n                return with_eof_error(\"Unterminated string constant\", function(){\n                        var quote = next(), ret = \"\";\n                        for (;;) {\n                                var ch = next(true);\n                                if (ch == \"\\\\\") {\n                                        // read OctalEscapeSequence (XXX: deprecated if \"strict mode\")\n                                        // https://github.com/mishoo/UglifyJS/issues/178\n                                        var octal_len = 0, first = null;\n                                        ch = read_while(function(ch){\n                                                if (ch >= \"0\" && ch <= \"7\") {\n                                                        if (!first) {\n                                                                first = ch;\n                                                                return ++octal_len;\n                                                        }\n                                                        else if (first <= \"3\" && octal_len <= 2) return ++octal_len;\n                                                        else if (first >= \"4\" && octal_len <= 1) return ++octal_len;\n                                                }\n                                                return false;\n                                        });\n                                        if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));\n                                        else ch = read_escaped_char(true);\n                                }\n                                else if (ch == quote) break;\n                                ret += ch;\n                        }\n                        return token(\"string\", ret);\n                });\n        };\n\n        function read_line_comment() {\n                next();\n                var i = find(\"\\n\"), ret;\n                if (i == -1) {\n                        ret = S.text.substr(S.pos);\n                        S.pos = S.text.length;\n                } else {\n                        ret = S.text.substring(S.pos, i);\n                        S.pos = i;\n                }\n                return token(\"comment1\", ret, true);\n        };\n\n        function read_multiline_comment() {\n                next();\n                return with_eof_error(\"Unterminated multiline comment\", function(){\n                        var i = find(\"*/\", true),\n                            text = S.text.substring(S.pos, i);\n                        S.pos = i + 2;\n                        S.line += text.split(\"\\n\").length - 1;\n                        S.newline_before = S.newline_before || text.indexOf(\"\\n\") >= 0;\n\n                        // https://github.com/mishoo/UglifyJS/issues/#issue/100\n                        if (/^@cc_on/i.test(text)) {\n                                warn(\"WARNING: at line \" + S.line);\n                                warn(\"*** Found \\\"conditional comment\\\": \" + text);\n                                warn(\"*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.\");\n                        }\n\n                        return token(\"comment2\", text, true);\n                });\n        };\n\n        function read_name() {\n                var backslash = false, name = \"\", ch, escaped = false, hex;\n                while ((ch = peek()) != null) {\n                        if (!backslash) {\n                                if (ch == \"\\\\\") escaped = backslash = true, next();\n                                else if (is_identifier_char(ch)) name += next();\n                                else break;\n                        }\n                        else {\n                                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                                ch = read_escaped_char();\n                                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                                name += ch;\n                                backslash = false;\n                        }\n                }\n                if (HOP(KEYWORDS, name) && escaped) {\n                        hex = name.charCodeAt(0).toString(16).toUpperCase();\n                        name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\n                }\n                return name;\n        };\n\n        function read_regexp(regexp) {\n                return with_eof_error(\"Unterminated regular expression\", function(){\n                        var prev_backslash = false, ch, in_class = false;\n                        while ((ch = next(true))) if (prev_backslash) {\n                                regexp += \"\\\\\" + ch;\n                                prev_backslash = false;\n                        } else if (ch == \"[\") {\n                                in_class = true;\n                                regexp += ch;\n                        } else if (ch == \"]\" && in_class) {\n                                in_class = false;\n                                regexp += ch;\n                        } else if (ch == \"/\" && !in_class) {\n                                break;\n                        } else if (ch == \"\\\\\") {\n                                prev_backslash = true;\n                        } else {\n                                regexp += ch;\n                        }\n                        var mods = read_name();\n                        return token(\"regexp\", [ regexp, mods ]);\n                });\n        };\n\n        function read_operator(prefix) {\n                function grow(op) {\n                        if (!peek()) return op;\n                        var bigger = op + peek();\n                        if (HOP(OPERATORS, bigger)) {\n                                next();\n                                return grow(bigger);\n                        } else {\n                                return op;\n                        }\n                };\n                return token(\"operator\", grow(prefix || next()));\n        };\n\n        function handle_slash() {\n                next();\n                var regex_allowed = S.regex_allowed;\n                switch (peek()) {\n                    case \"/\":\n                        S.comments_before.push(read_line_comment());\n                        S.regex_allowed = regex_allowed;\n                        return next_token();\n                    case \"*\":\n                        S.comments_before.push(read_multiline_comment());\n                        S.regex_allowed = regex_allowed;\n                        return next_token();\n                }\n                return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n        };\n\n        function handle_dot() {\n                next();\n                return is_digit(peek())\n                        ? read_num(\".\")\n                        : token(\"punc\", \".\");\n        };\n\n        function read_word() {\n                var word = read_name();\n                return !HOP(KEYWORDS, word)\n                        ? token(\"name\", word)\n                        : HOP(OPERATORS, word)\n                        ? token(\"operator\", word)\n                        : HOP(KEYWORDS_ATOM, word)\n                        ? token(\"atom\", word)\n                        : token(\"keyword\", word);\n        };\n\n        function with_eof_error(eof_error, cont) {\n                try {\n                        return cont();\n                } catch(ex) {\n                        if (ex === EX_EOF) parse_error(eof_error);\n                        else throw ex;\n                }\n        };\n\n        function next_token(force_regexp) {\n                if (force_regexp != null)\n                        return read_regexp(force_regexp);\n                skip_whitespace();\n                start_token();\n                var ch = peek();\n                if (!ch) return token(\"eof\");\n                if (is_digit(ch)) return read_num();\n                if (ch == '\"' || ch == \"'\") return read_string();\n                if (HOP(PUNC_CHARS, ch)) return token(\"punc\", next());\n                if (ch == \".\") return handle_dot();\n                if (ch == \"/\") return handle_slash();\n                if (HOP(OPERATOR_CHARS, ch)) return read_operator();\n                if (ch == \"\\\\\" || is_identifier_start(ch)) return read_word();\n                parse_error(\"Unexpected character '\" + ch + \"'\");\n        };\n\n        next_token.context = function(nc) {\n                if (nc) S = nc;\n                return S;\n        };\n\n        return next_token;\n\n};\n\n/* -----[ Parser (constants) ]----- */\n\nvar UNARY_PREFIX = array_to_hash([\n        \"typeof\",\n        \"void\",\n        \"delete\",\n        \"--\",\n        \"++\",\n        \"!\",\n        \"~\",\n        \"-\",\n        \"+\"\n]);\n\nvar UNARY_POSTFIX = array_to_hash([ \"--\", \"++\" ]);\n\nvar ASSIGNMENT = (function(a, ret, i){\n        while (i < a.length) {\n                ret[a[i]] = a[i].substr(0, a[i].length - 1);\n                i++;\n        }\n        return ret;\n})(\n        [\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\"],\n        { \"=\": true },\n        0\n);\n\nvar PRECEDENCE = (function(a, ret){\n        for (var i = 0, n = 1; i < a.length; ++i, ++n) {\n                var b = a[i];\n                for (var j = 0; j < b.length; ++j) {\n                        ret[b[j]] = n;\n                }\n        }\n        return ret;\n})(\n        [\n                [\"||\"],\n                [\"&&\"],\n                [\"|\"],\n                [\"^\"],\n                [\"&\"],\n                [\"==\", \"===\", \"!=\", \"!==\"],\n                [\"<\", \">\", \"<=\", \">=\", \"in\", \"as\", \"instanceof\"],\n                [\">>\", \"<<\", \">>>\"],\n                [\"+\", \"-\"],\n                [\"*\", \"/\", \"%\"]\n        ],\n        {}\n);\n\nvar STATEMENTS_WITH_LABELS = array_to_hash([ \"for\", \"do\", \"while\", \"switch\" ]);\n\nvar ATOMIC_START_TOKEN = array_to_hash([ \"atom\", \"num\", \"string\", \"regexp\", \"name\" ]);\n\n/* -----[ Parser ]----- */\n\nfunction NodeWithToken(str, start, end) {\n        this.name = str;\n        this.start = start;\n        this.end = end;\n};\n\nNodeWithToken.prototype.toString = function() { return this.name; };\n\nfunction parse($TEXT, exigent_mode, embed_tokens) {\n\n        var S = {\n                input         : typeof $TEXT == \"string\" ? tokenizer($TEXT, true) : $TEXT,\n                token         : null,\n                prev          : null,\n                peeked        : null,\n                in_function   : 0,\n                in_directives : true,\n                in_loop       : 0,\n                labels        : []\n        };\n\n        S.token = next();\n\n        function is(type, value) {\n                return is_token(S.token, type, value);\n        };\n\n        function peek() { return S.peeked || (S.peeked = S.input()); };\n\n        function next() {\n                S.prev = S.token;\n                if (S.peeked) {\n                        S.token = S.peeked;\n                        S.peeked = null;\n                } else {\n                        S.token = S.input();\n                }\n                S.in_directives = S.in_directives && (\n                        S.token.type == \"string\" || is(\"punc\", \";\")\n                );\n                return S.token;\n        };\n\n        function prev() {\n                return S.prev;\n        };\n\n        function croak(msg, line, col, pos) {\n                var ctx = S.input.context();\n                js_error(msg,\n                         line != null ? line : ctx.tokline,\n                         col != null ? col : ctx.tokcol,\n                         pos != null ? pos : ctx.tokpos);\n        };\n\n        function token_error(token, msg) {\n                croak(msg, token.line, token.col);\n        };\n\n        function unexpected(token) {\n                if (token == null)\n                        token = S.token;\n                token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\n        };\n\n        function expect_token(type, val) {\n                if (is(type, val)) {\n                        return next();\n                }\n                token_error(S.token, \"Unexpected token \" + S.token.type + \", expected \" + type);\n        };\n\n        function expect(punc) { return expect_token(\"punc\", punc); };\n\n        function can_insert_semicolon() {\n                return !exigent_mode && (\n                        S.token.nlb || is(\"eof\") || is(\"punc\", \"}\")\n                );\n        };\n\n        function semicolon() {\n                if (is(\"punc\", \";\")) next();\n                else if (!can_insert_semicolon()) unexpected();\n        };\n\n        function as() {\n                var args = slice(arguments);\n                args.line = (S.prev ? S.prev.line : 0) + 1;\n                return args;\n        };\n\n        function parenthesised() {\n                expect(\"(\");\n                var ex = expression();\n                expect(\")\");\n                return ex;\n        };\n\n        function add_tokens(str, start, end) {\n                return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);\n        };\n\n        function maybe_embed_tokens(parser) {\n                if (embed_tokens) return function() {\n                        var start = S.token;\n                        var ast = parser.apply(this, arguments);\n                        ast[0] = add_tokens(ast[0], start, prev());\n                        return ast;\n                };\n                else return parser;\n        };\n\n        var statement = maybe_embed_tokens(function() {\n                if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n                        S.peeked = null;\n                        S.token = S.input(S.token.value.substr(1)); // force regexp\n                }\n                switch (S.token.type) {\n                    case \"string\":\n                        var dir = S.in_directives, stat = simple_statement();\n                        if (dir && stat[1][0] == \"string\" && !is(\"punc\", \",\"))\n                            return as(\"directive\", stat[1][1]);\n                        return stat;\n                    case \"num\":\n                    case \"regexp\":\n                    case \"operator\":\n                    case \"atom\":\n                        return simple_statement();\n\n                    case \"name\":\n                        return is_token(peek(), \"punc\", \":\")\n                                ? labeled_statement(prog1(S.token.value, next, next))\n                                : simple_statement();\n\n                    case \"punc\":\n                        switch (S.token.value) {\n                            case \"{\":\n                                return as(\"block\", block_());\n                            case \"[\":\n                            case \"(\":\n                                return simple_statement();\n                            case \";\":\n                                next();\n                                return as(\"block\");\n                            default:\n                                unexpected();\n                        }\n\n                    case \"keyword\":\n                        switch (prog1(S.token.value, next)) {\n                            case \"break\":\n                                return break_cont(\"break\");\n\n                            case \"continue\":\n                                return break_cont(\"continue\");\n\n                            case \"debugger\":\n                                semicolon();\n                                return as(\"debugger\");\n\n                            case \"do\":\n                                return (function(body){\n                                        expect_token(\"keyword\", \"while\");\n                                        return as(\"do\", prog1(parenthesised, semicolon), body);\n                                })(in_loop(statement));\n\n                            case \"import\":\n                                return import_();\n\n                            case \"for\":\n                                return for_();\n\n                            case \"function\":\n                                return function_(true);\n\n                            case \"if\":\n                                return if_();\n\n                            case \"return\":\n                                if (S.in_function == 0)\n                                        croak(\"'return' outside of function\");\n                                return as(\"return\",\n                                          is(\"punc\", \";\")\n                                          ? (next(), null)\n                                          : can_insert_semicolon()\n                                          ? null\n                                          : prog1(expression, semicolon));\n\n                            case \"switch\":\n                                return as(\"switch\", parenthesised(), switch_block_());\n\n                            case \"throw\":\n                                if (S.token.nlb)\n                                        croak(\"Illegal newline after 'throw'\");\n                                return as(\"throw\", prog1(expression, semicolon));\n\n                            case \"try\":\n                                return try_();\n\n                            case \"var\":\n                                return prog1(var_, semicolon);\n\n                            case \"const\":\n                                return prog1(const_, semicolon);\n\n                            case \"while\":\n                                return as(\"while\", parenthesised(), in_loop(statement));\n\n                            case \"with\":\n                                return as(\"with\", parenthesised(), statement());\n\n                            default:\n                                unexpected();\n                        }\n                }\n        });\n\n        function labeled_statement(label) {\n                S.labels.push(label);\n                var start = S.token, stat = statement();\n                if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))\n                        unexpected(start);\n                S.labels.pop();\n                return as(\"label\", label, stat);\n        };\n\n        function simple_statement() {\n                return as(\"stat\", prog1(expression, semicolon));\n        };\n\n        function break_cont(type) {\n                var name;\n                if (!can_insert_semicolon()) {\n                        name = is(\"name\") ? S.token.value : null;\n                }\n                if (name != null) {\n                        next();\n                        if (!member(name, S.labels))\n                                croak(\"Label \" + name + \" without matching loop or statement\");\n                }\n                else if (S.in_loop == 0)\n                        croak(type + \" not inside a loop or switch\");\n                semicolon();\n                return as(type, name);\n        };\n\n        function import_() {\n                var prefixDots = \"\";\n                while (S.token.type == \"punc\" && S.token.value == \".\") {\n                        prefixDots += \".\";\n                        next();\n                }\n\n                var item = expr_atom(false);\n\n                logger.error(S.token.type, S.token.value);\n                if (S.token.type == \"operator\" && S.token.value == \"as\") {\n                        next();\n                        var name = expr_atom(false);\n                        var retVal = as (\"import\", prefixDots, item, \"as\", name);\n                } else {\n                        var retVal = as (\"import\", prefixDots, item);\n                }\n\n                semicolon();\n                return retVal;\n        }\n\n        function for_() {\n                expect(\"(\");\n                var init = null;\n                if (!is(\"punc\", \";\")) {\n                        init = is(\"keyword\", \"var\")\n                                ? (next(), var_(true))\n                                : expression(true, true);\n                        if (is(\"operator\", \"in\")) {\n                                if (init[0] == \"var\" && init[1].length > 1)\n                                        croak(\"Only one variable declaration allowed in for..in loop\");\n                                return for_in(init);\n                        }\n                }\n                return regular_for(init);\n        };\n\n        function regular_for(init) {\n                expect(\";\");\n                var test = is(\"punc\", \";\") ? null : expression();\n                expect(\";\");\n                var step = is(\"punc\", \")\") ? null : expression();\n                expect(\")\");\n                return as(\"for\", init, test, step, in_loop(statement));\n        };\n\n        function for_in(init) {\n                var lhs = init[0] == \"var\" ? as(\"name\", init[1][0]) : init;\n                next();\n                var obj = expression();\n                expect(\")\");\n                return as(\"for-in\", init, lhs, obj, in_loop(statement));\n        };\n\n        var function_ = function(in_statement) {\n                var name = is(\"name\") ? prog1(S.token.value, next) : null;\n                if (in_statement && !name)\n                        unexpected();\n                expect(\"(\");\n                return as(in_statement ? \"defun\" : \"function\",\n                          name,\n                          // arguments\n                          (function(first, a){\n                                  while (!is(\"punc\", \")\")) {\n                                          if (first) first = false; else expect(\",\");\n                                          if (!is(\"name\")) unexpected();\n                                          a.push(S.token.value);\n                                          next();\n                                  }\n                                  next();\n                                  return a;\n                          })(true, []),\n                          // body\n                          (function(){\n                                  ++S.in_function;\n                                  var loop = S.in_loop;\n                                  S.in_directives = true;\n                                  S.in_loop = 0;\n                                  var a = block_();\n                                  --S.in_function;\n                                  S.in_loop = loop;\n                                  return a;\n                          })());\n        };\n\n        function if_() {\n                var cond = parenthesised(), body = statement(), belse;\n                if (is(\"keyword\", \"else\")) {\n                        next();\n                        belse = statement();\n                }\n                return as(\"if\", cond, body, belse);\n        };\n\n        function block_() {\n                expect(\"{\");\n                var a = [];\n                while (!is(\"punc\", \"}\")) {\n                        if (is(\"eof\")) unexpected();\n                        a.push(statement());\n                }\n                next();\n                return a;\n        };\n\n        var switch_block_ = curry(in_loop, function(){\n                expect(\"{\");\n                var a = [], cur = null;\n                while (!is(\"punc\", \"}\")) {\n                        if (is(\"eof\")) unexpected();\n                        if (is(\"keyword\", \"case\")) {\n                                next();\n                                cur = [];\n                                a.push([ expression(), cur ]);\n                                expect(\":\");\n                        }\n                        else if (is(\"keyword\", \"default\")) {\n                                next();\n                                expect(\":\");\n                                cur = [];\n                                a.push([ null, cur ]);\n                        }\n                        else {\n                                if (!cur) unexpected();\n                                cur.push(statement());\n                        }\n                }\n                next();\n                return a;\n        });\n\n        function try_() {\n                var body = block_(), bcatch, bfinally;\n                if (is(\"keyword\", \"catch\")) {\n                        next();\n                        expect(\"(\");\n                        if (!is(\"name\"))\n                                croak(\"Name expected\");\n                        var name = S.token.value;\n                        next();\n                        expect(\")\");\n                        bcatch = [ name, block_() ];\n                }\n                if (is(\"keyword\", \"finally\")) {\n                        next();\n                        bfinally = block_();\n                }\n                if (!bcatch && !bfinally)\n                        croak(\"Missing catch/finally blocks\");\n                return as(\"try\", body, bcatch, bfinally);\n        };\n\n        function vardefs(no_in) {\n                var a = [];\n                for (;;) {\n                        if (!is(\"name\"))\n                                unexpected();\n                        var name = S.token.value;\n                        next();\n                        if (is(\"operator\", \"=\")) {\n                                next();\n                                a.push([ name, expression(false, no_in) ]);\n                        } else {\n                                a.push([ name ]);\n                        }\n                        if (!is(\"punc\", \",\"))\n                                break;\n                        next();\n                }\n                return a;\n        };\n\n        function var_(no_in) {\n                return as(\"var\", vardefs(no_in));\n        };\n\n        function const_() {\n                return as(\"const\", vardefs());\n        };\n\n        function new_() {\n                var newexp = expr_atom(false), args;\n                if (is(\"punc\", \"(\")) {\n                        next();\n                        args = expr_list(\")\");\n                } else {\n                        args = [];\n                }\n                return subscripts(as(\"new\", newexp, args), true);\n        };\n\n        var expr_atom = maybe_embed_tokens(function(allow_calls) {\n                if (is(\"operator\", \"new\")) {\n                        next();\n                        return new_();\n                }\n                if (is(\"punc\")) {\n                        switch (S.token.value) {\n                            case \"(\":\n                                next();\n                                return subscripts(prog1(expression, curry(expect, \")\")), allow_calls);\n                            case \"[\":\n                                next();\n                                return subscripts(array_(), allow_calls);\n                            case \"{\":\n                                next();\n                                return subscripts(object_(), allow_calls);\n                        }\n                        unexpected();\n                }\n                if (is(\"keyword\", \"function\")) {\n                        next();\n                        return subscripts(function_(false), allow_calls);\n                }\n                if (HOP(ATOMIC_START_TOKEN, S.token.type)) {\n                        var atom = S.token.type == \"regexp\"\n                                ? as(\"regexp\", S.token.value[0], S.token.value[1])\n                                : as(S.token.type, S.token.value);\n                        return subscripts(prog1(atom, next), allow_calls);\n                }\n                unexpected();\n        });\n\n        function expr_list(closing, allow_trailing_comma, allow_empty) {\n                var first = true, a = [];\n                while (!is(\"punc\", closing)) {\n                        if (first) first = false; else expect(\",\");\n                        if (allow_trailing_comma && is(\"punc\", closing)) break;\n                        if (is(\"punc\", \",\") && allow_empty) {\n                                a.push([ \"atom\", \"undefined\" ]);\n                        } else {\n                                a.push(expression(false));\n                        }\n                }\n                next();\n                return a;\n        };\n\n        function array_() {\n                return as(\"array\", expr_list(\"]\", !exigent_mode, true));\n        };\n\n        function object_() {\n                var first = true, a = [];\n                while (!is(\"punc\", \"}\")) {\n                        if (first) first = false; else expect(\",\");\n                        if (!exigent_mode && is(\"punc\", \"}\"))\n                                // allow trailing comma\n                                break;\n                        var type = S.token.type;\n                        var name = as_property_name();\n                        if (type == \"name\" && (name == \"get\" || name == \"set\") && !is(\"punc\", \":\")) {\n                                a.push([ as_name(), function_(false), name ]);\n                        } else {\n                                expect(\":\");\n                                a.push([ name, expression(false) ]);\n                        }\n                }\n                next();\n                return as(\"object\", a);\n        };\n\n        function as_property_name() {\n                switch (S.token.type) {\n                    case \"num\":\n                    case \"string\":\n                        return prog1(S.token.value, next);\n                }\n                return as_name();\n        };\n\n        function as_name() {\n                switch (S.token.type) {\n                    case \"name\":\n                    case \"operator\":\n                    case \"keyword\":\n                    case \"atom\":\n                        return prog1(S.token.value, next);\n                    default:\n                        unexpected();\n                }\n        };\n\n        function subscripts(expr, allow_calls) {\n                if (is(\"punc\", \".\")) {\n                        next();\n                        return subscripts(as(\"dot\", expr, as_name()), allow_calls);\n                }\n                if (is(\"punc\", \"[\")) {\n                        next();\n                        return subscripts(as(\"sub\", expr, prog1(expression, curry(expect, \"]\"))), allow_calls);\n                }\n                if (allow_calls && is(\"punc\", \"(\")) {\n                        next();\n                        return subscripts(as(\"call\", expr, expr_list(\")\")), true);\n                }\n                return expr;\n        };\n\n        function maybe_unary(allow_calls) {\n                if (is(\"operator\") && HOP(UNARY_PREFIX, S.token.value)) {\n                        return make_unary(\"unary-prefix\",\n                                          prog1(S.token.value, next),\n                                          maybe_unary(allow_calls));\n                }\n                var val = expr_atom(allow_calls);\n                while (is(\"operator\") && HOP(UNARY_POSTFIX, S.token.value) && !S.token.nlb) {\n                        val = make_unary(\"unary-postfix\", S.token.value, val);\n                        next();\n                }\n                return val;\n        };\n\n        function make_unary(tag, op, expr) {\n                if ((op == \"++\" || op == \"--\") && !is_assignable(expr))\n                        croak(\"Invalid use of \" + op + \" operator\");\n                return as(tag, op, expr);\n        };\n\n        function expr_op(left, min_prec, no_in) {\n                var op = is(\"operator\") ? S.token.value : null;\n                if (op && op == \"in\" && no_in) op = null;\n                var prec = op != null ? PRECEDENCE[op] : null;\n                if (prec != null && prec > min_prec) {\n                        next();\n                        var right = expr_op(maybe_unary(true), prec, no_in);\n                        return expr_op(as(\"binary\", op, left, right), min_prec, no_in);\n                }\n                return left;\n        };\n\n        function expr_ops(no_in) {\n                return expr_op(maybe_unary(true), 0, no_in);\n        };\n\n        function maybe_conditional(no_in) {\n                var expr = expr_ops(no_in);\n                if (is(\"operator\", \"?\")) {\n                        next();\n                        var yes = expression(false);\n                        expect(\":\");\n                        return as(\"conditional\", expr, yes, expression(false, no_in));\n                }\n                return expr;\n        };\n\n        function is_assignable(expr) {\n                if (!exigent_mode) return true;\n                switch (expr[0]+\"\") {\n                    case \"dot\":\n                    case \"sub\":\n                    case \"new\":\n                    case \"call\":\n                        return true;\n                    case \"name\":\n                        return expr[1] != \"this\";\n                }\n        };\n\n        function maybe_assign(no_in) {\n                var left = maybe_conditional(no_in), val = S.token.value;\n                if (is(\"operator\") && HOP(ASSIGNMENT, val)) {\n                        if (is_assignable(left)) {\n                                next();\n                                return as(\"assign\", ASSIGNMENT[val], left, maybe_assign(no_in));\n                        }\n                        croak(\"Invalid assignment\");\n                }\n                return left;\n        };\n\n        var expression = maybe_embed_tokens(function(commas, no_in) {\n                if (arguments.length == 0)\n                        commas = true;\n                var expr = maybe_assign(no_in);\n                if (commas && is(\"punc\", \",\")) {\n                        next();\n                        return as(\"seq\", expr, expression(true, no_in));\n                }\n                return expr;\n        });\n\n        function in_loop(cont) {\n                try {\n                        ++S.in_loop;\n                        return cont();\n                } finally {\n                        --S.in_loop;\n                }\n        };\n\n        return as(\"toplevel\", (function(a){\n                while (!is(\"eof\"))\n                        a.push(statement());\n                return a;\n        })([]));\n\n};\n\n/* -----[ Utilities ]----- */\n\nfunction curry(f) {\n        var args = slice(arguments, 1);\n        return function() { return f.apply(this, args.concat(slice(arguments))); };\n};\n\nfunction prog1(ret) {\n        if (ret instanceof Function)\n                ret = ret();\n        for (var i = 1, n = arguments.length; --n > 0; ++i)\n                arguments[i]();\n        return ret;\n};\n\nfunction array_to_hash(a) {\n        var ret = {};\n        for (var i = 0; i < a.length; ++i)\n                ret[a[i]] = true;\n        return ret;\n};\n\nfunction slice(a, start) {\n        return Array.prototype.slice.call(a, start || 0);\n};\n\nfunction characters(str) {\n        return str.split(\"\");\n};\n\nfunction member(name, array) {\n        for (var i = array.length; --i >= 0;)\n                if (array[i] == name)\n                        return true;\n        return false;\n};\n\nfunction HOP(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n};\n\nvar warn = function() {};\n\n/* -----[ Exports ]----- */\n\nexports.tokenizer = tokenizer;\nexports.parse = parse;\nexports.slice = slice;\nexports.curry = curry;\nexports.member = member;\nexports.array_to_hash = array_to_hash;\nexports.PRECEDENCE = PRECEDENCE;\nexports.KEYWORDS_ATOM = KEYWORDS_ATOM;\nexports.RESERVED_WORDS = RESERVED_WORDS;\nexports.KEYWORDS = KEYWORDS;\nexports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;\nexports.OPERATORS = OPERATORS;\nexports.is_alphanumeric_char = is_alphanumeric_char;\nexports.set_logger = function(logger) {\n        warn = logger;\n};","pre":true},"util/setProperty.js":{"path":"util/setProperty.js","friendlyPath":"jsio.util.setProperty","directory":"util/","filename":"setProperty.js","src":"function createGetter(ctx, name) {\n\treturn function() {\n\t\treturn this[name];\n\t}\n}\n\nfunction createSetter(ctx, name, callback, initialValue) {\n\tif (initialValue !== undefined) {\n\t\tctx[name] = initialValue;\n\t}\n\t\n\tif (typeof callback == 'function') {\n\t\treturn function(value) {\n\t\t\tif (this[name] !== value) {\n\t\t\t\tvar old = this[name];\n\t\t\t\tthis[name] = value;\n\t\t\t\tcallback.call(this, name, value, old);\n\t\t\t}\n\t\t}\n\t} else if (typeof callback == 'string') {\n\t\treturn function(value) {\n\t\t\tif (this[name] !== value) {\n\t\t\t\tvar old = this[name];\n\t\t\t\tthis[name] = value;\n\t\t\t\tthis[callback](name, value, old);\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn function(value) {\n\t\t\tthis[name] = value;\n\t\t}\n\t}\n}\n\nexports = function(ctx, name, def) {\n\tif (!def.get && !def.set && !def.cb && ('value' in def)) {\n\t\tctx[name] = def.value;\n\t} else {\n\t\tif (!def.get) { def.get = createGetter(ctx, '_' + name); }\n\t\tif (!def.set) { def.set = createSetter(ctx, '_' + name, def.cb, def.value); }\n\t\tif ('value' in def) { ctx['_' + name] = def.value; }\n\n\t\tdelete def.value;\n\t\tif (Object.defineProperty) {\n\t\t\tObject.defineProperty(ctx, name, def);\n\t\t\t// merge(def, {\n\t\t\t// \t\t\t\tconfigurable: false,\n\t\t\t// \t\t\t\tenumerable: true\n\t\t\t// \t\t\t});\n\t\t} else if (ctx.__defineSetter__) {\n\t\t\tctx.__defineSetter__(name, def.set);\n\t\t\tctx.__defineGetter__(name, def.get);\n\t\t} else {\n\t\t\tctx[name] = def.value;\n\t\t}\n\t}\n}\n","pre":true},"util/sprintf.js":{"path":"util/sprintf.js","friendlyPath":"jsio.util.sprintf","directory":"util/","filename":"sprintf.js","src":"// XXX: Lets have a reasonable implementation of this fucntion\n//\t  -mcarter 9/18/09\n\n// Code from http://www.webtoolkit.info/javascript-sprintf.html\n// Seems to be an MIT-like license, with linking in source code required\n// License:\n//   As long as you leave the copyright notice of the original script, or link\n//   back to this website, you can use any of the content published on this \n//   website free of charge for any use: commercial or noncommercial.\n//   (http://www.webtoolkit.info/licence.html 9/18/09)\n\n// there was no original copyright notice in the code. just a link to:\n// http://www.webtoolkit.info\n\n\nvar sprintfWrapper = {\n \n\tinit : function () {\n \n\t\tif (typeof arguments == \"undefined\") { return null; }\n\t\tif (arguments.length < 1) { return null; }\n\t\tif (typeof arguments[0] != \"string\") { return null; }\n\t\tif (typeof RegExp == \"undefined\") { return null; }\n \n\t\tvar string = arguments[0];\n\t\tvar exp = new RegExp(/(%([%]|(\\-)?(\\+|\\x20)?(0)?(\\d+)?(\\.(\\d)?)?([bcdfosxX])))/g);\n\t\tvar matches = new Array();\n\t\tvar strings = new Array();\n\t\tvar convCount = 0;\n\t\tvar stringPosStart = 0;\n\t\tvar stringPosEnd = 0;\n\t\tvar matchPosEnd = 0;\n\t\tvar newString = '';\n\t\tvar match = null;\n \n\t\twhile (match = exp.exec(string)) {\n\t\t\tif (match[9]) { convCount += 1; }\n \n\t\t\tstringPosStart = matchPosEnd;\n\t\t\tstringPosEnd = exp.lastIndex - match[0].length;\n\t\t\tstrings[strings.length] = string.substring(stringPosStart, stringPosEnd);\n \n\t\t\tmatchPosEnd = exp.lastIndex;\n\t\t\tmatches[matches.length] = {\n\t\t\t\tmatch: match[0],\n\t\t\t\tleft: match[3] ? true : false,\n\t\t\t\tsign: match[4] || '',\n\t\t\t\tpad: match[5] || ' ',\n\t\t\t\tmin: match[6] || 0,\n\t\t\t\tprecision: match[8],\n\t\t\t\tcode: match[9] || '%',\n\t\t\t\tnegative: parseInt(arguments[convCount]) < 0 ? true : false,\n\t\t\t\targument: typeof(arguments[convCount]) == 'object' ? JSON.stringify(arguments[convCount]) : String(arguments[convCount])\n\t\t\t};\n\t\t}\n\t\tstrings[strings.length] = string.substring(matchPosEnd);\n \n\t\tif (matches.length == 0) { return string; }\n\t\tif ((arguments.length - 1) < convCount) { return null; }\n \n\t\tvar code = null;\n\t\tvar match = null;\n\t\tvar i = null;\n \n\t\tfor (i=0; i<matches.length; i++) {\n \n\t\t\tif (matches[i].code == '%') { substitution = '%' }\n\t\t\telse if (matches[i].code == 'b') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)).toString(2));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i], true);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'c') {\n\t\t\t\tmatches[i].argument = String(String.fromCharCode(parseInt(Math.abs(parseInt(matches[i].argument)))));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i], true);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'd') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'f') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseFloat(matches[i].argument)).toFixed(matches[i].precision ? matches[i].precision : 6));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'o') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)).toString(8));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]);\n\t\t\t}\n\t\t\telse if (matches[i].code == 's') {\n\t\t\t\tmatches[i].argument = matches[i].argument.substring(0, matches[i].precision ? matches[i].precision : matches[i].argument.length)\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i], true);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'x') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)).toString(16));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]);\n\t\t\t}\n\t\t\telse if (matches[i].code == 'X') {\n\t\t\t\tmatches[i].argument = String(Math.abs(parseInt(matches[i].argument)).toString(16));\n\t\t\t\tsubstitution = sprintfWrapper.convert(matches[i]).toUpperCase();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsubstitution = matches[i].match;\n\t\t\t}\n \n\t\t\tnewString += strings[i];\n\t\t\tnewString += substitution;\n \n\t\t}\n\t\tnewString += strings[i];\n \n\t\treturn newString;\n \n\t},\n \n\tconvert : function(match, nosign){\n\t\tif (nosign) {\n\t\t\tmatch.sign = '';\n\t\t} else {\n\t\t\tmatch.sign = match.negative ? '-' : match.sign;\n\t\t}\n\t\tvar l = match.min - match.argument.length + 1 - match.sign.length;\n\t\tvar pad = new Array(l < 0 ? 0 : l).join(match.pad);\n\t\tif (!match.left) {\n\t\t\tif (match.pad == \"0\" || nosign) {\n\t\t\t\treturn match.sign + pad + match.argument;\n\t\t\t} else {\n\t\t\t\treturn pad + match.sign + match.argument;\n\t\t\t}\n\t\t} else {\n\t\t\tif (match.pad == \"0\" || nosign) {\n\t\t\t\treturn match.sign + match.argument + pad.replace(/0/g, ' ');\n\t\t\t} else {\n\t\t\t\treturn match.sign + match.argument + pad;\n\t\t\t}\n\t\t}\n\t}\n}\n \nexports.sprintf = sprintfWrapper.init;","pre":true},"util/syntax.js":{"path":"util/syntax.js","friendlyPath":"jsio.util.syntax","directory":"util/","filename":"syntax.js","src":"jsio('import .esprima');\n\nfunction validate(code, filename) {\n  try {\n    var syntax = esprima.parse(code, { tolerant: true, loc: true });\n    var errors = syntax.errors;\n    if (errors.length > 0) {\n      logErrors(filename, code, errors);\n    }\n  } catch (e) {\n    logErrors(filename, code, [e]);\n  }\n}\n\nfunction padString(str, pad) {\n  str = str + '';\n  while (str.length < pad) {\n    str = ' ' + str;\n  }\n  return str;\n}\n\nfunction logColor(color, str) {\n  if (console.group) {\n    str = '%c' + str;\n    console.log(str, 'color:' + color);\n  } else {\n    console.log(str);\n  }\n}\n\nfunction logErrors(filename, code, errors) {\n  var title = \"Syntax Error (\" + filename + \"):\";\n  if (console.group) {\n    console.group(\"%c\" + title, \"color: red; text-decoration: underline\");\n  } else {\n    console.error(\"Syntax Error:\");\n  }\n\n  var linesBefore = 3;\n  var linesAfter = 3;\n  var lines = code.split('\\n');\n  for (var i = 0; i < errors.length; i += 1) {\n    var e = errors[i];\n    var pad = ('' + (e.lineNumber + linesAfter)).length;\n    printLines(pad, lines, e.lineNumber - linesBefore, e.lineNumber - 1);\n    logColor(\"red\", padString(e.lineNumber, pad) + ' ' + lines[e.lineNumber - 1]);\n\n    logColor(\"blue\", new Array(pad + e.column + 1).join('·') + '^');\n\n    printLines(pad, lines, e.lineNumber + 1, e.lineNumber + 1 + linesAfter);\n\n    logColor(\"red\", \"Line \" + e.lineNumber + \": \" + e.description);\n  }\n\n  console.groupEnd && console.groupEnd();\n}\n\n\nvar printLines = console.group\n  ? function (pad, lines, from, to) {\n      for (var j = from; j <= to; ++j) {\n        console.log('%c' + padString(j, pad) + ' %c' + lines[j - 1], 'color: gray', 'color: auto');\n      }\n    }\n  : function (pad, lines, from, to) {\n      for (var j = from; j <= to; ++j) {\n        console.log(padString(j, pad), lines[j - 1]);\n      }\n    };\n\nexports = validate;\n","pre":true},"util/underscore.js":{"path":"util/underscore.js","friendlyPath":"jsio.util.underscore","directory":"util/","filename":"underscore.js","src":"//     Underscore.js 1.6.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.6.0';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return obj;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, length = obj.length; i < length; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results.push(iterator.call(context, value, index, list));\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !predicate.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    var result = -Infinity, lastComputed = -Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed > lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    var result = Infinity, lastComputed = Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed < lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Shuffle an array, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return value;\n    return _.property(value);\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iterator, context) {\n      var result = {};\n      iterator = lookupIterator(iterator);\n      each(obj, function(value, index) {\n        var key = iterator.call(context, value, index, obj);\n        behavior(result, key, value);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, key, value) {\n    _.has(result, key) ? result[key].push(value) : result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, key, value) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, key) {\n    _.has(result, key) ? result[key]++ : result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    each(input, function(value) {\n      if (_.isArray(value) || _.isArguments(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Split an array into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(array, predicate) {\n    var pass = [], fail = [];\n    each(array, function(elem) {\n      (predicate(elem) ? pass : fail).push(elem);\n    });\n    return [pass, fail];\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.contains(other, item);\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var length = _.max(_.pluck(arguments, 'length').concat(0));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, '' + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(length);\n\n    while(idx < length) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) throw new Error('bindAll must be passed function names');\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n      if (last < wait) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] === void 0) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))\n                        && ('constructor' in a && 'constructor' in b)) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function () {\n      return value;\n    };\n  };\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    return function(obj) {\n      if (obj === attrs) return true; //avoid comparing an object to itself.\n      for (var key in attrs) {\n        if (attrs[key] !== obj[key])\n          return false;\n      }\n      return true;\n    }\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(Math.max(0, n));\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() { return new Date().getTime(); };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}).call(this);\n","pre":true},"base.js":{"path":"base.js","friendlyPath":"jsio.base","directory":"","filename":"base.js","src":"/**\n * base.js\n * This file contains all global functions provided by js.io.\n */\n\nexports.log = jsio.__env.log;\nexports.GLOBAL = jsio.__env.global;\n\n/**\n * Various polyfill methods to ensure js.io implementations provide\n * a baseline of JavaScript functionality. Feature compatibility (localStorage,\n * etc.) should be provided elsewhere.\n */\n\n// Array.isArray\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\n\nif (!Array.isArray) {\n\tArray.isArray = function (arg) {\n\t\treturn Object.prototype.toString.call(arg) === '[object Array]';\n\t}\n};\n\n// Function.prototype.bind\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== \"function\") {\n      // closest thing possible to the ECMAScript 5 internal IsCallable function\n      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP = function () {},\n        fBound = function () {\n          return fToBind.apply(this instanceof fNOP\n                                 ? this\n                                 : oThis,\n                               aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n\n/**\n * DEPRECATED. Old js.io polyfills.\n */\n\nvar SLICE = Array.prototype.slice;\n\n/* Use native isArray if available\n */\nif (typeof Array.isArray === 'function') {\n\texports.isArray = Array.isArray;\n} else {\n\texports.isArray = function (obj) {\n\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n}\n\nexports.bind = function(context, method /*, VARGS*/) {\n\tif(arguments.length > 2) {\n\t\tvar args = SLICE.call(arguments, 2);\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, args.concat(SLICE.call(arguments, 0)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, args.concat(SLICE.call(arguments, 0))); }\n\t} else {\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, arguments); }\n\t}\n}\n\n/**\n * Class constructor.\n */\n\nexports.Class = function(name, parent, proto) {\n\treturn exports.__class__(function() { return this.init && this.init.apply(this, arguments); }, name, parent, proto);\n}\n\nexports.__class__ = function (cls, name, parent, proto) {\n\tvar clsProto = function () {};\n\tvar logger;\n\n\tif (typeof name != 'string') {\n\t\tproto = parent;\n\t\tparent = name;\n\t\tname = null;\n\t}\n\n\tif (name) {\n\t\tlogger = exports.logging.get(name);\n\t}\n\n\tif (!parent) { throw new Error('parent or prototype not provided'); }\n\tif (!proto) { proto = parent; parent = null; }\n\n\tif (parent) {\n\t\tif (exports.isArray(parent)) { // multiple inheritance, use at your own risk =)\n\t\t\tclsProto.prototype = {};\n\t\t\tfor(var i = 0, p; p = parent[i]; ++i) {\n\t\t\t\tif (p == Error && ErrorParentClass) { p = ErrorParentClass; }\n\t\t\t\tfor (var item in p.prototype) {\n\t\t\t\t\tif (!(item in clsProto.prototype)) {\n\t\t\t\t\t\tclsProto.prototype[item] = p.prototype[item];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent = parent[0];\n\t\t} else {\n\t\t\tif (parent == Error && ErrorParentClass) { parent = ErrorParentClass; }\n\t\t\tclsProto.prototype = parent.prototype;\n\t\t}\n\t}\n\n\tvar supr = parent ? function(context, method, args) {\n\t\t\tvar f = parent.prototype[method];\n\t\t\tif (!f) { throw new Error('method ' + method + ' does not exist'); }\n\t\t\treturn f.apply(context, args || []);\n\t\t} : null;\n\n\tvar p = cls.prototype = new clsProto();\n\tp.constructor = cls;\n\tp.__parentClass__ = parent;\n\tif (name) { p.__class__ = name; }\n\tproto.call(p, logger || supr, logger && supr);\n\treturn cls;\n}\n\nvar ErrorParentClass = exports.__class__(function ErrorCls() {\n\t\tvar err = Error.prototype.constructor.apply(this, arguments);\n\t\tfor (var prop in err) {\n\t\t\tif (err.hasOwnProperty(prop)) {\n\t\t\t\tthis[prop] = err[prop];\n\t\t\t}\n\t\t}\n\t}, function() {});\n\n/**\n * Merge two objects together.\n */\n\nexports.Class.defaults =\nexports.merge = function(base, extra) {\n\tbase = base || {};\n\n\tfor (var i = 1, len = arguments.length; i < len; ++i) {\n\t\tvar copyFrom = arguments[i];\n\t\tfor (var key in copyFrom) {\n\t\t\tif (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n\t\t\t\tbase[key] = copyFrom[key];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn base;\n}\n\n/**\n * Create a timer delay.\n */\n\nexports.delay = function(orig, timeout) {\n\tvar _timer = null;\n\tvar ctx, args;\n\tvar f = function() { orig.apply(ctx, args); }\n\treturn function() {\n\t\tctx = this;\n\t\targs = arguments;\n\t\tif (_timer) { clearTimeout(_timer); }\n\t\t_timer = setTimeout(f, timeout || 0);\n\t}\n}\n\n/**\n * Log constructor and default \"logger\".\n */\n\nexports.logging = (function() {\n\n\t// logging namespace, this is what is exported\n\tvar logging = {\n\t\t\tDEBUG: 1,\n\t\t\tLOG: 2,\n\t\t\tINFO: 3,\n\t\t\tWARN: 4,\n\t\t\tERROR: 5,\n\t\t\tNONE: 10\n\t\t};\n\n\tvar _loggers = {}; // all loggers\n\tvar _production = false;\n\tvar _prefix = '';\n\n\tlogging.setPrefix = function(prefix) { _prefix = prefix + ' '; }\n\n\tlogging.setProduction = function(prod) {\n\t\t_production = !!prod;\n\t\tfor (var key in _loggers) {\n\t\t\t_loggers[key].setProduction(_production);\n\t\t}\n\t}\n\n\tlogging.get = function(name) {\n\t\tvar logger = name in _loggers ? _loggers[name] :\n\t\t\t(_loggers[name] = new Logger(name));\n\t\tlogger.setProduction(_production);\n\t\treturn logger;\n\t}\n\n\tlogging.set = function(name, logger) {\n\t\t_loggers[name] = logger;\n\t}\n\n\tlogging.getAll = function() { return _loggers; }\n\n\tlogging.__create = function(pkg, ctx) { ctx.logger = logging.get(pkg); }\n\n\tvar Logger = exports.__class__(\n\t\tfunction Logger(name, level) {\n\t\t\tthis._name = name;\n\t\t\tthis._isProduction = _production;\n\n\t\t\tthis.setLevel(level || logging.LOG);\n\t\t},\n\t\tfunction () {\n\t\t\tthis.setProduction = function (isProduction) {\n\t\t\t\tthis._isProduction = isProduction;\n\t\t\t\tisProduction && this.setLevel(logging.NONE);\n\t\t\t}\n\n\t\t\tthis.setLevel = function(level) {\n\t\t\t\tthis._level = level;\n\n\t\t\t\tif (this._isProduction) {\n\t\t\t\t\tlevel = logging.NONE;\n\t\t\t\t}\n\n\t\t\t\tthis.DEBUG = level <= logging.DEBUG;\n\t\t\t\tthis.LOG   = level <= logging.LOG;\n\t\t\t\tthis.INFO  = level <= logging.INFO;\n\t\t\t\tthis.WARN  = level <= logging.WARN;\n\t\t\t\tthis.ERROR = level <= logging.ERROR;\n\t\t\t}\n\n\t\t\tfunction makeLogger(type) {\n\t\t\t\tvar level = logging[type];\n\t\t\t\treturn function() {\n\t\t\t\t\tif (!this._isProduction && level >= this._level) {\n\t\t\t\t\t\tvar prefix = type + ' ' + _prefix + this._name;\n\t\t\t\t\t\tvar listener = this._listener || exports.log;\n\n\t\t\t\t\t\treturn listener && listener.apply(this._listener, [prefix].concat(SLICE.call(arguments)));\n\t\t\t\t\t}\n\t\t\t\t\treturn arguments[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setListener = function(listener) { this._listener = listener; }\n\n\t\t\tthis.debug = makeLogger(\"DEBUG\");\n\t\t\tthis.log = makeLogger(\"LOG\");\n\t\t\tthis.info = makeLogger(\"INFO\");\n\t\t\tthis.warn = makeLogger(\"WARN\");\n\t\t\tthis.error = makeLogger(\"ERROR\");\n\t\t});\n\n\treturn logging;\n})();\n\nvar logger = exports.logging.get('jsiocore');\n\n","pre":true},"index.js":{"path":"index.js","friendlyPath":"jsio.index","directory":"","filename":"index.js","src":"// This is strictly for nodejs, not browsers.\nrequire('./jsio');\n\n","pre":true},"logging.js":{"path":"logging.js","friendlyPath":"jsio.logging","directory":"","filename":"logging.js","src":"exports.UIWatcher = Class(function() {\n\t\n});","pre":true}});jsio("import jsio_compile.compiler").start()